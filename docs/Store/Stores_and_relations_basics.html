<!DOCTYPE html>
<!--[if lt IE 7]>       <html class="no-js ie6 oldie" lang="en"> <![endif]-->
<!--[if IE 7]>          <html class="no-js ie7 oldie" lang="en"> <![endif]-->
<!--[if IE 8]>          <html class="no-js ie8 oldie" lang="en"> <![endif]-->
<!--[if gt IE 8]><!-->  <html class="no-js" lang="en"> <!--<![endif]-->
<head>
    <title>Stores and relations basics - Type-R</title>
    <meta name="description" content="Universal state management framework" />
    <meta name="author" content="Vlad Balin">
    <meta charset="UTF-8">
    <link rel="icon" href="../themes/daux/img/favicon-navy.png" type="image/x-icon">
    <!-- Mobile -->
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Font -->
    <link href='https://fonts.googleapis.com/css?family=Roboto+Slab:400,100,300,700&subset=latin,cyrillic-ext,cyrillic' rel='stylesheet' type='text/css'>
    <!-- CSS -->
    <link href='../themes/daux/css/theme-navy.min.css' rel='stylesheet' type='text/css'>
            <!-- Tipue Search -->
        <link href="../tipuesearch/tipuesearch.css" rel="stylesheet">
    
    <!--[if lt IE 9]>
    <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
</head>
<body class="">
    
<header class="Navbar hidden-print">
    <a class="Navbar__brand" href="../index.html">Type-R</a>

    <div class="Search">
        <svg class="Search__icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 451 451"><path d="M447.05 428l-109.6-109.6c29.4-33.8 47.2-77.9 47.2-126.1C384.65 86.2 298.35 0 192.35 0 86.25 0 .05 86.3.05 192.3s86.3 192.3 192.3 192.3c48.2 0 92.3-17.8 126.1-47.2L428.05 447c2.6 2.6 6.1 4 9.5 4s6.9-1.3 9.5-4c5.2-5.2 5.2-13.8 0-19zM26.95 192.3c0-91.2 74.2-165.3 165.3-165.3 91.2 0 165.3 74.2 165.3 165.3s-74.1 165.4-165.3 165.4c-91.1 0-165.3-74.2-165.3-165.4z"/></svg>
        <input type="search" id="tipue_search_input" class="Search__field" placeholder="Search..." autocomplete="on" results=25 autosave=text_search>
    </div>
</header>
<div class="Columns content">
    <aside class="Columns__left Collapsible">
        <div class="Collapsible__container">
            <button type="button" class="Button Collapsible__trigger">
                <span class="Collapsible__trigger--bar"></span>
                <span class="Collapsible__trigger--bar"></span>
                <span class="Collapsible__trigger--bar"></span>
            </button>
        </div>

        <div class="Collapsible__content">
            <!-- Navigation -->
            <ul class='Nav'><li class='Nav__item '><a href="../Getting_Started.html">Getting Started</a></li><li class='Nav__item '><a href="../Overview.html">Overview</a></li><li class='Nav__item  has-children'><a href="../Record/Basics.html" class="folder"><i class="Nav__arrow">&nbsp;</i>Record</a><ul class='Nav'><li class='Nav__item '><a href="../Record/Basics.html">Basics</a></li><li class='Nav__item '><a href="../Record/Updates_and_transactions.html">Updates and transactions</a></li><li class='Nav__item '><a href="../Record/Listening_to_events.html">Listening to events</a></li></ul></li><li class='Nav__item  has-children'><a href="../Collection/Basics.html" class="folder"><i class="Nav__arrow">&nbsp;</i>Collection</a><ul class='Nav'><li class='Nav__item '><a href="../Collection/Basics.html">Basics</a></li><li class='Nav__item '><a href="../Collection/Updates_and_transactions.html">Updates and transactions</a></li><li class='Nav__item '><a href="../Collection/Listening_to_events.html">Listening to events</a></li><li class='Nav__item '><a href="../Collection/Iteration_methods.html">Iteration methods</a></li><li class='Nav__item '><a href="../Collection/Sorted_collections.html">Sorted collections</a></li><li class='Nav__item '><a href="../Collection/Proxied_array_methods.html">Proxied array methods</a></li></ul></li><li class='Nav__item  has-children'><a href="../Aggregation_tree/Overview.html" class="folder"><i class="Nav__arrow">&nbsp;</i>Aggregation tree</a><ul class='Nav'><li class='Nav__item '><a href="../Aggregation_tree/Overview.html">Overview</a></li><li class='Nav__item '><a href="../Aggregation_tree/Serialization.html">Serialization</a></li><li class='Nav__item '><a href="../Aggregation_tree/Validation.html">Validation</a></li><li class='Nav__item '><a href="../Aggregation_tree/Shared_objects.html">Shared objects</a></li><li class='Nav__item '><a href="../Aggregation_tree/id-references.html">id-references</a></li></ul></li><li class='Nav__item Nav__item--open has-children'><a href="../Store/Guide.html" class="folder"><i class="Nav__arrow">&nbsp;</i>Store</a><ul class='Nav'><li class='Nav__item '><a href="../Store/Guide.html">Guide</a></li><li class='Nav__item Nav__item--active'><a href="../Store/Stores_and_relations_basics.html">Stores and relations basics</a></li><li class='Nav__item '><a href="../Store/Advanced_stores.html">Advanced stores</a></li></ul></li><li class='Nav__item '><a href="../Events.html">Events</a></li><li class='Nav__item '><a href="../Mixins.html">Mixins</a></li></ul>

            <div class="Links">
                                    <hr/>
                                            <a href="https://github.com/Volicon/React-MVx/issues" target="_blank">Help/Support/Bugs</a>
                        <br />
                                            <a href="http://volicon.com" target="_blank">Made by Volicon (a Verizon company)</a>
                        <br />
                                    
                                    <div class="CodeToggler">
                        <hr/>
                                                    <a class="CodeToggler__button CodeToggler__button--main" href="#">Show Code Blocks Inline</a><br>
                                            </div>
                
                                    <hr/>
                    <div class="Twitter">
                                                    <iframe allowtransparency="true" frameborder="0" scrolling="no" style="width:162px; height:20px;" src="https://platform.twitter.com/widgets/follow_button.html?screen_name=gaperton&amp;show_count=false"></iframe>
                            <br />
                            <br />
                                            </div>
                            </div>
        </div>
    </aside>
    <div class="Columns__right ">
        <div class="Columns__right__content">
            <div class="doc_content">
                <article class="Page">

    <div class="Page__header">
        <h1>Stores and relations basics</h1>
                        <span style="float: right; font-size: 10px; color: gray;">
            <a href="https://github.com/Volicon/React-MVx/blob/develop/docs/06_Store/02_Stores_and_relations_basics.md" target="_blank">Edit on GitHub</a>
        </span>
            </div>


    <div class="s-content">
        <h1 id="page_The+problem">The problem</h1>
<p>When you building complex data layer, sooner or later you will need to cross-reference objects by id. Lets consider
users and roles as an example. For the purpose of the example we assume (and in many real cases its true),
that users and models related to each other as many-to-many.</p>
<p>Two questions arise - how will we send these data in JSON, and how would we ideally want them to appear in our models layer. Lets start with JSON for the users. Obvious solution would be the one as follows:</p>
<pre><code class="language-javascript">const users = [{
    &quot;id&quot; : 1,
    &quot;login&quot; : &quot;Vini&quot;
    &quot;roles&quot; : [ { &quot;id&quot; : 1, &quot;name&quot; : &quot;Admin&quot; }, { &quot;id&quot; : 2, &quot;name&quot; : &quot;User&quot; } ]
},
{
    &quot;id&quot; : 2,
    &quot;login&quot; : &quot;Avraham&quot;
    &quot;roles&quot; : [ { &quot;id&quot; : 1, &quot;name&quot; : &quot;Admin&quot; }, { &quot;id&quot; : 2, &quot;name&quot; : &quot;User&quot; } ]
}, ... ]
</code></pre>
<p>So, our user's model in this case will look like this:</p>
<pre><code class="language-javascript">@define class Role extends Record {
    static attributes = {
        name : String    
    }
}

@define class Users extends Record {
    static attributes = {
        login : String,
        roles : Role.Collection
    }
}
</code></pre>
<p>Obvious problem is that we're transferring the same roles multiple times, which increase the traffic.
Less obvious problem is that when objects for <code>role 1</code> will be deserialized, they will actually become <em>different</em> objects
in every user model. So, when one of them needs to be modified, it should be modified for every user.
In short, as relational DB developer would say, <em>these data are not normalized</em>.</p>
<p>So, the best thing we could do, is to normalize them, putting roles in separate collection. So, our 'users collection'
becomes 'users directory object'.</p>
<pre><code class="language-javascript">{
    &quot;users&quot; : [
        {
            &quot;id&quot; : 1,
            &quot;login&quot; : &quot;Vini&quot;
            &quot;roles&quot; : [ 1, 2 ]
        },
        {
            &quot;id&quot; : 2,inter
            &quot;login&quot; : &quot;Avraham&quot;
            &quot;roles&quot; : [ 1, 2 ]
        }, ...
    ],

    &quot;roles&quot; : [ { &quot;id&quot; : 1, &quot;name&quot; : &quot;Admins&quot; }, { &quot;id&quot; : 2, &quot;name&quot; : &quot;Users&quot; }, ... ]
}
</code></pre>
<p>Now JSON looks okay, and we face the second problem. How would we want it to appear in our data layer?</p>
<h1 id="page_Handling+%22to-many%22+relationship">Handling &quot;to-many&quot; relationship</h1>
<p>I would say, it would be an ideal case if the user of the data layer <em>wouldn't notice</em> this complexity at all.
If it will look for us like full collection of roles, <em>and</em> as nested collections of roles in every user model (but
roles in this nested collection will be actually the references to shared objects in full collection of roles), it would
be just fine.</p>
<p>Fortunately, this is just the thing which NestedTypes allows you to do. It will require some changes to our model definition,
though:</p>
<pre><code class="language-javascript">@define class Role  extends Record {
    static attributes = {
        name : String    
    }
}

@define class Users extends Record{
    static attributes = {
        login : String,
        roles : Role.Collection.subsetOf( '~roles' )
    }
}

@define class UsersDirectory extends Record{
    static attributes = {
        users : User.Collection,
        roles : Role.Collection
    }
}
</code></pre>
<p>There are two new things here - <code>Role.Collection.subsetOf( '~roles' )</code> and <code>Store</code>. Lets understand what does it mean.</p>
<p><code>CollectionType.subsetOf( path )</code> spec literally means that the type of an attribute is the given collection, which will
consists of an elements from different collection with a given <code>path</code> relative to model's <code>this</code>. <code>~</code> is the shortcut
for <code>getStore()</code> method, so <code>~roles</code> path will be resolved to <code>this.getStore().roles</code>. <code>getStore()</code> method, in turn,
will locate the nearest store model traversing object ownership tree upwards, until it will find something which
extends <code>Store</code> base class.</p>
<p><em>Speaking simply, <code>~roles</code> reference points to the <code>roles</code> attribute of the <code>Store</code> model, which is the closest parent
of our model. This semantic is important as it allows us to have multiple store instances in the system at the same time</em>.</p>
<p>Now, how this code works. <code>subsetOf</code> attributes are always serialized as an arrays of model ids. So, it will take
array of roles ids from the JSON, and wait for the moment you will actually try to read it. And when you read
<code>user.roles</code> attribute for the first time, it will take master collection from the path you specified,
and resolve ids to real models.</p>
<p><em>Speaking simply, <code>user.roles</code> will appear to you as if it would be the regular <code>Roles.Collection</code>. And it's the key
point of design that you should notice nothing strange.</em></p>
<p>There are some differences in behaviour, due to the fact that <code>subsetOf</code> is treated as <em>relation</em>, not <em>aggregation</em>:</p>
<ul>
<li>
<code>Collection.subsetOf</code> is considered as changed (and throws 'changes' event) only in case its elements are being added or removed.
<em>No member models changes will trigger collection change, and parent model change.</em>
</li>
<li>When <code>Collection.subsetOf</code> is deep cloned, it doesn't clone its elements.</li>
<li>You can use model ids in the place of the models in <code>set</code> and <code>add</code> methods.</li>
<li>As it was mentioned above, it's serialized to an array of ids.</li>
</ul>
<h1 id="page_Handling+cross-references">Handling cross-references</h1>
<p>Okay. But what if you want <em>both</em> user and role to reference each other? Yep, you can do it too using
the special form of <code>extend</code> for <em>forward declaration</em>:</p>
<pre><code class="language-javascript">// Make forward declaration for the User...
@predefine class User extends Record{}

@define class Role extends Record {
    static attributes = {
        name : String,
        users : User.Collection.subsetOf( '~users' )
    }
}

User.define({
    attributes : {
        login : String,
        roles : Role.Collection.subsetOf( '~roles' )
    }
});

@define class UsersDirectory = Store.extend({
    static attributes = {
        users : User.Collection,
        roles : Role.Collection
    }
}
</code></pre>
<h1 id="page_to-one+relationships+and+default+store">to-one relationships and default store</h1>
<p>Lets say, we have some content created by users. We have few authors, and it would probably be not so bad idea to
reference author of this content in JSON by user <code>id</code>. However, we don't like an idea that all our collections
would be bound to the same store as UserDirectory.</p>
<p>First obvious thing we could do to resolve this situation, is to create some global default <code>store</code> holding all 'dictionary' data which would be used
to resolve such an ids across the system. Lets create such a store:</p>
<pre><code class="language-javascript">Nested.store = new UsersDirectory();
</code></pre>
<p>Once we have <em>default store</em>, it will be used in all cases when ownership store lookup fails. So, we can just define
our standalone BlogPost model.</p>
<p>But wait. BlogPost have just one author, not many. Thus, we don't need <code>Collection</code>, which is <code>subsetOf</code> something.
We need <code>Model</code>, taken <code>from</code> collection.</p>
<pre><code class="language-javascript">const BlogPost = Model.extend({
    attributes : {
        author : Model.from( '~users' ),
        created : Date,
        title : '',
        body : ''
    }
});

let posts = new BlogPost.Collection();
posts.fetch();
</code></pre>
<p>Whenever we have default store populated with data, this <code>post.author</code> attribute will be indistinguishable from regular
nested model attribute. But as with <code>subsetOf</code>, it's not an <em>aggregation</em>, but <em>relation</em>. So, there are some differences:</p>
<ul>
<li>
<code>Model.from</code> is considered as changed (and throws 'change:attr' event) only in case its model is <em>replaced</em>.
<em>No nested model changes will trigger attribute change, and parent model change.</em>
</li>
<li>When <code>Model.from</code> is deep cloned, it doesn't clone its element.</li>
<li>You can assign model <code>id</code> to this attribute.</li>
<li>It's serialized as just model ids.</li>
</ul>
<h2 id="page_Pitfalls">Pitfalls</h2>
<p>There is one problem, however, which you should be aware of. In case when role is being deleted from master collection, you will need to reconcile
users collection, in order to remove extra users. So far, there are no built in mechanics for that, and an easiest
way of doing this is just to fetch UsersDirectory from server again.</p>
<p>Or (if it really important) you can do something like in the example below.</p>
<pre><code class="language-javascript">const UsersDirectory = Model.extend({
  attributes : { ... },
  
  initialize(){
     this.listenTo( this.roles, 'remove', role =&gt; {
        this.users.transaction( () =&gt; { // 'users' will trigger single 'changes' event for bulk operation
            this.users.each( user =&gt; user.roles.remove( role ) );
        });
     });
  }
});
</code></pre>
<p>Or ask us to add generic <code>reconcile</code> method. In older NestedTypes
versions it was hard to do efficient enough to make generic implementation, and also its quite rare situation
when you really need client-side reconcilation; that's why it's not done yet. But now we can.</p>
    </div>

        <nav>
        <ul class="Pager">
            <li class=Pager--prev><a href="../Store/Guide.html">Previous</a></li>            <li class=Pager--next><a href="../Store/Advanced_stores.html">Next</a></li>        </ul>
    </nav>
    </article>

            </div>
        </div>
    </div>
</div>

    
    <!-- jQuery -->
    <script src="../themes/daux/js/jquery-1.11.3.min.js"></script>

    <!-- hightlight.js -->
    <script src="../themes/daux/js/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    <!-- JS -->
    
    <script src="../themes/daux/js/daux.js"></script>

            <!-- Tipue Search -->
        <script type="text/javascript" src="../tipuesearch/tipuesearch.js"></script>

        <script>
            window.onunload = function(){}; // force $(document).ready to be called on back/forward navigation in firefox
            $(function() {
                tipuesearch({
                    'base_url': '../'
                });
            });
        </script>
    
</body>
</html>
