# Record's id

### record.id

Predefined record's attribute, the `id` is an arbitrary string (integer id or UUID).
`id` is typically generated by the server. It is used in JSON for id-references.

Records can be retrieved by `id` from collections, and there can be just one instance
of the record with the same `id` in the particular collection.

### `static` idAttribute = 'attrName'

A record's unique identifier is stored under the `id` attribute.
If you're directly communicating with a backend (CouchDB, MongoDB) that uses a different unique key,
you may set a Record's `idAttribute` to transparently map from that key to id.

Record's `id` property will still be linked to Record's id, no matter which value `idAttribute` has.

```javascript
@define class Meal extends Record {
  static idAttribute =  "_id";
  static attributes = {
      _id : Number,
      name : ''
  }
}

const cake = new Meal({ _id: 1, name: "Cake" });
alert("Cake id: " + cake.id);
```

### record.isNew()

Has this record been saved to the server yet? If the record does not yet have an `id`, it is considered to be new.

# id-references

Serializable references to shared records are called an _id-references_. It is represented as `record.id` in JSON,
and there must be the populated master collection of records on the client in order to resolve ids on parse.

There are two kinds of id-references: one-to-many, and many-to-many. They are declared with the special kind of attribute annotation.
Id-references behaves in the same way as shared attributes, but _inner changes_ in referenced objects are _not observed_.

### `attrDef` attr : Record.from( `sourceCollection` )

Declare an attribute to be the record from the particular collection.

Serialized as `record.id`.

### `attrDef` attr : Collection.subsetOf( `sourceCollection` )

Declare an attribute to be the collection, which is the subset of the particular collection.

Serialized as an array of record ids.

### `sourceCollection` 'path.relative.to.this'

`sourceCollection` may be the string with the dot-separated _relative object path_ to the collection.
In this case, it is resolved dynamically relative to the record's `this`.

    @define class State extends Record {
        items : Item.Collection,
        selected : Record.from( 'items' ) // Will resolve to `this.items`
    }

### `sourceCollection` '^path.relative.to.owner'

`^` symbol in path is being translated to the `getOwner()` call.

> It's recommended to use tilda-references and stores instead.

# Stores and tilda-references

### `abstract class` Store
### `sourceCollection` '~path.relative.to.store'

`Store` is the Record's subclass which serves as a root for id-references.
Any id-reference with a path starting with `~` look for the nearest `Store` subclass traversing the aggregation tree upwards,
and if there are none, it takes the default Store class `Store.global`.

For all objects inside of the store's aggregation tree `~member` will resolve to the member of this store class.
If the lookup will fail, the next available store upper in aggregation tree will be used (as regular records stores can be nested), or the `Store.global` if there are no one.

> Stores in Type-R is _very different_ to stores in other framework. Pay attention.

```javascript
@define class Role extends Record {
    static attributes = {
        name : String,
        ...
    }
}

@define class User extends Record {
    static attributes = {
        name : String,
        roles : Role.Collection.subsetOf( '~roles' )
    }
}

@define class UsersDirectory extends Store {
    static attributes = {
        roles : Role.Collection,
        users : User.Collection // `~roles` references will be resolved against this.roles
    }
}
```

### Store.global

The default store class. Is always the last store to lookup when resolving tilda-reference.

Use the default store for the _globally shared data only_. Each application page must have its local store.

```javascript
@define class MyStore extends Store {
    static attributes = {
        users : User.Collection,
        roles : Role.Collection
    }
}

Store.global = new MyStore();

// Now the reference '~users` will point to users collection from the MyStore.
```
