<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <title>API Reference</title>

    <link rel="icon" href="images/type-r-logo-dark.png" />
    <link href="lib/stylesheets/screen.css" rel="stylesheet" type="text/css" media="screen" />
    <link href="lib/stylesheets/print.css" rel="stylesheet" type="text/css" media="print" />
    <link href="lib/stylesheets/default.css" rel="stylesheet" type="text/css" />

    <style>
      .logo-section img {
        vertical-align: middle;
        margin: 15px;
        height: 48px;
      }

      .logo-section .logo-text {
        vertical-align: middle;
        color: white;
        display: inline-block;
      }

      .logo-section .logo-caption {
        font-size: 28px;
      }

    </style>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>
      <script src="lib/javascripts/all.js" type="text/javascript"></script>

      <script>
        $(function() {
          var langs = [];
          setupLanguages( langs );
        });
      </script>
  </head>

  <body class="index">
    <a href="#" id="nav-button">
      <span>
        NAV
        <img src="images/navbar.png" />
      </span>
    </a>
    <div class="tocify-wrapper">
      <div class="logo-section">
        <img src="images/logo.png" />
        <div class="logo-text">
          <div class="logo-caption">Type-R</div>
          <div>universal state management</div>
        </div>
        
      </div>
        <div class="lang-selector">
        </div>
        <div class="search">
          <input type="text" class="search" id="input-search" placeholder="Search">
        </div>
        <ul class="search-results"></ul>
      <div id="toc">
      </div>
        <ul class="toc-footer">
                <li>Developed by <img style="vertical-align: middle" src="images/volicon_verizon_dm.png" href='#'/></li>
        </ul>
    </div>
    <div class="page-wrapper">
        <div class="content">
          <h1 id="getting-started">Getting started</h1>
<p>Type-R is the universal state management framework for both UI and domain state.</p>
<p>Application state is described with the superposition of two main container types - <a href="04_Record/00_Overview.md">Record</a> and <a href="./05_Collection/00_Overview.md">Collection</a> of records. The state has observable changes and is serializable by default.</p>
<ul>
<li>Records are classes with typed attributes. They are protected from attributes assignment of incompatible types with run-time type assertions and conversions. Which means that the client-server protocol is protected from both ends.</li>
<li>Records distinguish <a href="06_API_by_feature/01_Aggregation_tree.md">aggregated attributes</a> and those which are <a href="06_API_by_feature/04_Shared_objects.md">references to shared objects</a>. Aggregated attributes are serialized as nested JSON, while references might be <a href="06_API_by_feature/05_id-references_and_Stores.md">serialized as ids</a>. Operations like <code>clone()</code>, <code>dispose()</code>, and <code>toJSON()</code> are performed recursively on elements of aggregation tree.</li>
<li>Type-R features declarative <a href="06_API_by_feature/03_Validation.md">validation</a> with attribute-level rules. Validation is transparent and lazily evaluated.</li>
<li>Architecture does not depend on stores and singletons. <a href="05_API_by_feature/05_id-references_and_Stores.md">Stores</a> are optional and used for shared data only. There might be as many stores as you need, and they can be created and disposed dynamically.</li>
<li>Type-R data structures are pretty efficient. They are about 10 times faster in real-world data scenarios than BackboneJS.</li>
</ul>
<h2 id="installation">Installation</h2>
<p>Is packed as UMD and ES6 module. No side dependencies.</p>
<p><code>npm install type-r --save-dev</code></p>
<h2 id="requirements">Requirements</h2>
<p>IE10+, Edge, Safari, Chrome, and Firefox are supported.</p>
<p>IE9 and Opera may work but has not been tested. IE8 <em>won&#39;t work</em>.</p>
<h2 id="how-the-type-r-compares-with-x-">How the Type-R compares with X?</h2>
<p>Type-R is designed to be the substitution for BackboneJS, which was used extensively 3 years ago in Volicon/Verizon Observer products. While it largely backward compatible by its API with BackboneJS (for Events and Collections), it&#39;s entirely different internally.</p>
<p>In its core, it&#39;s an engine for managing the <em>aggregation trees</em> composed of nested Records and Collections. It contains no View, Router, REST, and jQuery/Underscore dependencies.</p>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Type-R</th>
<th>BackboneJS</th>
<th>EmberJS</th>
<th>mobx</th>
</tr>
</thead>
<tbody>
<tr>
<td>View and Router</td>
<td>-</td>
<td>✓</td>
<td>✓</td>
<td>-</td>
</tr>
<tr>
<td>Models</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>Objects as models</td>
</tr>
<tr>
<td>Collections</td>
<td>✓</td>
<td>✓</td>
<td>modeled as relations</td>
<td>Arrays as collections</td>
</tr>
<tr>
<td>Nested Data Strictures</td>
<td>as aggregation trees and relations</td>
<td>-</td>
<td>as relations</td>
<td>as object graph</td>
</tr>
<tr>
<td>Relations by id</td>
<td>resolved agains the chain of dynamic stores</td>
<td>-</td>
<td>resolved agains the global store</td>
<td>- </td>
</tr>
<tr>
<td>JSON Serialization</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>-</td>
</tr>
<tr>
<td>Validation</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>-</td>
</tr>
</tbody>
</table>

<h1 id="record">Record</h1>
<p>Record is the serializable class with typed attributes, observable changes, and custom validation checks. It is the main building block for managing the application state; component local state, stores, and collection elements are all subclasses of the <code>Record</code>.</p>
<p>In contrast to the &quot;model&quot; class in the majority of data frameworks, Record is <em>not the key-value hash</em>. It&#39;s the class with statically defined set of attributes of known types.</p>
<p><code>Record</code> itself is an abstract class. The subclass needs to be defined for every data structure of different shape, in a similar way as it&#39;s done in statically typed languages.</p>
<pre><code class="highlight javascript">import { define, Record } from 'type-r'

// ⤹ required to make magic work  
@define class User extends Record {
    // ⤹ attribute's declaration
    static attributes = {
        firstName : '', // ⟵ String type is inferred from the default value
        lastName  : String, // ⟵ Or you can just mention its constructor
        email     : String.value( null ), //⟵ Or you can provide both
        createdAt : Date, // ⟵ And it works for any constructor.
        // And you can attach ⤹ metadata to fine-tune attribute's behavior
        lastLogin : Date.value( null ).has.toJSON( false ) // ⟵ not serializable
    }
}

const user = new User();
console.log( user.createdAt ); // ⟵ this is an instance of Date created for you.

const users = new User.Collection(); // ⟵ Collections are defined automatically.
users.on( 'changes', () =&gt; updateUI( users ) ); // ⟵ listen to the changes.

users.set( json, { parse : true } ); // ⟵ parse raw JSON from the server.
users.updateEach( user =&gt; user.firstName = '' ); // ⟵ bulk update triggering 'changes' once
</code></pre>
<h2 id="define">Define</h2>
<p>Record definition must:</p>
<ul>
<li>be the class extending the <code>Record</code>;</li>
<li>be preceded with the <code>@define</code> decorator;</li>
<li>have <code>static attributes</code> definition.</li>
</ul>
<h3 id="-decorator-define"><code>decorator</code> @define</h3>
<p><em>Must</em> be placed before record class definition.</p>
<pre><code class="highlight javascript"><span class="hljs-keyword">import</span> { define, Record } <span class="hljs-keyword">from</span> <span class="hljs-string">'type-r'</span>

@define class X extends Record {
    ...    
}
</code></pre>
<h3 id="-static-attributes-name-attrdef-"><code>static</code> attributes = { name : <code>attrDef</code>, ... }</h3>
<p>Record&#39;s attributes definition. Lists attribute names along with their types, default values, and metadata controlling different aspects of attribute behavior.</p>
<pre><code class="highlight javascript">@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    static attributes = {
        name    : <span class="hljs-built_in">String</span>.value( <span class="hljs-string">'John Dow'</span> ),
        email   : <span class="hljs-string">'john.dow@mail.com'</span>, <span class="hljs-comment">// Same as String.value( 'john.dow@mail.com' )</span>
        address : <span class="hljs-built_in">String</span>, <span class="hljs-comment">// Same as String.value( '' )</span>
    }
}
</code></pre>
<p>The Record guarantee that <em>every attribute will retain the value of the declared type</em>. Whenever an attribute is being assigned with the value which is not compatible with its declared type, the type is being converted with an invocation of the constructor: <code>new Type( value )</code> (primitive types are treated specially).</p>
<h3 id="-attrdef-name-type"><code>attrDef</code> name : Type</h3>
<p>When the function is used as <code>attrDef</code>, it&#39;s treated as the constructor function. Any constructor function which behaves as <em>converting constructor</em> (like <code>new Date( msecs )</code>) may be used as an attribute type.</p>
<p>You can use other record&#39;s and collection&#39;s constructors as attribute types. They will be treated as an <em>integral part</em> of the record (created, serialized, validated, and disposed together), i.e. as <em>aggregated members</em>.</p>
<pre><code class="highlight javascript">@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    static attributes = {
        name : <span class="hljs-built_in">String</span> <span class="hljs-comment">// String attribute which is "" by default.</span>
        createdAt : <span class="hljs-built_in">Date</span> <span class="hljs-comment">// Date attribute</span>
        ...
    }
}
</code></pre>
<h3 id="-attrdef-name-defaultvalue"><code>attrDef</code> name : defaultValue</h3>
<p>When value of other type than function is used as <code>attrDef</code> it&#39;s treated as attribute&#39;s default value. Attribute&#39;s type is being inferred from the value.</p>
<p>Use the general form of attribute definition for attributes of <code>Function</code> type: <code>Function.value( theFunction )</code>.</p>
<pre><code class="highlight javascript">@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GridColumn</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    static attributes = {
        name : <span class="hljs-string">''</span>, <span class="hljs-comment">// String attribute which is '' by default.</span>
        render : <span class="hljs-built_in">Function</span>.value( x =&gt; x ),
        ...
    }
}
</code></pre>
<h3 id="-attrdef-name-type-value-defaultvalue-"><code>attrDef</code> name : Type.value( defaultValue )</h3>
<p>The general form of attribute definition is <code>Type.value( defaultValue )</code>, where the <code>Type</code> is the corresponding constructor function.</p>
<pre><code class="highlight javascript">@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    static attributes = {
        phone : <span class="hljs-built_in">String</span>.value( <span class="hljs-literal">null</span> ) <span class="hljs-comment">// String attribute which is null by default.</span>
        ...
    }
}
</code></pre>
<h2 id="create">Create</h2>
<p>Record behaves as regular ES6 class with attributes accessible as properties.</p>
<h3 id="new-record-">new Record()</h3>
<p>Create an instance of the record with default attribute values taken from the attributes definition.</p>
<p>When no default value is explicitly provided for an attribute, it&#39;s initialized as <code>new Type()</code> (just <code>Type()</code> for primitives). When the default value is provided and it&#39;s not compatible with the attribute type, it&#39;s converted with <code>new Type( defaultValue )</code> call.</p>
<h3 id="new-record-attrname-value-options-">new Record({ attrName : value, ... }, options? )</h3>
<p>When creating an instance of a record, you can pass in the initial attribute values to override the defaults.</p>
<p>If <code>{parse: true}</code> option is used, <code>attrs</code> is assumed to be the JSON.</p>
<p>If the value of the particular attribute is not compatible with its type, it&#39;s converted to the declared type invoking the constructor <code>new Type( value )</code> (just <code>Type( value )</code> for primitives).</p>
<pre><code class="highlight javascript">@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    static attributes = {
        title  : <span class="hljs-string">''</span>,
        author : <span class="hljs-string">''</span>
    }
}

<span class="hljs-keyword">const</span> book = <span class="hljs-keyword">new</span> Book({
  title: <span class="hljs-string">"One Thousand and One Nights"</span>,
  author: <span class="hljs-string">"Scheherazade"</span>
});
</code></pre>
<h3 id="-abstract-record-initialize-attrs-options-"><code>abstract</code> record.initialize( attrs?, options? )</h3>
<p>Called at the end of the <code>Record</code> constructor when all attributes are assigned and the record&#39;s inner state is properly initialized. Takes the same arguments as
a constructor.</p>
<h3 id="record-attrname">record.attrName</h3>
<p>Record&#39;s attributes may be directly accessed as <code>record.name</code>.</p>
<blockquote>
<p>Please note, that you <em>have to declare all attributes</em> in <code>static attributes</code> declaration.</p>
</blockquote>
<pre><code class="highlight javascript">@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Account</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    static attributes = {
        name : <span class="hljs-built_in">String</span>,
        balance : <span class="hljs-built_in">Number</span>
    }
}

<span class="hljs-keyword">const</span> myAccount = <span class="hljs-keyword">new</span> Account({ name : <span class="hljs-string">'mine'</span> });
myAccount.balance += <span class="hljs-number">1000000</span>; <span class="hljs-comment">// That works. Good, eh?</span>
</code></pre>
<h2 id="update">Update</h2>
<h3 id="record-attrname-value">record.attrName = value</h3>
<p>Assign the record&#39;s attribute. If the value is not compatible with attribute&#39;s type from the declaration, it is converted:</p>
<ul>
<li>with <code>Type( value )</code> call, for primitive types;</li>
<li>with <code>record.attrName.set( value )</code>, for existing record or collection (updated in place);</li>
<li>with <code>new Type( value )</code> in all other cases.</li>
</ul>
<p>Record triggers events on changes:</p>
<ul>
<li><code>change:attrName</code> <em>( record, value )</em>.</li>
<li><code>change</code> <em>( record )</em>.</li>
</ul>
<pre><code class="highlight javascript">@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    static attributes = {
        title : <span class="hljs-built_in">String</span>,
        author : <span class="hljs-built_in">String</span>
        price : <span class="hljs-built_in">Number</span>,
        publishedAt : <span class="hljs-built_in">Date</span>,
        available : <span class="hljs-built_in">Boolean</span>
    }
}

<span class="hljs-keyword">const</span> myBook = <span class="hljs-keyword">new</span> Book({ title : <span class="hljs-string">"State management with Type-R"</span> });
myBook.author = <span class="hljs-string">'Vlad'</span>; <span class="hljs-comment">// That works.</span>
myBook.price = <span class="hljs-string">'Too much'</span>; <span class="hljs-comment">// Converted with Number( 'Too much' ), resulting in NaN.</span>
myBook.price = <span class="hljs-string">'123'</span>; <span class="hljs-comment">// = Number( '123' ).</span>
myBook.publishedAt = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(); <span class="hljs-comment">// Type is compatible, no conversion.</span>
myBook.publishedAt = <span class="hljs-string">'1678-10-15 12:00'</span>; <span class="hljs-comment">// new Date( '1678-10-15 12:00' )</span>
myBook.available = some &amp;&amp; weird || condition; <span class="hljs-comment">// Will always be Boolean. Or null.</span>
</code></pre>
<h3 id="record-set-attrname-value-options-options-">record.set( { attrName : value, ... }, options? : <code>options</code> )</h3>
<p>Bulk assign record&#39;s attributes, possibly taking options.</p>
<p>If the value is not compatible with attribute&#39;s type from the declaration, it is converted:</p>
<ul>
<li>with <code>Type( value )</code> call, for primitive types.</li>
<li>with <code>record.attrName.set( value )</code>, for existing record or collection (updated in place).</li>
<li>with <code>new Type( value )</code> in all other cases.</li>
</ul>
<p>Record triggers events after all changes are applied:</p>
<ol>
<li><code>change:attrName</code> <em>( record, val, options )</em> for any changed attribute.</li>
<li><code>change</code> <em>(record, options)</em>, if there were changed attributes.</li>
</ol>
<h3 id="-options-parse-true-"><code>options</code> { parse : true }</h3>
<p>Assume <code>record.set</code> argument is the raw JSON and parse it. Must be used to process the response from the server.</p>
<pre><code class="highlight javascript"><span class="hljs-comment">// Another way of doing the bestSeller.clone()</span>
<span class="hljs-comment">// Amazingly, this is guaranteed to work by default.</span>
<span class="hljs-keyword">const</span> book = <span class="hljs-keyword">new</span> Book();
book.set( bestSeller.toJSON(), { parse : <span class="hljs-literal">true</span> } );
</code></pre>
<h3 id="record-assignfrom-otherrecord-">record.assignFrom( otherRecord )</h3>
<p>Makes an existing <code>record</code> to be the full clone of <code>otherRecord</code>, recursively assigning all attributes.</p>
<pre><code class="highlight javascript"><span class="hljs-comment">// Another way of doing the bestSeller.clone()</span>
<span class="hljs-keyword">const</span> book = <span class="hljs-keyword">new</span> Book();
book.assignFrom( bestSeller );
</code></pre>
<h3 id="record-transaction-fun-">record.transaction( fun )</h3>
<p>Execute the all changes made to the record in <code>fun</code> as single transaction triggering the single <code>change</code> event.</p>
<p>All record updates occurs in the scope of transactions. Transaction is the sequence of changes which results in a single <code>change</code> event.
Transaction can be opened either manually or implicitly with calling <code>set()</code> or assigning an attribute.
Any additional changes made to the record in <code>change:attr</code> event handler will be executed in the scope of the original transaction, and won&#39;t trigger additional <code>change</code> events.</p>
<pre><code class="highlight javascript">some.record.transaction( record =&gt; {
    record.a = <span class="hljs-number">1</span>; <span class="hljs-comment">// `change:a` event is triggered.</span>
    record.b = <span class="hljs-number">2</span>; <span class="hljs-comment">// `change:b` event is triggered.</span>
}); <span class="hljs-comment">// `change` event is triggered.</span>
</code></pre>
<p>Manual transactions with attribute assignments are superior to <code>record.set()</code> in terms of both performance and flexibility.</p>
<h2 id="change-events">Change events</h2>
<p>Object tree formed by nested records and collection is deeply observable by default; changes in every attribute trigger change events for the record and all parent elements in sequence.</p>
<p>Record triggers following events on change:</p>
<ul>
<li><code>change:attrName</code> <em>( record, value )</em> for every changed attribute.</li>
<li><code>change</code> <em>( record )</em> when record is changed.</li>
</ul>
<h3 id="-attrdef-attr-type-has-changeevents-false-"><code>attrDef</code> attr : Type.has.changeEvents( false )</h3>
<p>Record automatically listens to change events of all nested records and collections, triggering appropriate change events for its attributes. This declaration turns it off for the specific attribute.</p>
<h2 id="listening-to-changes-with-events-api">Listening to changes with Events API</h2>
<p><a href="../10_Events.md">Events API</a> is used for managing events subscriptions.</p>
<h3 id="listener-listento-record-event-handler-">listener.listenTo( record, event, handler )</h3>
<p><a href="../10_Events.md">Events API</a> method used to listen to the any of the change events.</p>
<h3 id="listener-stoplistening-record-">listener.stopListening( record )</h3>
<p><a href="../10_Events.md">Events API</a> method to explicitly stop all event subscriptions from the record.</p>
<p>Not needed if the listener is other record or collection.</p>
<h2 id="listening-to-events-in-a-record">Listening to events in a record</h2>
<p>Record has declarative API for managing custom event subscriptions for its attributes.</p>
<h3 id="-attrdef-attr-type-has-watcher-methodname-"><code>attrDef</code> attr : Type.has.watcher( &#39;methodName&#39; )</h3>
<h3 id="-attrdef-attr-type-has-watcher-function-value-name-"><code>attrDef</code> attr : Type.has.watcher( function( value, name ){ ... } )</h3>
<p>Attach <code>change:attr</code> event listener to the particular record&#39;s attribute.</p>
<p><em>Watcher function</em> has the signature <code>( attrValue, attrName ) =&gt; void</code> and is executed in the context of the record. Note that it differs from the event signature.</p>
<pre><code class="highlight javascript">@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    static attributes = {
        name : <span class="hljs-built_in">String</span>.has.watcher( <span class="hljs-string">'onNameChange'</span> ),
        isAdmin : <span class="hljs-built_in">Boolean</span>,
    }

    onNameChange(){
        <span class="hljs-comment">// Cruel. But we need it for the purpose of the example.</span>
        <span class="hljs-keyword">this</span>.isAdmin = <span class="hljs-keyword">this</span>.name.indexOf( <span class="hljs-string">'Admin'</span> ) &gt;= <span class="hljs-number">0</span>;
    }
}
</code></pre>
<h3 id="-attrdef-attr-type-has-events-eventname-handler-"><code>attrDef</code> attr : Type.has.events({ eventName : handler, ... })</h3>
<p>Automatically manage custom event subscription for the attribute. <code>handler</code> is either the method name or the handler function.</p>
<h2 id="change-inspection-methods">Change inspection methods</h2>
<p>Following API might be useful in change event listeners.</p>
<h3 id="record-changed">record.changed</h3>
<p>The <code>changed</code> property is the internal hash containing all the attributes that have changed during its last transaction.
Please do not update <code>changed</code> directly since its state is internally maintained by <code>set()</code>.
A copy of <code>changed</code> can be acquired from <code>changedAttributes()</code>.</p>
<h3 id="record-changedattributes-attrs-">record.changedAttributes( attrs? )</h3>
<p>Retrieve a hash of only the record&#39;s attributes that have changed during the last transaction,
or false if there are none. Optionally, an external attributes hash can be passed in,
returning the attributes in that hash which differ from the record.
This can be used to figure out which portions of a view should be updated,
or what calls need to be made to sync the changes to the server.</p>
<h3 id="record-previous-attr-">record.previous( attr )</h3>
<p>During a &quot;change&quot; event, this method can be used to get the previous value of a changed attribute.</p>
<pre><code class="highlight javascript">@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span></span>{
    static attributes = {
        name: <span class="hljs-string">''</span>
    }
}

<span class="hljs-keyword">const</span> bill = <span class="hljs-keyword">new</span> Person({
  name: <span class="hljs-string">"Bill Smith"</span>
});

bill.on(<span class="hljs-string">"change:name"</span>, ( record, name ) =&gt; {
  alert( <span class="hljs-string">`Changed name from <span class="hljs-subst">${ bill.previous('name') }</span> to <span class="hljs-subst">${ name }</span>`</span>);
});

bill.name = <span class="hljs-string">"Bill Jones"</span>;
</code></pre>
<h3 id="record-previousattributes-">record.previousAttributes()</h3>
<p>Return a copy of the record&#39;s previous attributes. Useful for getting a diff between versions of a record, or getting back to a valid state after an error occurs.</p>
<h1 id="collection">Collection</h1>
<p>Collections are ordered sets of records. You can bind &quot;change&quot; events to be notified when any record in the collection has been modified, listen for &quot;add&quot; and &quot;remove&quot; events, fetch the collection from the server, and use a full suite of Underscore.js methods.</p>
<p>Collection is implicitly defined for every record with a constructor accessible as <code>MyRecord.Collection</code>. In most cases, you
don&#39;t need to declare it manually.</p>
<pre><code class="highlight javascript"><span class="hljs-comment">// Implicitly defined collection.</span>
<span class="hljs-keyword">const</span> books = <span class="hljs-keyword">new</span> Book.Collection();

@define
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ComicsShelve</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Book</span>.<span class="hljs-title">Collection</span> </span>{
    static itemEvents = {
        <span class="hljs-comment">// List of records's events we want to be triggered on the collection</span>
        <span class="hljs-string">'change:inMyReadingList'</span> : <span class="hljs-literal">true</span>,
        <span class="hljs-string">'customEvent'</span> : <span class="hljs-literal">true</span>
    }
}

@define
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Comics</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Book</span> </span>{
    <span class="hljs-comment">// Use custom collection instead of the implicitly created one</span>
    static Collection = ComicsShelve;

    <span class="hljs-comment">// Extend record's attributes</span>
    static attributes = {
        artist : Author
    }
}
</code></pre>
<h2 id="collection-definition">Collection definition</h2>
<h3 id="recordconstructor-collection">RecordConstructor.Collection</h3>
<p>Every <code>Record</code> class has implicitly defined Collection, which can be referenced adding the <code>.Collection</code> to the record&#39;s constructor.</p>
<h3 id="-record-definition-static-collection-collectionconstructor">(record definition) <code>static</code> Collection = CollectionConstructor</h3>
<p>Replaces implicitly defined collection with externally defined collection class.</p>
<h3 id="-collection-definition-static-model-recordconstructor">(collection definition) <code>static</code> model = RecordConstructor</h3>
<p>Specify the record type inside of the collection&#39;s definition. This property is being set automatically for collection types referenced as <code>MyRecord.Collection</code>.</p>
<pre><code class="highlight javascript">@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Library</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span>.<span class="hljs-title">Collection</span> </span>{
    static model = Book;
}
</code></pre>
<h2 id="create-and-access-the-collection">Create and access the collection</h2>
<h3 id="new-collection-">new Collection()</h3>
<p>Create an empty collection.</p>
<h3 id="new-collection-records-options-">new Collection( records, options? )</h3>
<p>When creating a Collection, you may choose to pass in the initial array of records. The collection&#39;s comparator may be included as an option. Passing <code>false</code> as the comparator option will prevent sorting. If you define an <code>initialize()</code> function, it will be invoked when the collection is created.</p>
<pre><code class="highlight javascript"><span class="hljs-keyword">var</span> tabs = <span class="hljs-keyword">new</span> TabSet([tab1, tab2, tab3]);
</code></pre>
<h3 id="collection-initialize-records-options-">collection.initialize( records?, options? )</h3>
<p>Initialization function which is called at the end of the constructor.</p>
<h3 id="collection-get-id-">collection.get( id )</h3>
<p>Get a record from a collection, specified by an <code>id</code>, a <code>cid</code>, or by passing in a record.</p>
<pre><code class="highlight javascript"><span class="hljs-keyword">const</span> book = library.get(<span class="hljs-number">110</span>);
</code></pre>
<h3 id="collection-at-index-">collection.at( index )</h3>
<p>Get a record from a collection, specified by index. Useful if your collection is sorted, and if your collection isn&#39;t sorted, at will still retrieve records in insertion order. When passed a negative index, it will retrieve the record from the back of the collection.</p>
<h3 id="collection-length">collection.length</h3>
<p>Like an array, a Collection maintains a length property, counting the number of records it contains.</p>
<h3 id="collection-models">collection.models</h3>
<p>Raw access to the JavaScript array of records inside of the collection. Usually you&#39;ll want to use <code>get</code>, <code>at</code>, or the other methods to access record objects, but occasionally a direct reference to the array is desired.</p>
<h2 id="updates">Updates</h2>
<p>Methods to update the collection. They accept common options:</p>
<ul>
<li><code>sort : false</code> - do not sort the collection.</li>
<li><code>parse : true</code> - parse raw JSON (used to set collection with a data from the server).</li>
</ul>
<h3 id="collection-add-records-options-">collection.add( records, options? )</h3>
<p>Add a record (or an array of records) to the collection. If this is the <code>Record.Collection</code>, you may also pass raw attributes objects, and have them be vivified as instances of the <code>Record</code>. Returns the added (or preexisting, if duplicate) records.</p>
<p>Pass <code>{at: index}</code> to splice the record into the collection at the specified index. If you&#39;re adding records to the collection that are already in the collection, they&#39;ll be ignored, unless you pass <code>{merge: true}</code>, in which case their attributes will be merged into the corresponding records.</p>
<ol>
<li>Trigger the one event per record:<ul>
<li><code>add</code>(record, collection, options) for each record added.</li>
<li><code>change</code>(record, options) for each record changed (if the <code>{merge: true}</code> option is passed).</li>
</ul>
</li>
<li>Trigger the single event:<ul>
<li><code>update</code>(collection, options) if any records were added.</li>
<li><code>sort</code>(collection, options) if an order of records was changed.</li>
</ul>
</li>
<li>Trigger <code>changes</code> event in case if any changes were made to the collection and objects inside.</li>
</ol>
<h3 id="collection-remove-records-options-">collection.remove( records, options? )</h3>
<p>Remove a record (or an array of records) from the collection, and return them. Each record can be a record instance, an id string or a JS object, any value acceptable as the id argument of collection.get.</p>
<ol>
<li>Trigger <code>remove</code>(record, collection, options) for each record removed.</li>
<li>If any records were removed, trigger:<ul>
<li><code>update</code>(collection, options)</li>
<li><code>changes</code>(collection, options).</li>
</ul>
</li>
</ol>
<h3 id="collection-set-records-options-">collection.set( records, options? )</h3>
<p>The set method performs a &quot;smart&quot; update of the collection with the passed list of records. If a record in the list isn&#39;t yet in the collection it will be added; if the record is already in the collection its attributes will be merged; and if the collection contains any records that aren&#39;t present in the list, they&#39;ll be removed. All of the appropriate &quot;add&quot;, &quot;remove&quot;, and &quot;change&quot; events are fired as this happens. Returns the touched records in the collection. If you&#39;d like to customize the behavior, you can disable it with options: <code>{remove: false}</code>, or <code>{merge: false}</code>.</p>
<h4 id="events">Events</h4>
<ol>
<li>Trigger the one event per record:<ul>
<li><code>add</code>(record, collection, options) for each record added.</li>
<li><code>remove</code>(record, collection, options) for each record removed.</li>
<li><code>change</code>(record, options) for each record changed.</li>
</ul>
</li>
<li>Trigger the single event:<ul>
<li><code>update</code>(collection, options) if any records were added.</li>
<li><code>sort</code>(collection, options) if an order of records was changed.</li>
</ul>
</li>
<li>Trigger <code>changes</code> event in case if any changes were made to the collection and objects inside.</li>
</ol>
<pre><code class="highlight javascript"><span class="hljs-keyword">const</span> vanHalen = <span class="hljs-keyword">new</span> Man.Collection([ eddie, alex, stone, roth ]);

vanHalen.set([ eddie, alex, stone, hagar ]);

<span class="hljs-comment">// Fires a "remove" event for roth, and an "add" event for hagar.</span>
<span class="hljs-comment">// Updates any of stone, alex, and eddie's attributes that may have</span>
<span class="hljs-comment">// changed over the years.</span>
</code></pre>
<h3 id="collection-reset-records-options-">collection.reset( records, options? )</h3>
<p>Replace the collection&#39;s content with the new records. More efficient than <code>collection.set</code>, but does not send record-level events.</p>
<p>Calling <code>collection.reset()</code> without passing any records as arguments will empty the entire collection.</p>
<ol>
<li>Trigger event <code>reset</code>( collection, options ).</li>
<li>Trigger event <code>changes</code>( collection, options ).</li>
</ol>
<h2 id="transactions">Transactions</h2>
<p>All collection updates occurs in the scope of transactions. Transaction is the sequence of changes which results in a single <code>changes</code> event.</p>
<p>Transaction can be opened either manually or implicitly with calling any of collection update methods.
Any additional changes made to the collection or its items in event handlers will be executed in the scope of the original transaction, and won&#39;t trigger an additional <code>changes</code> events.</p>
<h3 id="collection-transaction-fun-">collection.transaction( fun )</h3>
<p>Execute the sequence of updates in <code>fun</code> function in the scope of the transaction.</p>
<h3 id="collection-updateeach-iteratee-val-record-index-void-context-">collection.updateEach( iteratee : ( val : Record, index ) =&gt; void, context? )</h3>
<p>Similar to the <code>collection.each</code>, but wraps the loop in a transaction.</p>
<h2 id="observable-changes">Observable changes</h2>
<p>Object tree formed by nested records is deeply observable by default; changes in every item trigger change events for the collection and all parent elements in sequence.</p>
<p>Collection triggers following events on change:</p>
<ul>
<li><code>change</code> <em>( record, options )</em> for every changed record.</li>
<li><code>add</code> <em>( record, collection, options )</em> for every added record.</li>
<li><code>remove</code> <em>( record, collection, options )</em> for every removed record.</li>
<li><code>update</code> <em>( collection, options )</em> when any records were added or removed.</li>
<li><code>sort</code> <em>( collection, options )</em> when any records changed their order.</li>
<li><code>reset</code> <em>( collection, options )</em> if <code>collection.reset()</code> was used to update the collection.</li>
<li><code>changes</code> <em>( collection, options )</em> in case of any changes.</li>
</ul>
<h2 id="listening-to-changes-with-events-api">Listening to changes with Events API</h2>
<p><a href="../10_Events.md">Events API</a> is used for managing events subscriptions.</p>
<h3 id="listener-listento-record-event-handler-">listener.listenTo( record, event, handler )</h3>
<p><a href="../10_Events.md">Events API</a> method used to listen to the any of the change events.</p>
<h3 id="listener-stoplistening-record-">listener.stopListening( record )</h3>
<p><a href="../10_Events.md">Events API</a> method to explicitly stop all event subscriptions from the record.</p>
<p>Not needed if the listener is other record or collection.</p>
<h2 id="listening-to-item-events-in-the-collection">Listening to item events in the collection</h2>
<h3 id="-static-itemevents-eventname-handler-"><code>static</code> itemEvents = { eventName : <code>handler</code>, ... }</h3>
<p>Subscribe for events from records. The <code>hander</code> is either the collection&#39;s method name, the handler function, or <code>true</code>.</p>
<p>When <code>true</code> is passed as a handler, the corresponding event will be triggered on the collection.</p>
<h2 id="map-and-foreach">map and forEach</h2>
<h3 id="collection-foreach-iteratee-val-record-index-void-context-">collection.forEach( iteratee : ( val : Record, index ) =&gt; void, context? )</h3>
<h3 id="collection-each-iteratee-val-record-index-void-context-">collection.each( iteratee : ( val : Record, index ) =&gt; void, context? )</h3>
<p>Iterate through the elements of the collection. Similar to <code>Array.forEach</code>.</p>
<h3 id="collection-updateeach-iteratee-val-record-index-void-context-">collection.updateEach( iteratee : ( val : Record, index ) =&gt; void, context? )</h3>
<p>Similar to the <code>collection.each</code>, but wraps an iteration in a transaction. The single <code>changes</code> event will be emitted
for the group of changes to the records made in <code>updateEach</code>.</p>
<p><em>Use this method if you modify records in a loop</em>.</p>
<h3 id="collection-map-iteratee-val-record-index-t-context-">collection.map( iteratee : ( val : Record, index ) =&gt; T, context? )</h3>
<p>Map elements of the collection. Similar to <code>Array.map</code>, but <code>undefined</code> values returned by iteratee are filtered out.</p>
<p>Thus, <code>collection.map</code> can be used to map and filter elements in a single pass.</p>
<h2 id="predicate-methods">Predicate methods</h2>
<p>Predicate is either the iteratee function returning boolean, or an object with attribute values used to match with record&#39;s attributes.</p>
<h3 id="collection-filter-iteratee-predicate-context-">collection.filter( iteratee : Predicate, context? )</h3>
<p>Return filtered array of records matching the predicate.</p>
<h3 id="collection-every-iteratee-predicate-context-boolean">collection.every( iteratee : Predicate, context? ) : boolean</h3>
<p>Return <code>true</code> if all records match the predicate.</p>
<h3 id="collection-some-iteratee-predicate-context-boolean">collection.some( iteratee : Predicate, context? ) : boolean</h3>
<p>Return <code>true</code> if at least one record match the predicated.</p>
<p>By default there is no comparator for a collection. If you define a comparator, it will be used to maintain the collection in sorted order. This means that as records are added, they are inserted at the correct index in <code>collection.models</code>.</p>
<p>Note that Type-R depends on the arity of your comparator function to determine between the two styles, so be careful if your comparator function is bound.</p>
<p>Collections with a comparator will not automatically re-sort if you later change record attributes, so you may wish to call sort after changing record attributes that would affect the order.</p>
<h3 id="-static-comparator-attrname-"><code>static</code> comparator = &#39;attrName&#39;</h3>
<p>Maintain the collection in sorted order by the given record&#39;s attribute.</p>
<h3 id="-static-comparator-x-number-string"><code>static</code> comparator = x =&gt; number | string</h3>
<p>&quot;sortBy&quot; comparator functions take a record and return a numeric or string value by which the record should be ordered relative to others.</p>
<h3 id="-static-comparator-x-y-1-0-1"><code>static</code> comparator = ( x, y ) =&gt; -1 | 0 | 1</h3>
<p>&quot;sort&quot; comparator functions take two records, and return -1 if the first record should come before the second, 0 if they are of the same rank and 1 if the first record should come after.</p>
<p>Note how even though all of the chapters in this example are added backwards, they come out in the proper order:</p>
<pre><code class="highlight javascript">@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Chapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    static attributes = {
        page : <span class="hljs-built_in">Number</span>,
        title : <span class="hljs-built_in">String</span>
    }
}

<span class="hljs-keyword">var</span> chapters = <span class="hljs-keyword">new</span> Chapter.Collection();

chapters.comparator = <span class="hljs-string">'page'</span>;

chapters.add(<span class="hljs-keyword">new</span> Chapter({page: <span class="hljs-number">9</span>, title: <span class="hljs-string">"The End"</span>}));
chapters.add(<span class="hljs-keyword">new</span> Chapter({page: <span class="hljs-number">5</span>, title: <span class="hljs-string">"The Middle"</span>}));
chapters.add(<span class="hljs-keyword">new</span> Chapter({page: <span class="hljs-number">1</span>, title: <span class="hljs-string">"The Beginning"</span>}));

alert(chapters.map( x =&gt; x.title ));
</code></pre>
<h3 id="collection-sort-options-">collection.sort( options? )</h3>
<p>Force a collection to re-sort itself. You don&#39;t need to call this under normal circumstances, as a collection with a comparator will sort itself whenever a record is added. To disable sorting when adding a record, pass <code>{sort: false}</code> to add. Calling sort triggers a &quot;sort&quot; event on the collection.</p>
<h3 id="collection-push-record-options-">collection.push( record, options? )</h3>
<p>Add a record at the end of a collection. Takes the same options as add.</p>
<h3 id="collection-pop-options-">collection.pop( options? )</h3>
<p>Remove and return the last record from a collection. Takes the same options as remove.</p>
<h3 id="collection-unshift-record-options-">collection.unshift( record, options? )</h3>
<p>Add a record at the beginning of a collection. Takes the same options as add.</p>
<h3 id="collection-shift-options-">collection.shift( options? )</h3>
<p>Remove and return the first record from a collection. Takes the same options as remove.</p>
<h3 id="collection-slice-begin-end-">collection.slice( begin, end )</h3>
<p>Return a shallow copy of the <code>collection.models</code>, using the same options as native Array#slice.</p>
<h3 id="collection-indexof-recordorid-any-number">collection.indexOf( recordOrId : any ) : number</h3>
<p>Return an index of the record in the collection, and -1 if there are no such a record in the collection.</p>
<p>Can take the record itself as an argument, <code>id</code>, or <code>cid</code> of the record.</p>
<h1 id="aggregation-tree">Aggregation tree</h1>
<h2 id="aggregation-tree-methods">Aggregation tree methods</h2>
<p>Record&#39;s attributes can hold other Records and Collections, forming indefinitely nested data structures of arbitrary complexity.
To create nested record or collection you should just mention its constructor function in attribute&#39;s definition.</p>
<pre><code class="highlight javascript"><span class="hljs-keyword">import</span> { Record } <span class="hljs-keyword">from</span> <span class="hljs-string">'type-r'</span>

@define class User extends Record {
    static attributes = {
        name : String,
        email : String,
        isActive : true
    }
}

@define class UsersListState extends Record {
    static attributes = {
        users : User.Collection
    }
}
</code></pre>
<p>All nested records and collections are <em>aggregated</em> by default and behave as integral parts of the containing record. Aggregated attributes are <em>exclusively owned</em> by the record, and taken with it together form an <em>ownership tree</em>. Many operations are performed recursively on aggregated elements:</p>
<ul>
<li>They are created when the owner record is created.</li>
<li>They are cloned when the record is cloned.</li>
<li>They are disposed when the record is disposed.</li>
<li>They are validated as part of the record.</li>
<li>They are serialized as nested JSON.</li>
</ul>
<h3 id="recordorcollection-getowner-">recordOrCollection.getOwner()</h3>
<p>Return the reference to the record which is an owner, or <code>null</code> if the object is the root of an aggregation tree.</p>
<p>Due to the nature of <em>aggregation</em>, an object may have one and only one owner.</p>
<h3 id="recordorcollection-clone-">recordOrCollection.clone()</h3>
<p>Create the deep copy of the aggregation tree, recursively cloning all aggregated records and collections. References to <a href="04_Shared_objects.md">shared members</a> will be copied, but not shared members themselves.</p>
<h3 id="recordorcollection-set-json-parse-true-">recordOrCollection.set( json, { parse : true } )</h3>
<p>Recursively update an aggregation tree in place with the raw JSON data.</p>
<pre><code class="highlight javascript"><span class="hljs-comment">// Has the same effect as assignFrom():</span>
record.set( otherRecord.toJSON(), { parse : <span class="hljs-literal">true</span> });
</code></pre>
<h3 id="record-assignfrom-otherrecord-">record.assignFrom( otherRecord )</h3>
<h3 id="collection-assignfrom-othercollection-">collection.assignFrom( otherCollection )</h3>
<p>Make an <em>existing</em> record or collection to be an exact copy of other record or collection. The whole aggregation tree will be recursively traversed and assigned.</p>
<p>Other record/collection must have the similar shape as the record/collection type.</p>
<pre><code class="highlight javascript"><span class="hljs-comment">// Has the same effect as record.clone():</span>
<span class="hljs-keyword">const</span> clonedRecord = <span class="hljs-keyword">new</span> MyRecord();
clonedRecord.assignFrom( record );
</code></pre>
<h3 id="recordorcollection-dispose-">recordOrCollection.dispose()</h3>
<p>Recursively dispose the record and its aggregated members. &quot;Dispose&quot; means that elements of the aggregation tree will unsubscribe from all event sources. It&#39;s crucial to prevent memory leaks in SPA.</p>
<p>The whole aggregation tree will be recursively disposed, shared members won&#39;t.</p>
<p>All records and collections except <a href="04_Shared_objects.md">shared objects</a> are serializable by default as nested JSON reflecting the structure of their aggregation tree.</p>
<h2 id="shared-objects">Shared objects</h2>
<p>Record&#39;s attributes can hold the records and collections from <em>other</em> aggregation trees if they are marked as <code>shared</code>.</p>
<h3 id="-attrdef-attr-recordorcollection-shared"><code>attrDef</code> attr : RecordOrCollection.shared</h3>
<p>Record&#39;s attribute with a reference to the shared record or collection.</p>
<ul>
<li>It&#39;s initialized with <code>null</code></li>
<li>It&#39;s not cloned when the record is cloned (just the reference is copied over).</li>
<li>It&#39;s not disposed when the record is disposed.</li>
<li>It&#39;s not validated as part of the record (always valid by default)</li>
<li>It&#39;s excluded from serialization.</li>
</ul>
<pre><code class="highlight javascript">@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UsersListState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    static attributes = {
        users : User.Collection,
        selected : User.shared <span class="hljs-comment">// Can be assigned with the user from this.users</span>
    }
}
</code></pre>
<h3 id="-attrdef-attr-collection-refs"><code>attrDef</code> attr : Collection.Refs</h3>
<h3 id="new-collection-refs-">new Collection.Refs()</h3>
<p>Collection of references to shared records, which <em>does not aggregate</em> its elements. In contrast to the <code>Collection.shared</code>, <code>Collection.Refs</code> creates an instance of collection which <em>is the part the parent record</em>. Still, its items are not validated and serialized.</p>
<pre><code class="highlight javascript">    @define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRecord</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
        static attributes = {
            notCloned : SomeCollection.shared, <span class="hljs-comment">// Reference to the _shared collection_ object.</span>
            cloned : SomeCollection.Refs <span class="hljs-comment">// _Aggregated_ collection of references to the _shared records_.</span>
    }
</code></pre>
<h1 id="serialization">Serialization</h1>
<h2 id="serialization-api">Serialization API</h2>
<h3 id="recordorcollection-tojson-">recordOrCollection.toJSON()</h3>
<p>Produces the JSON for the given record or collection and its aggregated members. Aggregation tree is serialized as nested JSON. Record corresponds to an object in JSON, while the collection is represented as an array.</p>
<p>May be overridden in the particular record or collection class.</p>
<pre><code class="highlight javascript">@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Comment</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    static attributes = {
        body : <span class="hljs-string">''</span>
    }
}

@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BlogPost</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    static attributes = {
        title : <span class="hljs-string">''</span>,
        body : <span class="hljs-string">''</span>,
        comments : Comment.Collection
    }
}

<span class="hljs-keyword">const</span> post = <span class="hljs-keyword">new</span> BlogPost({
    title: <span class="hljs-string">"Type-R is cool!"</span>,
    comments : [ { body : <span class="hljs-string">"Agree"</span> }]
});

<span class="hljs-keyword">const</span> rawJSON = post.toJSON()
<span class="hljs-comment">// { title : "Type-R is cool!", body : "", comments : [{ body : "Agree" }] }</span>
</code></pre>
<h3 id="new-recordorcollection-json-parse-true-">new RecordOrCollection( json, { parse : true } )</h3>
<p>Create an object and its aggregated members from its JSON representation.</p>
<pre><code class="highlight javascript"><span class="hljs-comment">// Create the blog post from previous example.</span>
<span class="hljs-keyword">const</span> rawJSON = { title : <span class="hljs-string">"Type-R is cool!"</span>, body : <span class="hljs-string">""</span>, comments : [{ body : <span class="hljs-string">"Agree"</span> }] };

<span class="hljs-keyword">const</span> post = <span class="hljs-keyword">new</span> BlogPost( rawJSON, { parse : <span class="hljs-literal">true</span> });
</code></pre>
<h3 id="recordorcollection-set-json-parse-true-">recordOrCollection.set( json, { parse : true } )</h3>
<p>Update an existing object and its aggregated members from its JSON representation.</p>
<pre><code class="highlight javascript"><span class="hljs-comment">// Create the blog post from previous example.</span>
<span class="hljs-keyword">const</span> rawJSON = { title : <span class="hljs-string">"Type-R is cool!"</span>, body : <span class="hljs-string">""</span>, comments : [{ body : <span class="hljs-string">"Agree"</span> }] };

<span class="hljs-comment">// Similar to new BlogPost( rawJSON, { parse : true });</span>
<span class="hljs-keyword">const</span> post = <span class="hljs-keyword">new</span> BlogPost();
post.set( rawJSON, { parse : <span class="hljs-literal">true</span> });
</code></pre>
<h3 id="-abstract-recordorcollection-parse-json-"><code>abstract</code> recordOrCollection.parse( json )</h3>
<p>Invoked internally when <code>{ parse : true }</code> is passed. May be overridden to define custom JSON transformation. Should not be called explicitly.</p>
<h2 id="attribute-level-serialization-control">Attribute-level serialization control</h2>
<p>Serialization can be configured for the specific attribute in the Record&#39;s attribute definition.</p>
<h3 id="-attrdef-attr-type-has-tojson-false-"><code>attrDef</code> attr : Type.has.toJSON( false )</h3>
<p>Do <em>not</em> serialize the specific attribute.</p>
<h3 id="-attrdef-attr-type-has-tojson-value-name-json-"><code>attrDef</code> attr : Type.has.toJSON( ( value, name ) =&gt; json )</h3>
<p>Override the default serialization for the specific record&#39;s attribute.</p>
<p>Attribute is not serialized when the function return <code>undefined</code>.</p>
<h3 id="-attrdef-attr-type-has-parse-json-name-value-"><code>attrDef</code> attr : Type.has.parse( ( json, name ) =&gt; value )</h3>
<p>Transform the data before it will be assigned to the record&#39;s attribute.</p>
<p>Invoked when the <code>{ parse : true }</code> option is set.</p>
<pre><code class="highlight javascript"><span class="hljs-comment">// Define custom boolean attribute type which is serialized as 0 or 1.</span>
<span class="hljs-keyword">const</span> MyWeirdBool = <span class="hljs-built_in">Boolean</span>.has
                      .parse( x =&gt; x === <span class="hljs-number">1</span> )
                      .toJSON( x =&gt; x ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span> );
</code></pre>
<h2 id="serialization-of-date">Serialization of Date</h2>
<p>There&#39;s no built-in Date type in JSON. Type-R address this issue providing the attribute-level control on date&#39;s JSON representation.</p>
<h3 id="-attrdef-attr-date"><code>attrDef</code> attr : Date</h3>
<p><code>attr</code> is serialized as an ISO string. Works in Safari as well.</p>
<h3 id="-attrdef-attr-date-microsoft"><code>attrDef</code> attr : Date.microsoft</h3>
<p><code>attr</code> is serialized as Microsoft&#39;s <code>&quot;/Date(msecs)/&quot;</code> string.</p>
<h3 id="-attrdef-attr-date-timestamp"><code>attrDef</code> attr : Date.timestamp</h3>
<p><code>attr</code> is serialized as UNIX integer timestamp.</p>
<h1 id="relations-by-id">Relations by id</h1>
<h2 id="record-s-id">Record&#39;s id</h2>
<h3 id="record-id">record.id</h3>
<p>Predefined record&#39;s attribute, the <code>id</code> is an arbitrary string (integer id or UUID).
<code>id</code> is typically generated by the server. It is used in JSON for id-references.</p>
<p>Records can be retrieved by <code>id</code> from collections, and there can be just one instance
of the record with the same <code>id</code> in the particular collection.</p>
<h3 id="-static-idattribute-attrname-"><code>static</code> idAttribute = &#39;attrName&#39;</h3>
<p>A record&#39;s unique identifier is stored under the <code>id</code> attribute.
If you&#39;re directly communicating with a backend (CouchDB, MongoDB) that uses a different unique key,
you may set a Record&#39;s <code>idAttribute</code> to transparently map from that key to id.</p>
<p>Record&#39;s <code>id</code> property will still be linked to Record&#39;s id, no matter which value <code>idAttribute</code> has.</p>
<pre><code class="highlight javascript">@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Meal</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
  static idAttribute =  <span class="hljs-string">"_id"</span>;
  static attributes = {
      _id : <span class="hljs-built_in">Number</span>,
      name : <span class="hljs-string">''</span>
  }
}

<span class="hljs-keyword">const</span> cake = <span class="hljs-keyword">new</span> Meal({ _id: <span class="hljs-number">1</span>, name: <span class="hljs-string">"Cake"</span> });
alert(<span class="hljs-string">"Cake id: "</span> + cake.id);
</code></pre>
<h3 id="record-isnew-">record.isNew()</h3>
<p>Has this record been saved to the server yet? If the record does not yet have an <code>id</code>, it is considered to be new.</p>
<h2 id="id-references">id-references</h2>
<p>Serializable references to shared records are called an <em>id-references</em>. It is represented as <code>record.id</code> in JSON,
and there must be the populated master collection of records on the client in order to resolve ids on parse.</p>
<p>There are two kinds of id-references: one-to-many, and many-to-many. They are declared with the special kind of attribute annotation.
Id-references behaves in the same way as shared attributes, but <em>inner changes</em> in referenced objects are <em>not observed</em>.</p>
<h3 id="-attrdef-attr-record-from-sourcecollection-"><code>attrDef</code> attr : Record.from( <code>sourceCollection</code> )</h3>
<p>Declare an attribute to be the record from the particular collection.</p>
<p>Serialized as <code>record.id</code>.</p>
<h3 id="-attrdef-attr-collection-subsetof-sourcecollection-"><code>attrDef</code> attr : Collection.subsetOf( <code>sourceCollection</code> )</h3>
<p>Declare an attribute to be the collection, which is the subset of the particular collection.</p>
<p>Serialized as an array of record ids.</p>
<h3 id="-sourcecollection-path-relative-to-this-"><code>sourceCollection</code> &#39;path.relative.to.this&#39;</h3>
<p><code>sourceCollection</code> may be the string with the dot-separated <em>relative object path</em> to the collection.
In this case, it is resolved dynamically relative to the record&#39;s <code>this</code>.</p>
<pre><code class="highlight javascript">    @define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">State</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
        items : Item.Collection,
        selected : Record.from( <span class="hljs-string">'items'</span> ) <span class="hljs-comment">// Will resolve to `this.items`</span>
    }
</code></pre>
<h3 id="-sourcecollection-path-relative-to-owner-"><code>sourceCollection</code> &#39;^path.relative.to.owner&#39;</h3>
<p><code>^</code> symbol in path is being translated to the <code>getOwner()</code> call.</p>
<blockquote>
<p>It&#39;s recommended to use tilda-references and stores instead.</p>
</blockquote>
<h2 id="stores-and-tilda-references">Stores and tilda-references</h2>
<h3 id="-abstract-class-store"><code>abstract class</code> Store</h3>
<h3 id="-sourcecollection-path-relative-to-store-"><code>sourceCollection</code> &#39;~path.relative.to.store&#39;</h3>
<p><code>Store</code> is the Record&#39;s subclass which serves as a root for id-references.
Any id-reference with a path starting with <code>~</code> look for the nearest <code>Store</code> subclass traversing the aggregation tree upwards,
and if there are none, it takes the default Store class <code>Store.global</code>.</p>
<p>For all objects inside of the store&#39;s aggregation tree <code>~member</code> will resolve to the member of this store class.
If the lookup will fail, the next available store upper in aggregation tree will be used (as regular records stores can be nested), or the <code>Store.global</code> if there are no one.</p>
<blockquote>
<p>Stores in Type-R is <em>very different</em> to stores in other framework. Pay attention.</p>
</blockquote>
<pre><code class="highlight javascript">@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Role</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    static attributes = {
        name : <span class="hljs-built_in">String</span>,
        ...
    }
}

@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    static attributes = {
        name : <span class="hljs-built_in">String</span>,
        roles : Role.Collection.subsetOf( <span class="hljs-string">'~roles'</span> )
    }
}

@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UsersDirectory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Store</span> </span>{
    static attributes = {
        roles : Role.Collection,
        users : User.Collection <span class="hljs-comment">// `~roles` references will be resolved against this.roles</span>
    }
}
</code></pre>
<h3 id="store-global">Store.global</h3>
<p>The default store class. Is always the last store to lookup when resolving tilda-reference.</p>
<p>Use the default store for the <em>globally shared data only</em>. Each application page must have its local store.</p>
<pre><code class="highlight javascript">@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyStore</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Store</span> </span>{
    static attributes = {
        users : User.Collection,
        roles : Role.Collection
    }
}

Store.global = <span class="hljs-keyword">new</span> MyStore();

<span class="hljs-comment">// Now the reference '~users` will point to users collection from the MyStore.</span>
</code></pre>
<h1 id="api-by-feature">API by Feature</h1>
<h2 id="attribute-level-validators">Attribute-level validators</h2>
<p>Type-R supports declarative attribute-level validation declarations.
This is the preferable way of doing validation.</p>
<h3 id="-attrdef-attr-type-has-check-predicate-errormsg-"><code>attrDef</code> attr : Type.has.check( predicate, errorMsg? )</h3>
<p>Attribute-level validator.</p>
<ul>
<li><code>predicate : value =&gt; boolean</code> is the function taking attribute&#39;s value and returning <code>true</code> whenever the value is valid.</li>
<li>optional <code>errorMsg</code> is the error message which will be passed in case if the validation fail.</li>
</ul>
<p>If <code>errorMsg</code> is omitted, error message will be taken from <code>predicate.error</code>. It makes possible to define reusable validation functions.</p>
<pre><code class="highlight javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isAge</span>(<span class="hljs-params"> years </span>)</span>{
    <span class="hljs-keyword">return</span> years &gt;= <span class="hljs-number">0</span> &amp;&amp; years &lt; <span class="hljs-number">200</span>;
}

isAge.error = <span class="hljs-string">"Age must be between 0 and 200"</span>;
</code></pre>
<p>Attribute may have any number of checks attached, which are execute in sequence. Validation stops when first check in sequence fails.</p>
<pre><code class="highlight javascript"><span class="hljs-comment">// Define new attribute metatype encapsulating validation checks.</span>
<span class="hljs-keyword">const</span> Age = <span class="hljs-built_in">Number</span>.has
                .check( x =&gt; x &gt;= <span class="hljs-number">0</span>, <span class="hljs-string">'I guess you are a bit older'</span> )
                .check( x =&gt; x &lt; <span class="hljs-number">200</span>, <span class="hljs-string">'No way man can be that old'</span> );
</code></pre>
<h3 id="-attrdef-attr-type-isrequired"><code>attrDef</code> attr : Type.isRequired</h3>
<p>The special case of attribute-level check cutting out empty values. Attribute value must be truthy to pass, <code>&quot;Required&quot;</code> is used as validation error.</p>
<p><code>isRequired</code> is the first validator to check, no matter in which order validators were attached.</p>
<h2 id="object-level-validators">Object-level validators</h2>
<h3 id="-abstract-recordorcollection-validate-"><code>abstract</code> recordOrCollection.validate()</h3>
<p>Override in the subclass to add object-level validation. Whatever is returned from <code>validate()</code> is treated as an error message and triggers the validation error.</p>
<h2 id="validation-api">Validation API</h2>
<p>Validation happens transparently on the first access to any part of the validation API. Validation results are cached. Only the required parts of aggregation tree will be validated again</p>
<h3 id="recordorcollection-isvalid-">recordOrCollection.isValid()</h3>
<p>Returns <code>true</code> whenever an object and its aggregation tree is valid.</p>
<h3 id="record-isvalid-attrname-">record.isValid( attrName )</h3>
<h3 id="collection-isvalid-recordid-">collection.isValid( recordId )</h3>
<p>Returns <code>true</code> whenever the record&#39;s attribute or collection&#39;s item is valid.</p>
<h3 id="record-validationerror">record.validationError</h3>
<p>Detailed validation error information, or <code>null</code> if the record and its <em>aggregated attributes</em> are valid.
An error object has tree structure mapping the invalid subtree of the aggregation tree.</p>
<pre><code class="highlight javascript"><span class="hljs-comment">// ValidationError object shape</span>
{
    error : <span class="hljs-comment">/* record-level validation error msg as returned from record.validate() */</span>,

    <span class="hljs-comment">// Attribute-level validation errors, one entry for each invalid attribute.</span>
    nested : {
        <span class="hljs-comment">// Contains nested ValidationError object for nested records and collections...</span>
        nestedRecord : <span class="hljs-comment">/* ValidationError */</span>
        nestedCollection : <span class="hljs-comment">/* ValidationError */</span>

        <span class="hljs-comment">// ...and error msg for all other attributes.</span>
        otherAttr : <span class="hljs-comment">/* attribute validation error as returned from .has.check() validator */</span>
    }
}
</code></pre>
<h3 id="collection-validationerror">collection.validationError</h3>
<p>Detailed validation error information, or <code>null</code> if the collection and its items are valid.
An error object has tree structure mapping the invalid subtree of the aggregation tree.</p>
<pre><code class="highlight javascript"><span class="hljs-comment">// ValidationError object shape</span>
{
    error : <span class="hljs-comment">/* collection-level validation error msg as returned from collection.validate() */</span>,

    <span class="hljs-comment">// Collection items validation errors</span>
    nested : {
        <span class="hljs-comment">// Contains nested ValidationError object for nested records...</span>
        <span class="hljs-comment">/* record.cid */</span> : <span class="hljs-comment">/* record.validationError */</span>
    }
}
</code></pre>
<h3 id="record-getvalidationerror-attr-">record.getValidationError( attr )</h3>
<h3 id="collection-getvalidationerror-recordid-">collection.getValidationError( recordId )</h3>
<p>Return the validation error for the given <code>attr</code> or collection&#39;s item.</p>
<h3 id="recordorcollection-eachvalidationerror-iteratee-error-key-recordorcollection-void-">recordOrCollection.eachValidationError( iteratee : ( error, key, recordOrCollection ) =&gt; void )</h3>
<p>Recursively traverse aggregation tree errors. <code>key</code> is <code>null</code> for the record-level validation error (returned from <code>validate()</code>).
<code>recordOrCollection</code> is the reference to the current object.</p>
<h2 id="polymorphic-data-structures">Polymorphic data structures</h2>
<p>Sometimes it&#39;s required to deal with the collection of records of different types.
In the simplest case, <code>Record.Collection</code> is polymorphic in a sense that it may hold any record
inside, as well as the record&#39;s attribute of the <code>Record</code> type.</p>
<p>The trick, however, is to restore polymorphic data from JSON as its type is unknown.
Type-R solves it with <em>abstract records</em>.</p>
<h2 id="defining-an-abstract-record">Defining an abstract record</h2>
<p>Record base class with the <code>create()</code> factory function attached to its definition is an <em>abstract record</em>.</p>
<h3 id="-static-create-attrs-options-"><code>static</code> create( attrs, options )</h3>
<p>The factory function used internally by Type-R to create the instance of the record.
Must be defined in the base class for the polymorphic record.</p>
<pre><code class="highlight javascript">@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Widget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span> </span>{
    static attributes = {
        type : <span class="hljs-built_in">String</span>
    }

    static create( attrs, options ){
        <span class="hljs-keyword">switch</span>( attrs.type ){
            <span class="hljs-keyword">case</span> <span class="hljs-string">"typeA"</span> : <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TypeA( attrs, options );
            <span class="hljs-keyword">case</span> <span class="hljs-string">"typeB"</span> : <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TypeB( attrs, options );
        }
    }
}

@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TypeA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Widget</span> </span>{
    static attributes = {
        type : <span class="hljs-string">"typeA"</span>,
        ...
    }
}

@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TypeB</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Widget</span> </span>{
    static attributes = {
        type : <span class="hljs-string">"typeB"</span>,
        ...
    }
}
</code></pre>
<h2 id="polymorphic-attributes-and-collections">Polymorphic attributes and collections</h2>
<p>Abstract record type can be used to define serializable polymorphic attributes and collections.</p>
<h3 id="-attrdef-attr-polymorphicrecord"><code>attrDef</code> attr : PolymorphicRecord</h3>
<p>Attribute of polymorphic record type is serializable.</p>
<h3 id="polymorphicrecord-collection">PolymorphicRecord.Collection</h3>
<p>The default Collection for the polymorphic record type is serializable.</p>
<h2 id="recursive-data-structures">Recursive data structures</h2>
<p>The record is <em>recursive</em> if it&#39;s uses the type of itself in its attribute definition.</p>
<h3 id="recordorcollection-define-attributes-name-attrdef-">RecordOrCollection.define({ attributes : { name : <code>attrDef</code> } })</h3>
<p>Used in conjunction with <code>@predefine</code> decorator to make recursive definitions
referencing the same type.</p>
<p>Replaces <code>static attributes</code> declaration.</p>
<pre><code class="highlight javascript">@predefine <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Comment</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span></span>{}

Comment.define({
    attributes : {
        text : <span class="hljs-built_in">String</span>,
        replies : Comment.Collection
    }
});
</code></pre>
<h3 id="forward-declaration-of-the-collection">Forward declaration of the Collection</h3>
<p>As an alternative to <code>@predefine</code> decorator, you may make forward declaration for the collection.</p>
<pre><code class="highlight javascript"><span class="hljs-comment">// Declare the collection class.</span>
@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Comments</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span>.<span class="hljs-title">Collection</span> </span>{}

@define <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Comment</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span>(</span>{
    static Collection = Comments; <span class="hljs-comment">// Make it the default Comment collection.</span>

    attributes : {
        text : <span class="hljs-built_in">String</span>,
        replies : Comments
    }
});
</code></pre>
<h1 id="mixins">Mixins</h1>
<h2 id="decorators">Decorators</h2>
<p>Type-R is based on mixins with configurable properties merge rules.</p>
<h3 id="-decorator-mixins-mixina-mixinb-class-x-"><code>decorator</code> @mixins( mixinA, mixinB, ... ) class X ...</h3>
<p>Merge specified mixins to the class definition. Both plain JS object and class constructor may be used as mixin. In the case of the class constructor, missing static members will copied over as well.</p>
<pre><code class="highlight javascript">    <span class="hljs-keyword">import</span> { mixins, Events } <span class="hljs-keyword">from</span> <span class="hljs-string">'type-r'</span>
    ...

    @mixins( Events, plainObject, MyClass, ... )
    class X {
        ...
    }
</code></pre>
<h3 id="-decorator-mixinrules-propname-rule-class-"><code>decorator</code> @mixinRules({ propName : <code>rule</code>, ... }) class ...</h3>
<p>Specified class properties will be merged according to the given rule.
Rules can be extended and overridden in any subclass.</p>
<h2 id="mixin-rules">Mixin rules</h2>
<h3 id="-rule-propname-merge-"><code>rule</code> propName : &#39;merge&#39;</h3>
<p>Assume the property to be an object. Merge objects from mixins.</p>
<h3 id="-rule-propname-name1-rule-"><code>rule</code> propName : { name1 : <code>rule</code>, ... }</h3>
<p>Assume the property to be an object. Recursively define merge rules for its properties.</p>
<h3 id="-rule-propname-pipe-"><code>rule</code> propName : &#39;pipe&#39;</h3>
<p>Assume the property to be the function with a signature <code>( x : T ) =&gt; T</code>. Join functions from mixins in a pipe: <code>f1( f2( f3( x ) ) )</code>.</p>
<h3 id="-rule-propname-sequence-"><code>rule</code> propName : &#39;sequence&#39;</h3>
<p>Assume the property to be the function. Call functions from mixins in sequence: <code>f1.apply( this, arguments ); f2.apply( this, arguments );...</code></p>
<h3 id="-rule-propname-reverse-"><code>rule</code> propName : &#39;reverse&#39;</h3>
<p>Same as sequence, but functions are called in the reverse sequence.</p>
<h3 id="-rule-propname-mergesequence-"><code>rule</code> propName : &#39;mergeSequence&#39;</h3>
<p>Assume the property to be the function returning object. Merge objects returned by functions from mixins, executing them in sequence.</p>
<h3 id="-rule-propname-every-"><code>rule</code> propName : &#39;every&#39;</h3>
<p>Assume property to be the function returning boolean. Return <code>true</code> if all functions from mixins return truthy values.</p>
<h3 id="-rule-propname-some-"><code>rule</code> propName : &#39;some&#39;</h3>
<p>Same as <code>every</code>, but return true when at least one function from mixins returns true.</p>
<h1 id="events">Events</h1>
<p>Both <code>Record</code> and <code>Collection</code> uses an efficient synchronous events implementation which is compatible with Backbone 1.1 Events API but is twice faster in average. It comes in form of <code>Events</code> mixin and the <code>Messenger</code> base class.</p>
<p>An implementation is optimized for the large amount of relatively small subscriptions (5-10 events). Here are the benchmark results (lower is the better).</p>
<p><img src="./events-performance.jpg" alt="performance"></p>
<p>It is also available separately as part of <a href="https://github.com/Volicon/MixtureJS">MixtureJS</a> package.</p>
<h2 id="events-mixin">Events mixin</h2>
<p><code>Events</code> is a <a href="11_Mixins.md">mixin</a> giving the object the ability to bind and trigger custom named events. Events do not have to be declared before they are bound, and may take passed arguments.</p>
<pre><code class="highlight javascript"><span class="hljs-keyword">import</span> { mixins, Events } <span class="hljs-keyword">from</span> <span class="hljs-string">'type-r'</span>

@mixins( Events )
class Messenger {
    ...
}
</code></pre>
<blockquote>
<p><code>Messenger</code> abstract base class is included with Type-R, see below.</p>
</blockquote>
<h3 id="eventssource-trigger-event-arg1-arg2-">eventsSource.trigger(event, arg1, arg2, ... )</h3>
<p>Trigger callbacks for the given event, or space-delimited list of events. Subsequent arguments to trigger will be passed along to the event callbacks.</p>
<h2 id="messenger">Messenger</h2>
<p>Messenger is an abstract base class implementing Events mixin and some convenience methods.
As all Type-R classes, its definition must be preceded with the <code>@define</code> decorator.</p>
<pre><code class="highlight javascript"><span class="hljs-keyword">import</span> { define, Messenger } <span class="hljs-keyword">from</span> <span class="hljs-string">'type-r'</span>

@define class MyMessenger extends Messenger {

}
</code></pre>
<h3 id="-readonly-messenger-cid"><code>readonly</code> messenger.cid</h3>
<p>Unique run-time only messenger instance id (string).</p>
<h3 id="messenger-initialize-">messenger.initialize()</h3>
<p>Callback which is called at the end of the constructor.</p>
<h3 id="messenger-dispose-">messenger.dispose()</h3>
<p>Executes <code>messenger.stopListening()</code> and <code>messenger.off()</code>.</p>
<p>Objects must be disposed to prevent memory leaks caused by subscribing for events from singletons.</p>
<h2 id="high-level-listening-api">High-level listening API</h2>
<p>All high-level event subscriptions are stopped automatically on the listener&#39;s disposal, and thus does not introduce memory leaks.</p>
<p>This is the preferable listening API and must be used in all application code.</p>
<h3 id="listener-listento-other-event-callback-">listener.listenTo(other, event, callback)</h3>
<p>Tell an object to listen to a particular event on an other object. The advantage of using this form, instead of other.on(event, callback, object), is that listenTo allows the object to keep track of the events, and they can be removed all at once later on. The callback will always be called with object as context.</p>
<pre><code class="highlight javascript">    view.listenTo(record, <span class="hljs-string">'change'</span>, view.render );
</code></pre>
<h3 id="listener-stoplistening-other-event-callback-">listener.stopListening([other], [event], [callback])</h3>
<p>Tell an object to stop listening to events. Either call stopListening with no arguments to have the object remove all of its registered callbacks ... or be more precise by telling it to remove just the events it&#39;s listening to on a specific object, or a specific event, or just a specific callback.</p>
<pre><code class="highlight javascript">    view.stopListening(); <span class="hljs-comment">// Unsubscribe from all events</span>

    view.stopListening(record); <span class="hljs-comment">// Unsubscribe from all events from the record</span>
</code></pre>
<p>All Type-R classes execute <code>this.stopListening()</code> from their <code>dispose()</code> method.</p>
<h3 id="listener-listentoonce-other-event-callback-">listener.listenToOnce(other, event, callback)</h3>
<p>Just like listenTo, but causes the bound callback to fire only once before being removed.</p>
<h2 id="low-level-listening-api">Low-level listening API</h2>
<p>This API is more efficient but requires manual action to stop the subscription. Must be used with care.</p>
<h3 id="eventsource-on-event-callback-context-">eventSource.on(event, callback, [context])</h3>
<p>Bind a callback function to an object. The callback will be invoked whenever the event is fired. If you have a large number of different events on a page, the convention is to use colons to namespace them: <code>poll:start</code>, or <code>change:selection</code>. The event string may also be a space-delimited list of several events...</p>
<pre><code class="highlight javascript">    book.on(<span class="hljs-string">"change:title change:author"</span>, ...);
</code></pre>
<p>Callbacks bound to the special &quot;all&quot; event will be triggered when any event occurs, and are passed the name of the event as the first argument. For example, to proxy all events from one object to another:</p>
<pre><code class="highlight javascript">    proxy.on(<span class="hljs-string">"all"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">eventName</span>) </span>{
        object.trigger(eventName);
    });
</code></pre>
<p>All event methods also support an event map syntax, as an alternative to positional arguments:</p>
<pre><code class="highlight javascript">    book.on({
        <span class="hljs-string">"change:author"</span>: authorPane.update,
        <span class="hljs-string">"change:title change:subtitle"</span>: titleView.update,
        <span class="hljs-string">"destroy"</span>: bookView.remove
    });
</code></pre>
<p>To supply a context value for this when the callback is invoked, pass the optional last argument: <code>record.on(&#39;change&#39;, this.render, this)</code> or <code>record.on({change: this.render}, this)</code>.</p>
<h3 id="eventsource-off-event-callback-context-">eventSource.off([event], [callback], [context])</h3>
<p>Remove a previously bound callback function from an object. If no context is specified, all of the versions of the callback with different contexts will be removed. If no callback is specified, all callbacks for the event will be removed. If no event is specified, callbacks for all events will be removed.</p>
<pre><code class="highlight javascript">    <span class="hljs-comment">// Removes just the `onChange` callback.</span>
    object.off(<span class="hljs-string">"change"</span>, onChange);

    <span class="hljs-comment">// Removes all "change" callbacks.</span>
    object.off(<span class="hljs-string">"change"</span>);

    <span class="hljs-comment">// Removes the `onChange` callback for all events.</span>
    object.off(<span class="hljs-literal">null</span>, onChange);

    <span class="hljs-comment">// Removes all callbacks for `context` for all events.</span>
    object.off(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, context);

    <span class="hljs-comment">// Removes all callbacks on `object`.</span>
    object.off();
</code></pre>
<p>Note that calling <code>record.off()</code>, for example, will indeed remove all events on the record — including events that Backbone uses for internal bookkeeping.</p>
<h3 id="eventssource-once-event-callback-context-">eventsSource.once(event, callback, [context])</h3>
<p>Just like <code>on()</code>, but causes the bound callback to fire only once before being removed. Handy for saying &quot;the next time that X happens, do this&quot;. When multiple events are passed in using the space separated syntax, the event will fire once for every event you passed in, not once for a combination of all events</p>
<h2 id="record-events">Record events</h2>
<h3 id="-event-change-attrname-record-value-options-"><code>event</code> &quot;change:attrName&quot; (record, value, options)</h3>
<p>When a specific attribute has been updated</p>
<h3 id="-event-change-record-options-"><code>event</code> &quot;change&quot; (record, options)</h3>
<p>When a record&#39;s attributes have changed.</p>
<h2 id="collection-events">Collection events</h2>
<h3 id="-event-changes-collection-options-"><code>event</code> &quot;changes&quot; (collection, options)</h3>
<p>The main change event. Single event triggered when the collection has been changed.</p>
<h3 id="-event-update-collection-options-"><code>event</code> &quot;update&quot; (collection, options)</h3>
<p>Single event triggered after any number of records have been added or removed from a collection.</p>
<h3 id="-event-reset-collection-options-"><code>event</code> &quot;reset&quot; (collection, options)</h3>
<p>When the collection&#39;s entire contents have been reset.</p>
<h3 id="-event-sort-collection-options-"><code>event</code> &quot;sort&quot; (collection, options)</h3>
<p>When the collection has been re-sorted.</p>
<h3 id="-event-add-record-collection-options-"><code>event</code> &quot;add&quot; (record, collection, options)</h3>
<p>When a record is added to a collection.</p>
<h3 id="-event-remove-record-collection-options-"><code>event</code> &quot;remove&quot; (record, collection, options)</h3>
<p>When a record is removed from a collection.</p>
<h3 id="-event-change-record-options-"><code>event</code> &quot;change&quot; (record, options)</h3>
<p>When a record&#39;s attributes have changed.</p>
        </div>
    </div>
  </body>
</html>
