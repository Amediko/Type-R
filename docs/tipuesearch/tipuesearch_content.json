{"pages":[{"title":"Type-R","text":"Type-R is the modern state management JS framework designed to handle both UI and domain application state. JSON Serialization State is serializable by default. Both nested JSON and relations by id are supported. Validation Declarative validation checks. Validation is lazily evaluated. Dynamic type-safety State elements are typed. Client-server communication is guarded against type errors from both ends. Observable Changes Changes are observable by default. Scalability Not dependent on singletons. Stores are optional and can be created dynamically. Performance 10 times faster than BackboneJS in all browsers.","tags":"","url":"index.html"},{"title":"Getting Started","text":"Introduction Type-R is the universal state management framework for both UI and domain state. Application state is described with the superposition of two main container types - Record and Collection of records. The state has observable changes and is serializable by default. Records are classes with typed attributes. They are protected from attributes assignment of incompatible types with run-time type assertions and conversions. Which means that the client-server protocol is protected from both ends. Records distinguish aggregated attributes and those which are references to shared objects. Aggregated attributes are serialized as nested JSON, while references might be serialized as ids. Operations like clone(), dispose(), and toJSON() are performed recursively on elements of aggregation tree. Type-R features declarative validation with attribute-level rules. Validation is transparent and lazily evaluated. Architecture does not depend on stores and singletons. Stores are optional and used for shared data only. There might be as many stores as you need, and they can be created and disposed dynamically. Type-R data structures are pretty efficient. They are about 10 times faster in real-world data scenarios than BackboneJS. Installation Is packed as UMD and ES6 module. No side dependencies. npm install type-r --save-dev Requirements IE10+, Edge, Safari, Chrome, and Firefox are supported. IE9 and Opera may work but has not been tested. IE8 won't work.","tags":"","url":"Getting_Started.html"},{"title":"Overview","text":"Record is the serializable class with typed attributes, observable changes, and custom validation checks. It is the main building block for managing the application state; component local state, stores, and collection elements are all subclasses of the Record. In contrast to the &quot;model&quot; class in the majority of data frameworks, Record is not the key-value hash. It's the class with statically defined set of attributes of known types. Record itself is an abstract class. The subclass needs to be defined for every data structure of different shape, in a similar way as it's done in statically typed languages. import { define, Record } from 'type-r' \/\/ \u00e2\u00a4\u00b9 required to make magic work @define class User extends Record { \/\/ \u00e2\u00a4\u00b9 attribute's declaration static attributes = { firstName : '', \/\/ \u00e2\u009f\u00b5 String type is inferred from the default value lastName : String, \/\/ \u00e2\u009f\u00b5 Or you can just mention its constructor email : String.value( null ), \/\/\u00e2\u009f\u00b5 Or you can provide both createdAt : Date, \/\/ \u00e2\u009f\u00b5 And it works for any constructor. \/\/ And you can attach \u00e2\u00a4\u00b9 metadata to fine-tune attribute's behavior lastLogin : Date.value( null ).has.toJSON( false ) \/\/ \u00e2\u009f\u00b5 not serializable } } const user = new User(); console.log( user.createdAt ); \/\/ \u00e2\u009f\u00b5 this is an instance of Date created for you. const users = new User.Collection(); \/\/ \u00e2\u009f\u00b5 Collections are defined automatically. users.on( 'changes', () =&gt; updateUI( users ) ); \/\/ \u00e2\u009f\u00b5 listen to the changes. users.set( json, { parse : true } ); \/\/ \u00e2\u009f\u00b5 parse raw JSON from the server. users.updateEach( user =&gt; user.firstName = '' ); \/\/ \u00e2\u009f\u00b5 bulk update triggering 'changes' once Record definition Record definition must: be the class extending the Record; be preceded with the @define decorator; have static attributes definition. decorator @define Must be placed before record class definition. import { define, Record } from 'type-r' @define class X extends Record { ... } static attributes = { name : attrDef, ... } Record's attributes definition. Lists attribute names along with their types, default values, and metadata controlling different aspects of attribute behavior. @define class User extends Record { static attributes = { name : String.value( 'John Dow' ), email : 'john.dow@mail.com', \/\/ Same as String.value( 'john.dow@mail.com' ) address : String, \/\/ Same as String.value( '' ) } } The Record guarantee that every attribute will retain the value of the declared type. Whenever an attribute is being assigned with the value which is not compatible with its declared type, the type is being converted with an invocation of the constructor: new Type( value ) (primitive types are treated specially). Attribute definitions attrDef name : Type When the function is used as attrDef, it's treated as the constructor function. Any constructor function which behaves as converting constructor (like new Date( msecs )) may be used as an attribute type. You can use other record's and collection's constructors as attribute types. They will be treated as an integral part of the record (created, serialized, validated, and disposed together), i.e. as aggregated members. @define class Person extends Record { static attributes = { name : String \/\/ String attribute which is &quot;&quot; by default. createdAt : Date \/\/ Date attribute ... } } attrDef name : defaultValue When value of other type than function is used as attrDef it's treated as attribute's default value. Attribute's type is being inferred from the value. Use the general form of attribute definition for attributes of Function type: Function.value( theFunction ). @define class GridColumn extends Record { static attributes = { name : '', \/\/ String attribute which is '' by default. render : Function.value( x =&gt; x ), ... } } attrDef name : Type.value( defaultValue ) The general form of attribute definition is Type.value( defaultValue ), where the Type is the corresponding constructor function. @define class Person extends Record { static attributes = { phone : String.value( null ) \/\/ String attribute which is null by default. ... } } Create the record Record behaves as regular ES6 class with attributes accessible as properties. new Record() Create an instance of the record with default attribute values taken from the attributes definition. When no default value is explicitly provided for an attribute, it's initialized as new Type() (just Type() for primitives). When the default value is provided and it's not compatible with the attribute type, it's converted with new Type( defaultValue ) call. new Record({ attrName : value, ... }, options? ) When creating an instance of a record, you can pass in the initial attribute values to override the defaults. If {parse: true} option is used, attrs is assumed to be the JSON. If the value of the particular attribute is not compatible with its type, it's converted to the declared type invoking the constructor new Type( value ) (just Type( value ) for primitives). @define class Book extends Record { static attributes = { title : '', author : '' } } const book = new Book({ title: &quot;One Thousand and One Nights&quot;, author: &quot;Scheherazade&quot; }); abstract record.initialize( attrs?, options? ) Called at the end of the Record constructor when all attributes are assigned and the record's inner state is properly initialized. Takes the same arguments as a constructor. record.attrName Record's attributes may be directly accessed as record.name. Please note, that you have to declare all attributes in static attributes declaration. @define class Account extends Record { static attributes = { name : String, balance : Number } } const myAccount = new Account({ name : 'mine' }); myAccount.balance += 1000000; \/\/ That works. Good, eh?","tags":"","url":"Record\/Overview.html"},{"title":"Updates and transactions","text":"Update record attributes record.attrName = value Assign the record's attribute. If the value is not compatible with attribute's type from the declaration, it is converted: with Type( value ) call, for primitive types; with record.attrName.set( value ), for existing record or collection (updated in place); with new Type( value ) in all other cases. Record triggers events on changes: change:attrName ( record, value ). change ( record ). @define class Book extends Record { static attributes = { title : String, author : String price : Number, publishedAt : Date, available : Boolean } } const myBook = new Book({ title : &quot;State management with Type-R&quot; }); myBook.author = 'Vlad'; \/\/ That works. myBook.price = 'Too much'; \/\/ Converted with Number( 'Too much' ), resulting in NaN. myBook.price = '123'; \/\/ = Number( '123' ). myBook.publishedAt = new Date(); \/\/ Type is compatible, no conversion. myBook.publishedAt = '1678-10-15 12:00'; \/\/ new Date( '1678-10-15 12:00' ) myBook.available = some &amp;&amp; weird || condition; \/\/ Will always be Boolean. Or null. record.set( { attrName : value, ... }, options? : options ) Bulk assign record's attributes, possibly taking options. If the value is not compatible with attribute's type from the declaration, it is converted: with Type( value ) call, for primitive types. with record.attrName.set( value ), for existing record or collection (updated in place). with new Type( value ) in all other cases. Record triggers events after all changes are applied: change:attrName ( record, val, options ) for any changed attribute. change (record, options), if there were changed attributes. options { parse : true } Assume record.set argument is the raw JSON and parse it. Must be used to process the response from the server. \/\/ Another way of doing the bestSeller.clone() \/\/ Amazingly, this is guaranteed to work by default. const book = new Book(); book.set( bestSeller.toJSON(), { parse : true } ); record.assignFrom( otherRecord ) Makes an existing record to be the full clone of otherRecord, recursively assigning all attributes. \/\/ Another way of doing the bestSeller.clone() const book = new Book(); book.assignFrom( bestSeller ); Transactions All record updates occurs in the scope of transactions. Transaction is the sequence of changes which results in a single change event. Transaction can be opened either manually or implicitly with calling set() or assigning an attribute. Any additional changes made to the record in change:attr event handler will be executed in the scope of the original transaction, and won't trigger additional change events. record.transaction( fun ) Execute the all changes made to the record in fun as single transaction triggering the single change event. some.record.transaction( record =&gt; { record.a = 1; \/\/ `change:a` event is triggered. record.b = 2; \/\/ `change:b` event is triggered. }); \/\/ `change` event is triggered. Manual transactions with attribute assignments are superior to record.set() in terms of both performance and flexibility.","tags":"","url":"Record\/Updates_and_transactions.html"},{"title":"Observable changes","text":"Observable changes Object tree formed by nested records and collection is deeply observable by default; changes in every attribute trigger change events for the record and all parent elements in sequence. Record triggers following events on change: change:attrName ( record, value ) for every changed attribute. change ( record ) when record is changed. attrDef attr : Type.has.changeEvents( false ) Record automatically listens to change events of all nested records and collections, triggering appropriate change events for its attributes. This declaration turns it off for the specific attribute. Listening to changes with Events API Events API is used for managing events subscriptions. listener.listenTo( record, event, handler ) Events API method used to listen to the any of the change events. listener.stopListening( record ) Events API method to explicitly stop all event subscriptions from the record. Not needed if the listener is other record or collection. Listening to events in a record Record has declarative API for managing custom event subscriptions for its attributes. attrDef attr : Type.has.watcher( 'methodName' ) attrDef attr : Type.has.watcher( function( value, name ){ ... } ) Attach change:attr event listener to the particular record's attribute. Watcher function has the signature ( attrValue, attrName ) =&gt; void and is executed in the context of the record. Note that it differs from the event signature. @define class User extends Record { static attributes = { name : String.has.watcher( 'onNameChange' ), isAdmin : Boolean, } onNameChange(){ \/\/ Cruel. But we need it for the purpose of the example. this.isAdmin = this.name.indexOf( 'Admin' ) &gt;= 0; } } attrDef attr : Type.has.events({ eventName : handler, ... }) Automatically manage custom event subscription for the attribute. handler is either the method name or the handler function. Change inspection methods Following API might be useful in change event listeners. record.changed The changed property is the internal hash containing all the attributes that have changed during its last transaction. Please do not update changed directly since its state is internally maintained by set(). A copy of changed can be acquired from changedAttributes(). record.changedAttributes( attrs? ) Retrieve a hash of only the record's attributes that have changed during the last transaction, or false if there are none. Optionally, an external attributes hash can be passed in, returning the attributes in that hash which differ from the record. This can be used to figure out which portions of a view should be updated, or what calls need to be made to sync the changes to the server. record.previous( attr ) During a &quot;change&quot; event, this method can be used to get the previous value of a changed attribute. @define class Person extends Record{ static attributes = { name: '' } } const bill = new Person({ name: &quot;Bill Smith&quot; }); bill.on(&quot;change:name&quot;, ( record, name ) =&gt; { alert( `Changed name from ${ bill.previous('name') } to ${ name }`); }); bill.name = &quot;Bill Jones&quot;; record.previousAttributes() Return a copy of the record's previous attributes. Useful for getting a diff between versions of a record, or getting back to a valid state after an error occurs.","tags":"","url":"Record\/Observable_changes.html"},{"title":"Overview","text":"Collections are ordered sets of records. You can bind &quot;change&quot; events to be notified when any record in the collection has been modified, listen for &quot;add&quot; and &quot;remove&quot; events, fetch the collection from the server, and use a full suite of Underscore.js methods. Collection is implicitly defined for every record with a constructor accessible as MyRecord.Collection. In most cases, you don't need to declare it manually. \/\/ Implicitly defined collection. const books = new Book.Collection(); @define class ComicsShelve extends Book.Collection { static itemEvents = { \/\/ List of records's events we want to be triggered on the collection 'change:inMyReadingList' : true, 'customEvent' : true } } @define class Comics extends Book { \/\/ Use custom collection instead of the implicitly created one static Collection = ComicsShelve; \/\/ Extend record's attributes static attributes = { artist : Author } } Collection definition Implicitly defined collections RecordConstructor.Collection Every Record class has implicitly defined Collection, which can be referenced adding the .Collection to the record's constructor. Extending the Collection class Collections can be defined explicitly extending the base Collection class. There are two ways to bind collection to the record. (record definition) static Collection = CollectionConstructor Replaces implicitly defined collection with externally defined collection class. (collection definition) static model = RecordConstructor Specify the record type inside of the collection's definition. This property is being set automatically for collection types referenced as MyRecord.Collection. @define class Library extends Record.Collection { static model = Book; } Create and access the collection new Collection() Create an empty collection. new Collection( records, options? ) When creating a Collection, you may choose to pass in the initial array of records. The collection's comparator may be included as an option. Passing false as the comparator option will prevent sorting. If you define an initialize() function, it will be invoked when the collection is created. var tabs = new TabSet([tab1, tab2, tab3]); collection.initialize( records?, options? ) Initialization function which is called at the end of the constructor. collection.get( id ) Get a record from a collection, specified by an id, a cid, or by passing in a record. const book = library.get(110); collection.at( index ) Get a record from a collection, specified by index. Useful if your collection is sorted, and if your collection isn't sorted, at will still retrieve records in insertion order. When passed a negative index, it will retrieve the record from the back of the collection. collection.length Like an array, a Collection maintains a length property, counting the number of records it contains. collection.models Raw access to the JavaScript array of records inside of the collection. Usually you'll want to use get, at, or the other methods to access record objects, but occasionally a direct reference to the array is desired.","tags":"","url":"Collection\/Overview.html"},{"title":"Updates and transactions","text":"Updates Methods to update the collection. They accept common options: sort : false - do not sort the collection. parse : true - parse raw JSON (used to set collection with a data from the server). collection.add( records, options? ) Add a record (or an array of records) to the collection. If this is the Record.Collection, you may also pass raw attributes objects, and have them be vivified as instances of the Record. Returns the added (or preexisting, if duplicate) records. Pass {at: index} to splice the record into the collection at the specified index. If you're adding records to the collection that are already in the collection, they'll be ignored, unless you pass {merge: true}, in which case their attributes will be merged into the corresponding records. Trigger the one event per record: add(record, collection, options) for each record added. change(record, options) for each record changed (if the {merge: true} option is passed). Trigger the single event: update(collection, options) if any records were added. sort(collection, options) if an order of records was changed. Trigger changes event in case if any changes were made to the collection and objects inside. collection.remove( records, options? ) Remove a record (or an array of records) from the collection, and return them. Each record can be a record instance, an id string or a JS object, any value acceptable as the id argument of collection.get. Trigger remove(record, collection, options) for each record removed. If any records were removed, trigger: update(collection, options) changes(collection, options). collection.set( records, options? ) The set method performs a &quot;smart&quot; update of the collection with the passed list of records. If a record in the list isn't yet in the collection it will be added; if the record is already in the collection its attributes will be merged; and if the collection contains any records that aren't present in the list, they'll be removed. All of the appropriate &quot;add&quot;, &quot;remove&quot;, and &quot;change&quot; events are fired as this happens. Returns the touched records in the collection. If you'd like to customize the behavior, you can disable it with options: {remove: false}, or {merge: false}. Events Trigger the one event per record: add(record, collection, options) for each record added. remove(record, collection, options) for each record removed. change(record, options) for each record changed. Trigger the single event: update(collection, options) if any records were added. sort(collection, options) if an order of records was changed. Trigger changes event in case if any changes were made to the collection and objects inside. const vanHalen = new Man.Collection([ eddie, alex, stone, roth ]); vanHalen.set([ eddie, alex, stone, hagar ]); \/\/ Fires a &quot;remove&quot; event for roth, and an &quot;add&quot; event for hagar. \/\/ Updates any of stone, alex, and eddie's attributes that may have \/\/ changed over the years. collection.reset( records, options? ) Replace the collection's content with the new records. More efficient than collection.set, but does not send record-level events. Calling collection.reset() without passing any records as arguments will empty the entire collection. Trigger event reset( collection, options ). Trigger event changes( collection, options ). Transactions All collection updates occurs in the scope of transactions. Transaction is the sequence of changes which results in a single changes event. Transaction can be opened either manually or implicitly with calling any of collection update methods. Any additional changes made to the collection or its items in event handlers will be executed in the scope of the original transaction, and won't trigger an additional changes events. collection.transaction( fun ) Execute the sequence of updates in fun function in the scope of the transaction. collection.updateEach( iteratee : ( val : Record, index ) =&gt; void, context? ) Similar to the collection.each, but wraps the loop in a transaction.","tags":"","url":"Collection\/Updates_and_transactions.html"},{"title":"Observable changes","text":"Observable changes Object tree formed by nested records is deeply observable by default; changes in every item trigger change events for the collection and all parent elements in sequence. Collection triggers following events on change: change ( record, options ) for every changed record. add ( record, collection, options ) for every added record. remove ( record, collection, options ) for every removed record. update ( collection, options ) when any records were added or removed. sort ( collection, options ) when any records changed their order. reset ( collection, options ) if collection.reset() was used to update the collection. changes ( collection, options ) in case of any changes. Listening to changes with Events API Events API is used for managing events subscriptions. listener.listenTo( record, event, handler ) Events API method used to listen to the any of the change events. listener.stopListening( record ) Events API method to explicitly stop all event subscriptions from the record. Not needed if the listener is other record or collection. Listening to item events in the collection static itemEvents = { eventName : handler, ... } Subscribe for events from records. The hander is either the collection's method name, the handler function, or true. When true is passed as a handler, the corresponding event will be triggered on the collection.","tags":"","url":"Collection\/Observable_changes.html"},{"title":"Iteration methods","text":"map and forEach collection.forEach( iteratee : ( val : Record, index ) =&gt; void, context? ) collection.each( iteratee : ( val : Record, index ) =&gt; void, context? ) Iterate through the elements of the collection. Similar to Array.forEach. collection.updateEach( iteratee : ( val : Record, index ) =&gt; void, context? ) Similar to the collection.each, but wraps an iteration in a transaction. The single changes event will be emitted for the group of changes to the records made in updateEach. Use this method if you modify records in a loop. collection.map( iteratee : ( val : Record, index ) =&gt; T, context? ) Map elements of the collection. Similar to Array.map, but undefined values returned by iteratee are filtered out. Thus, collection.map can be used to map and filter elements in a single pass. Predicate methods Predicate is either the iteratee function returning boolean, or an object with attribute values used to match with record's attributes. collection.filter( iteratee : Predicate, context? ) Return filtered array of records matching the predicate. collection.every( iteratee : Predicate, context? ) : boolean Return true if all records match the predicate. collection.some( iteratee : Predicate, context? ) : boolean Return true if at least one record match the predicated.","tags":"","url":"Collection\/Iteration_methods.html"},{"title":"Sorted collections","text":"By default there is no comparator for a collection. If you define a comparator, it will be used to maintain the collection in sorted order. This means that as records are added, they are inserted at the correct index in collection.models. Note that Type-R depends on the arity of your comparator function to determine between the two styles, so be careful if your comparator function is bound. Collections with a comparator will not automatically re-sort if you later change record attributes, so you may wish to call sort after changing record attributes that would affect the order. static comparator = 'attrName' Maintain the collection in sorted order by the given record's attribute. static comparator = x =&gt; number | string &quot;sortBy&quot; comparator functions take a record and return a numeric or string value by which the record should be ordered relative to others. static comparator = ( x, y ) =&gt; -1 | 0 | 1 &quot;sort&quot; comparator functions take two records, and return -1 if the first record should come before the second, 0 if they are of the same rank and 1 if the first record should come after. Note how even though all of the chapters in this example are added backwards, they come out in the proper order: @define class Chapter extends Record { static attributes = { page : Number, title : String } } var chapters = new Chapter.Collection(); chapters.comparator = 'page'; chapters.add(new Chapter({page: 9, title: &quot;The End&quot;})); chapters.add(new Chapter({page: 5, title: &quot;The Middle&quot;})); chapters.add(new Chapter({page: 1, title: &quot;The Beginning&quot;})); alert(chapters.map( x =&gt; x.title )); collection.sort( options? ) Force a collection to re-sort itself. You don't need to call this under normal circumstances, as a collection with a comparator will sort itself whenever a record is added. To disable sorting when adding a record, pass {sort: false} to add. Calling sort triggers a &quot;sort&quot; event on the collection.","tags":"","url":"Collection\/Sorted_collections.html"},{"title":"Proxied array methods","text":"collection.push( record, options? ) Add a record at the end of a collection. Takes the same options as add. collection.pop( options? ) Remove and return the last record from a collection. Takes the same options as remove. collection.unshift( record, options? ) Add a record at the beginning of a collection. Takes the same options as add. collection.shift( options? ) Remove and return the first record from a collection. Takes the same options as remove. collection.slice( begin, end ) Return a shallow copy of the collection.models, using the same options as native Array#slice. collection.indexOf( recordOrId : any ) : number Return an index of the record in the collection, and -1 if there are no such a record in the collection. Can take the record itself as an argument, id, or cid of the record.","tags":"","url":"Collection\/Proxied_array_methods.html"},{"title":"Aggregation tree","text":"Record's attributes can hold other Records and Collections, forming indefinitely nested data structures of arbitrary complexity. To create nested record or collection you should just mention its constructor function in attribute's definition. import { Record } from 'type-r' @define class User extends Record { static attributes = { name : String, email : String, isActive : true } } @define class UsersListState extends Record { static attributes = { users : User.Collection } } All nested records and collections are aggregated by default and behave as integral parts of the containing record. Aggregated attributes are exclusively owned by the record, and taken with it together form an ownership tree. Many operations are performed recursively on aggregated elements: They are created when the owner record is created. They are cloned when the record is cloned. They are disposed when the record is disposed. They are validated as part of the record. They are serialized as nested JSON. Aggregation tree methods recordOrCollection.getOwner() Return the reference to the record which is an owner, or null if the object is the root of an aggregation tree. Due to the nature of aggregation, an object may have one and only one owner. recordOrCollection.clone() Create the deep copy of the aggregation tree, recursively cloning all aggregated records and collections. References to shared members will be copied, but not shared members themselves. recordOrCollection.set( json, { parse : true } ) Recursively update an aggregation tree in place with the raw JSON data. \/\/ Has the same effect as assignFrom(): record.set( otherRecord.toJSON(), { parse : true }); record.assignFrom( otherRecord ) collection.assignFrom( otherCollection ) Make an existing record or collection to be an exact copy of other record or collection. The whole aggregation tree will be recursively traversed and assigned. Other record\/collection must have the similar shape as the record\/collection type. \/\/ Has the same effect as record.clone(): const clonedRecord = new MyRecord(); clonedRecord.assignFrom( record ); recordOrCollection.dispose() Recursively dispose the record and its aggregated members. &quot;Dispose&quot; means that elements of the aggregation tree will unsubscribe from all event sources. It's crucial to prevent memory leaks in SPA. The whole aggregation tree will be recursively disposed, shared members won't.","tags":"","url":"API_by_feature\/Aggregation_tree.html"},{"title":"Serialization","text":"All records and collections except shared objects are serializable by default as nested JSON reflecting the structure of their aggregation tree. Serialization API recordOrCollection.toJSON() Produces the JSON for the given record or collection and its aggregated members. Aggregation tree is serialized as nested JSON. Record corresponds to an object in JSON, while the collection is represented as an array. May be overridden in the particular record or collection class. @define class Comment extends Record { static attributes = { body : '' } } @define class BlogPost extends Record { static attributes = { title : '', body : '', comments : Comment.Collection } } const post = new BlogPost({ title: &quot;Type-R is cool!&quot;, comments : [ { body : &quot;Agree&quot; }] }); const rawJSON = post.toJSON() \/\/ { title : &quot;Type-R is cool!&quot;, body : &quot;&quot;, comments : [{ body : &quot;Agree&quot; }] } new RecordOrCollection( json, { parse : true } ) Create an object and its aggregated members from its JSON representation. \/\/ Create the blog post from previous example. const rawJSON = { title : &quot;Type-R is cool!&quot;, body : &quot;&quot;, comments : [{ body : &quot;Agree&quot; }] }; const post = new BlogPost( rawJSON, { parse : true }); recordOrCollection.set( json, { parse : true } ) Update an existing object and its aggregated members from its JSON representation. \/\/ Create the blog post from previous example. const rawJSON = { title : &quot;Type-R is cool!&quot;, body : &quot;&quot;, comments : [{ body : &quot;Agree&quot; }] }; \/\/ Similar to new BlogPost( rawJSON, { parse : true }); const post = new BlogPost(); post.set( rawJSON, { parse : true }); abstract recordOrCollection.parse( json ) Invoked internally when { parse : true } is passed. May be overridden to define custom JSON transformation. Should not be called explicitly. Attribute-level serialization control Serialization can be configured for the specific attribute in the Record's attribute definition. attrDef attr : Type.has.toJSON( false ) Do not serialize the specific attribute. attrDef attr : Type.has.toJSON( ( value, name ) =&gt; json ) Override the default serialization for the specific record's attribute. Attribute is not serialized when the function return undefined. attrDef attr : Type.has.parse( ( json, name ) =&gt; value ) Transform the data before it will be assigned to the record's attribute. Invoked when the { parse : true } option is set. \/\/ Define custom boolean attribute type which is serialized as 0 or 1. const MyWeirdBool = Boolean.has .parse( x =&gt; x === 1 ) .toJSON( x =&gt; x ? 1 : 0 ); Serialization of Date There's no built-in Date type in JSON. Type-R address this issue providing the attribute-level control on date's JSON representation. attrDef attr : Date attr is serialized as an ISO string. Works in Safari as well. attrDef attr : Date.microsoft attr is serialized as Microsoft's &quot;\/Date(msecs)\/&quot; string. attrDef attr : Date.timestamp attr is serialized as UNIX integer timestamp.","tags":"","url":"API_by_feature\/Serialization.html"},{"title":"Validation","text":"Defining validators Attribute-level validators Type-R supports declarative attribute-level validation declarations. This is the preferable way of doing validation. attrDef attr : Type.has.check( predicate, errorMsg? ) Attribute-level validator. predicate : value =&gt; boolean is the function taking attribute's value and returning true whenever the value is valid. optional errorMsg is the error message which will be passed in case if the validation fail. If errorMsg is omitted, error message will be taken from predicate.error. It makes possible to define reusable validation functions. function isAge( years ){ return years &gt;= 0 &amp;&amp; years &lt; 200; } isAge.error = &quot;Age must be between 0 and 200&quot;; Attribute may have any number of checks attached, which are execute in sequence. Validation stops when first check in sequence fails. \/\/ Define new attribute metatype encapsulating validation checks. const Age = Number.has .check( x =&gt; x &gt;= 0, 'I guess you are a bit older' ) .check( x =&gt; x &lt; 200, 'No way man can be that old' ); attrDef attr : Type.isRequired The special case of attribute-level check cutting out empty values. Attribute value must be truthy to pass, &quot;Required&quot; is used as validation error. isRequired is the first validator to check, no matter in which order validators were attached. Object-level validators abstract recordOrCollection.validate() Override in the subclass to add object-level validation. Whatever is returned from validate() is treated as an error message and triggers the validation error. Validation API Validation happens transparently on the first access to any part of the validation API. Validation results are cached. Only the required parts of aggregation tree will be validated again recordOrCollection.isValid() Returns true whenever an object and its aggregation tree is valid. record.isValid( attrName ) collection.isValid( recordId ) Returns true whenever the record's attribute or collection's item is valid. record.validationError Detailed validation error information, or null if the record and its aggregated attributes are valid. An error object has tree structure mapping the invalid subtree of the aggregation tree. \/\/ ValidationError object shape { error : \/* record-level validation error msg as returned from record.validate() *\/, \/\/ Attribute-level validation errors, one entry for each invalid attribute. nested : { \/\/ Contains nested ValidationError object for nested records and collections... nestedRecord : \/* ValidationError *\/ nestedCollection : \/* ValidationError *\/ \/\/ ...and error msg for all other attributes. otherAttr : \/* attribute validation error as returned from .has.check() validator *\/ } } collection.validationError Detailed validation error information, or null if the collection and its items are valid. An error object has tree structure mapping the invalid subtree of the aggregation tree. \/\/ ValidationError object shape { error : \/* collection-level validation error msg as returned from collection.validate() *\/, \/\/ Collection items validation errors nested : { \/\/ Contains nested ValidationError object for nested records... \/* record.cid *\/ : \/* record.validationError *\/ } } record.getValidationError( attr ) collection.getValidationError( recordId ) Return the validation error for the given attr or collection's item. recordOrCollection.eachValidationError( iteratee : ( error, key, recordOrCollection ) =&gt; void ) Recursively traverse aggregation tree errors. key is null for the record-level validation error (returned from validate()). recordOrCollection is the reference to the current object.","tags":"","url":"API_by_feature\/Validation.html"},{"title":"Shared objects","text":"Shared objects Record's attributes can hold the records and collections from other aggregation trees if they are marked as shared. attrDef attr : RecordOrCollection.shared Record's attribute with a reference to the shared record or collection. It's initialized with null It's not cloned when the record is cloned (just the reference is copied over). It's not disposed when the record is disposed. It's not validated as part of the record (always valid by default) It's excluded from serialization. @define class UsersListState extends Record { static attributes = { users : User.Collection, selected : User.shared \/\/ Can be assigned with the user from this.users } } attrDef attr : Collection.Refs new Collection.Refs() Collection of references to shared records, which does not aggregate its elements. In contrast to the Collection.shared, Collection.Refs creates an instance of collection which is the part the parent record. Still, its items are not validated and serialized. @define class MyRecord extends Record { static attributes = { notCloned : SomeCollection.shared, \/\/ Reference to the _shared collection_ object. cloned : SomeCollection.Refs \/\/ _Aggregated_ collection of references to the _shared records_. }","tags":"","url":"API_by_feature\/Shared_objects.html"},{"title":"id-references and Stores","text":"Record's id record.id Predefined record's attribute, the id is an arbitrary string (integer id or UUID). id is typically generated by the server. It is used in JSON for id-references. Records can be retrieved by id from collections, and there can be just one instance of the record with the same id in the particular collection. static idAttribute = 'attrName' A record's unique identifier is stored under the id attribute. If you're directly communicating with a backend (CouchDB, MongoDB) that uses a different unique key, you may set a Record's idAttribute to transparently map from that key to id. Record's id property will still be linked to Record's id, no matter which value idAttribute has. @define class Meal extends Record { static idAttribute = &quot;_id&quot;; static attributes = { _id : Number, name : '' } } const cake = new Meal({ _id: 1, name: &quot;Cake&quot; }); alert(&quot;Cake id: &quot; + cake.id); record.isNew() Has this record been saved to the server yet? If the record does not yet have an id, it is considered to be new. id-references Serializable references to shared records are called an id-references. It is represented as record.id in JSON, and there must be the populated master collection of records on the client in order to resolve ids on parse. There are two kinds of id-references: one-to-many, and many-to-many. They are declared with the special kind of attribute annotation. Id-references behaves in the same way as shared attributes, but inner changes in referenced objects are not observed. attrDef attr : Record.from( sourceCollection ) Declare an attribute to be the record from the particular collection. Serialized as record.id. attrDef attr : Collection.subsetOf( sourceCollection ) Declare an attribute to be the collection, which is the subset of the particular collection. Serialized as an array of record ids. sourceCollection 'path.relative.to.this' sourceCollection may be the string with the dot-separated relative object path to the collection. In this case, it is resolved dynamically relative to the record's this. @define class State extends Record { items : Item.Collection, selected : Record.from( 'items' ) \/\/ Will resolve to `this.items` } sourceCollection '^path.relative.to.owner' ^ symbol in path is being translated to the getOwner() call. It's recommended to use tilda-references and stores instead. Stores and tilda-references abstract class Store sourceCollection '~path.relative.to.store' Store is the Record's subclass which serves as a root for id-references. Any id-reference with a path starting with ~ look for the nearest Store subclass traversing the aggregation tree upwards, and if there are none, it takes the default Store class Store.global. For all objects inside of the store's aggregation tree ~member will resolve to the member of this store class. If the lookup will fail, the next available store upper in aggregation tree will be used (as regular records stores can be nested), or the Store.global if there are no one. Stores in Type-R is very different to stores in other framework. Pay attention. @define class Role extends Record { static attributes = { name : String, ... } } @define class User extends Record { static attributes = { name : String, roles : Role.Collection.subsetOf( '~roles' ) } } @define class UsersDirectory extends Store { static attributes = { roles : Role.Collection, users : User.Collection \/\/ `~roles` references will be resolved against this.roles } } Store.global The default store class. Is always the last store to lookup when resolving tilda-reference. Use the default store for the globally shared data only. Each application page must have its local store. @define class MyStore extends Store { static attributes = { users : User.Collection, roles : Role.Collection } } Store.global = new MyStore(); \/\/ Now the reference '~users` will point to users collection from the MyStore.","tags":"","url":"API_by_feature\/id-references_and_Stores.html"},{"title":"Polymorphic and recursive data","text":"Polymorphic data structures Sometimes it's required to deal with the collection of records of different types. In the simplest case, Record.Collection is polymorphic in a sense that it may hold any record inside, as well as the record's attribute of the Record type. The trick, however, is to restore polymorphic data from JSON as its type is unknown. Type-R solves it with abstract records. Defining an abstract record Record base class with the create() factory function attached to its definition is an abstract record. static create( attrs, options ) The factory function used internally by Type-R to create the instance of the record. Must be defined in the base class for the polymorphic record. @define class Widget extends Record { static attributes = { type : String } static create( attrs, options ){ switch( attrs.type ){ case &quot;typeA&quot; : return new TypeA( attrs, options ); case &quot;typeB&quot; : return new TypeB( attrs, options ); } } } @define class TypeA extends Widget { static attributes = { type : &quot;typeA&quot;, ... } } @define class TypeB extends Widget { static attributes = { type : &quot;typeB&quot;, ... } } Polymorphic attributes and collections Abstract record type can be used to define serializable polymorphic attributes and collections. attrDef attr : PolymorphicRecord Attribute of polymorphic record type is serializable. PolymorphicRecord.Collection The default Collection for the polymorphic record type is serializable. Recursive data structures The record is recursive if it's uses the type of itself in its attribute definition. RecordOrCollection.define({ attributes : { name : attrDef } }) Used in conjunction with @predefine decorator to make recursive definitions referencing the same type. Replaces static attributes declaration. @predefine class Comment extends Record{} Comment.define({ attributes : { text : String, replies : Comment.Collection } }); Forward declaration of the Collection As an alternative to @predefine decorator, you may make forward declaration for the collection. \/\/ Declare the collection class. @define class Comments extends Record.Collection {} @define class Comment extends Record({ static Collection = Comments; \/\/ Make it the default Comment collection. attributes : { text : String, replies : Comments } });","tags":"","url":"API_by_feature\/Polymorphic_and_recursive_data.html"},{"title":"Events","text":"Both Record and Collection uses an efficient synchronous events implementation which is compatible with Backbone 1.1 Events API but is twice faster in average. It comes in form of Events mixin and the Messenger base class. An implementation is optimized for the large amount of relatively small subscriptions (5-10 events). Here are the benchmark results (lower is the better). It is also available separately as part of MixtureJS package. Events mixin Events is a mixin giving the object the ability to bind and trigger custom named events. Events do not have to be declared before they are bound, and may take passed arguments. import { mixins, Events } from 'type-r' @mixins( Events ) class Messenger { ... } Messenger abstract base class is included with Type-R, see below. eventsSource.trigger(event, arg1, arg2, ... ) Trigger callbacks for the given event, or space-delimited list of events. Subsequent arguments to trigger will be passed along to the event callbacks. High-level listening API All high-level event subscriptions are stopped automatically on the listener's disposal, and thus does not introduce memory leaks. This is the preferable listening API and must be used in all application code. listener.listenTo(other, event, callback) Tell an object to listen to a particular event on an other object. The advantage of using this form, instead of other.on(event, callback, object), is that listenTo allows the object to keep track of the events, and they can be removed all at once later on. The callback will always be called with object as context. view.listenTo(record, 'change', view.render ); listener.stopListening([other], [event], [callback]) Tell an object to stop listening to events. Either call stopListening with no arguments to have the object remove all of its registered callbacks ... or be more precise by telling it to remove just the events it's listening to on a specific object, or a specific event, or just a specific callback. view.stopListening(); \/\/ Unsubscribe from all events view.stopListening(record); \/\/ Unsubscribe from all events from the record All Type-R classes execute this.stopListening() from their dispose() method. listener.listenToOnce(other, event, callback) Just like listenTo, but causes the bound callback to fire only once before being removed. Low-level listening API This API is more efficient but requires manual action to stop the subscription. Must be used with care. eventSource.on(event, callback, [context]) Bind a callback function to an object. The callback will be invoked whenever the event is fired. If you have a large number of different events on a page, the convention is to use colons to namespace them: poll:start, or change:selection. The event string may also be a space-delimited list of several events... book.on(&quot;change:title change:author&quot;, ...); Callbacks bound to the special &quot;all&quot; event will be triggered when any event occurs, and are passed the name of the event as the first argument. For example, to proxy all events from one object to another: proxy.on(&quot;all&quot;, function(eventName) { object.trigger(eventName); }); All event methods also support an event map syntax, as an alternative to positional arguments: book.on({ &quot;change:author&quot;: authorPane.update, &quot;change:title change:subtitle&quot;: titleView.update, &quot;destroy&quot;: bookView.remove }); To supply a context value for this when the callback is invoked, pass the optional last argument: record.on('change', this.render, this) or record.on({change: this.render}, this). eventSource.off([event], [callback], [context]) Remove a previously bound callback function from an object. If no context is specified, all of the versions of the callback with different contexts will be removed. If no callback is specified, all callbacks for the event will be removed. If no event is specified, callbacks for all events will be removed. \/\/ Removes just the `onChange` callback. object.off(&quot;change&quot;, onChange); \/\/ Removes all &quot;change&quot; callbacks. object.off(&quot;change&quot;); \/\/ Removes the `onChange` callback for all events. object.off(null, onChange); \/\/ Removes all callbacks for `context` for all events. object.off(null, null, context); \/\/ Removes all callbacks on `object`. object.off(); Note that calling record.off(), for example, will indeed remove all events on the record \u00e2\u0080\u0094 including events that Backbone uses for internal bookkeeping. eventsSource.once(event, callback, [context]) Just like on(), but causes the bound callback to fire only once before being removed. Handy for saying &quot;the next time that X happens, do this&quot;. When multiple events are passed in using the space separated syntax, the event will fire once for every event you passed in, not once for a combination of all events Messenger Messenger is an abstract base class implementing Events mixin and some convenience methods. As all Type-R classes, its definition must be preceded with the @define decorator. import { define, Messenger } from 'type-r' @define class MyMessenger extends Messenger { } readonly messenger.cid Unique run-time only messenger instance id (string). messenger.initialize() Callback which is called at the end of the constructor. messenger.dispose() Executes messenger.stopListening() and messenger.off(). Objects must be disposed to prevent memory leaks caused by subscribing for events from singletons. List of built-in events Record events event &quot;change:attrName&quot; (record, value, options) When a specific attribute has been updated event &quot;change&quot; (record, options) When a record's attributes have changed. Collection events event &quot;changes&quot; (collection, options) The main change event. Single event triggered when the collection has been changed. event &quot;update&quot; (collection, options) Single event triggered after any number of records have been added or removed from a collection. event &quot;reset&quot; (collection, options) When the collection's entire contents have been reset. event &quot;sort&quot; (collection, options) When the collection has been re-sorted. event &quot;add&quot; (record, collection, options) When a record is added to a collection. event &quot;remove&quot; (record, collection, options) When a record is removed from a collection. event &quot;change&quot; (record, options) When a record's attributes have changed.","tags":"","url":"Events.html"},{"title":"Mixins","text":"Type-R is based on mixins with configurable properties merge rules. decorator @mixins( mixinA, mixinB, ... ) class X ... Merge specified mixins to the class definition. Both plain JS object and class constructor may be used as mixin. In the case of the class constructor, missing static members will copied over as well. import { mixins, Events } from 'type-r' ... @mixins( Events, plainObject, MyClass, ... ) class X { ... } decorator @mixinRules({ propName : rule, ... }) class ...` Specified class properties will be merged according to the given rule. Rules can be extended and overridden in any subclass. Mixin rules rule propName : 'merge' Assume the property to be an object. Merge objects from mixins. rule propName : { name1 : rule, ... } Assume the property to be an object. Recursively define merge rules for its properties. rule propName : 'pipe' Assume the property to be the function with a signature ( x : T ) =&gt; T. Join functions from mixins in a pipe: f1( f2( f3( x ) ) ). rule propName : 'sequence' Assume the property to be the function. Call functions from mixins in sequence: f1.apply( this, arguments ); f2.apply( this, arguments );... rule propName : 'reverse' Same as sequence, but functions are called in the reverse sequence. rule propName : 'mergeSequence' Assume the property to be the function returning object. Merge objects returned by functions from mixins, executing them in sequence. rule propName : 'every' Assume property to be the function returning boolean. Return true if all functions from mixins return truthy values. rule propName : 'some' Same as every, but return true when at least one function from mixins returns true.","tags":"","url":"Mixins.html"}]}