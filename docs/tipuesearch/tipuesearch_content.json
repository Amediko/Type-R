{"pages":[{"title":"Type-R","text":"Type-R is the universal state management JS framework designed to manage both UI and domain application state. Reactive and persistent state All data objects defined with Type-R are observable and serializable by default. Complex serialization scenarios like many-to-many relations are supported out of box. Declarative validation Validation checks are transparent and defined as a part of an attributes definition. Dynamically type-safe State elements are typed. It's guaranteed that state elements will retain declared types at run-time no matter what. Client-server communication is validated and guarded from type errors from both ends.","tags":"","url":"index.html"},{"title":"Getting Started","text":"Features Installation Is packed as UMD and ES6 module. No side dependencies. npm install type-r --save-dev Requirements IE10+, Edge, Safari, Chrome, Firefox are supported. IE9 and Opera may work but has not been tested. IE8 won't work.","tags":"","url":"Getting_Started.html"},{"title":"Overview","text":"React-MVx is built around the idea of universal state management featuring the same technique to manage the local component state, application page state, and the global application state. Basic building blocks of the application architecture are: React-MVx Component (extended React.Component) for the view layer. Records and Collection (provided by Type-R data framework) for managing all kinds of an application state. Links for two-way data binding. Stores (which is the subclass of the Record and can be dynamically created) for resolving record's id-references. React-MVx Component uses the Record class to manage its local state. Record can consists of other records and collections, describing the data structure of arbitrary complexity. All records are serializable by default, has deeply observable changes, and supports the declarative validation. The behavior of record's attributes and component state\/props elements is controlled with declarative type annotations. React-MVx extends React namespace and should be used instead of react. All class Component definitions must be preceeded with the @define decorator. import React, { define } from 'react-mvx' @define class HelloApp extends React.Component { static state = { count : 0 }; render(){ const { state } = this; return ( &lt;h1 onClick={ () =&gt; state.count++ }&gt; Hi there! { state.count } &lt;\/h1&gt;; ); } }","tags":"","url":"Overview.html"},{"title":"Basics","text":"Record is the serializable class with typed attributes, observable changes, and custom validation checks. It is the main building block for managing the application state; component local state, stores, and collection elements are all subclasses of the Record. In contrast to the &quot;model&quot; class in the majority of data frameworks, Record is not the key-value hash. It's the class with statically defined set of attributes of known types. Record itself is an abstract class. The subclass needs to be defined for every data structure of different shape, in a similar way as it's done in statically typed languages. import { define, Record } from 'type-r' \/\/ \u00e2\u00a4\u00b9 required to make magic work @define class User extends Record { \/\/ \u00e2\u00a4\u00b9 attribute's declaration static attributes = { firstName : '', \/\/ \u00e2\u009f\u00b5 String type is inferred from the default value lastName : String, \/\/ \u00e2\u009f\u00b5 Or you can just mention its constructor email : String.value( null ), \/\/\u00e2\u009f\u00b5 Or you can provide both createdAt : Date, \/\/ \u00e2\u009f\u00b5 And it works for any constructor. \/\/ And you can attach \u00e2\u00a4\u00b9 metadata to fine-tune attribute's behavior lastLogin : Date.value( null ).has.toJSON( false ) \/\/ \u00e2\u009f\u00b5 not serializable } } const user = new User(); console.log( user.createdAt ); \/\/ \u00e2\u009f\u00b5 this is an instance of Date created for you. const users = new User.Collection(); \/\/ \u00e2\u009f\u00b5 Collections are defined automatically. users.on( 'changes', () =&gt; updateUI( users ) ); \/\/ \u00e2\u009f\u00b5 listen to the changes. users.set( json, { parse : true } ); \/\/ \u00e2\u009f\u00b5 parse raw JSON from the server. users.updateEach( user =&gt; user.firstName = '' ); \/\/ \u00e2\u009f\u00b5 bulk update triggering 'changes' once Record definition Record must extend Record base class, it must have static attributes definition, and the class definition must be preceeded with @define decorator. static attributes = { name : attrDef, ... } Record is a class with an observalbe and serializable public attributes. Attributes must be declared statically in static attributes class member, which is an object hash mapping an attribute name name to its declaration, encapsulating attribute type, default value, and metadata controlling different aspects of attribute behavior. @define class User extends Record { static attributes = { name : String.value( 'John Dow' ), email : 'john.dow@mail.com', \/\/ Same as String.value( 'john.dow@mail.com' ) address : String, \/\/ Same as String.value( '' ) } } The Record guarantee that every attribute will always hold the value of the declared type. Whenever the an attribute is being assigned with the value which is not compatible with its declared type, the type is being converted with an invocation of the constructor: new Type( value ) (primitive types are treated specially). Attribute definitions attrDef name : Type.value( defaultValue ) The general form of type annotation is Type.value( defaultValue ), where the Type is the corresponding constructor function. attrDef name : Type When the function is used as attrDef, it's treated as the constructor function. Any constructor function may be used as an attribute type, if it behaves as converting constructor (like new Date( msecs )). attrDef name : defaultValue When other value than function is passed, it's treated as the default value and the type is being inferred form the value. If you need to pass function as the default value, use Function.value( theFunction ). Record's class members Record behaves as regular ES6 class with attributes accessible as properties. new Record() Create an instance of the record with the default attribute values taken from the attributes definition. When no default value is explicitly provided, it's new Type() (just Type() for primitives). When the default value is provided and it's not compatible with the attribute type, it's converted with new Type( defaultValue ) call. new Record({ attrName : value, ... }, options? ) When creating an instance of a record, you can pass in the initial values of the attributes, which will be set on the record. If {parse: true} is passed as an option, attrs is assumed to be the JSON. If the value of the particular attribute is not compatible with its type, it's converted to this type invoking the constructor new Type( value ) (just Type( value ) for primitives). @define class Book extends Record { static attributes = { title : '', author : '' } } const book = new Book({ title: &quot;One Thousand and One Nights&quot;, author: &quot;Scheherazade&quot; }); record.initialize( attrs?, options? ) Called at the end of the Record constructor when all attributes are assigned and record's inner state is properly initialized. Takes the same arguments as a constructor. record.attrName Record's attributes may be directly accessed with record.name, as if they would be the members of the class. Please note, that you have to declare all attributes in static attributes declaration before use. @define class Account extends Record { static attributes = { name : String, ballance : Number } } const myAccount = new Account({ name : 'mine' }); myAccount.ballance += 1000000; \/\/ That works. Good, eh?","tags":"","url":"Record\/Basics.html"},{"title":"Updates and transactions","text":"Update record attributes record.attrName = value Assign record attribute. If the value is not compatible with attribute's type, special action is taken: For primitive attribute, it's converted with Type( value ) call. For record or collection, it's used to update it in place with record.attrName.set( value ). In other cases, it's converted with new Type( value ) call. In case of changes, the record triggers events: change:attrName ( record, value ). change ( record ). record.set( { attrName : value, ... }, options? : options ) Bulk assign record's attributes, possibly taking options. If the value is not compatible with attribute's type, special action is taken: For primitive attribute, it's converted with Type( value ) call. For record or collection, it's used to update it in place with record.attrName.set( value ). In other cases, it's converted with new Type( value ) call. In case of changes, the record triggers events: For any changed attribute, trigger event change:attrName ( record, val, options ). If any attribute has changed: trigger event change (record, options). options { parse : true } Transform record.set argument with user-defined parse logic. Typically used to process the responce from the server to make user-defined JSON format conversion. options { merge : true } Merge attributes of record and collection types instead of replacement. If the new instance of record or collection is to be assigned, update the current instances instead. record.assignFrom( otherRecord ) Makes an existing record to be the copy of otherRecord, recursively assigning all attributes. Works similar to record.set( otherRecord.attributes, { merge : true }); Transactions All record updates occures in the scope of transactions. Transaction is the sequence of changes which results in a single change event. Transaction can be opened either manually or implicitly with calling set() or assigning an attribute. Any additional changes made to the record in change:attr event handler will be executed in the scope of the original transaction, and won't trigger additional change events. record.transaction( fun ) Execute the all changes made to the record in fun as single transaction. some.record.transaction( record =&gt; { record.a = 1; \/\/ `change:a` is triggered. record.b = 2; \/\/ `change:b` is triggered. }); \/\/ `change` is triggered. Manual transactions with attribute assignments are superior to record.set() in terms of both performance and flexibility.","tags":"","url":"Record\/Updates_and_transactions.html"},{"title":"Listening to events","text":"Observable changes Object tree formed by records and collection is deeply observable by default; changes in tree leafs triggers the changes of all parent elements in sequence. Records automatically listens to change events of all nested records and collections, and triggers the corresponding change events on its attributes. attrDef attr : Type.has.changeEvents( false ) Do not listen for the inner changes of the specific attr. Listening to events in the record Record has declarative API for managing event subscriptions for its attributes. attrDef attr : Type.has.watcher( 'methodName' ) attrDef attr : Type.has.watcher( function( value, name ){ ... } ) Attach change:attr event listener to the particular record's attribute. Watcher function has the signature ( attrValue, attrName ) =&gt; void and is executed in the context of the record. Note that it differs from the event signature. @define class User extends Record { static attributes = { name : String.has.watcher( 'onNameChange' ), isAdmin : Boolean, } onNameChange(){ \/\/ Cruel. But we need it for the purpose of the example. this.isAdmin = this.name.indexOf( 'Admin' ) &gt;= 0; } } attrDef attr : Type.has.events({ eventName : handler, ... }) Automatically manage custom event subscription for the attribute. handler is either the method name or the handler function. Events subscription with Events API listener.listenTo() and listener.listenToOnce() methods can be used to listen to the any of the change events. If listener itself is the record or collection, subscribtions will be stopped automatically. Otherwise they must be stopped manually with listener.stopListening() call to prevent memory leaks. Change inspection methods Following API might be useful in change event listeners. record.changed The changed property is the internal hash containing all the attributes that have changed during its last transaction. Please do not update changed directly since its state is internally maintained by set(). A copy of changed can be acquired from changedAttributes(). record.changedAttributes( attrs? ) Retrieve a hash of only the record's attributes that have changed during the last transaction, or false if there are none. Optionally, an external attributes hash can be passed in, returning the attributes in that hash which differ from the record. This can be used to figure out which portions of a view should be updated, or what calls need to be made to sync the changes to the server. record.previous( attr ) During a &quot;change&quot; event, this method can be used to get the previous value of a changed attribute. @define class Person extends Record{ static attributes = { name: '' } } const bill = new Person({ name: &quot;Bill Smith&quot; }); bill.on(&quot;change:name&quot;, ( record, name ) =&gt; { alert( `Changed name from ${ bill.previous('name') } to ${ name }`); }); bill.name = &quot;Bill Jones&quot;; record.previousAttributes() Return a copy of the record's previous attributes. Useful for getting a diff between versions of a record, or getting back to a valid state after an error occurs.","tags":"","url":"Record\/Listening_to_events.html"},{"title":"Basics","text":"Collections are ordered sets of records. You can bind &quot;change&quot; events to be notified when any record in the collection has been modified, listen for &quot;add&quot; and &quot;remove&quot; events, fetch the collection from the server, and use a full suite of Underscore.js methods. Collection is implicitly defined for every record with a constructor accessible as MyRecord.Collection. In most cases, you don't need to declare it manually. \/\/ Implicitly defined collection. const books = new Book.Collection(); @define class ComicsShelve extends Book.Collection { static itemEvents = { \/\/ List of records's events we want to be triggered on the collection 'change:inMyReadingList' : true, 'customEvent' : true } } @define class Comics extends Book { \/\/ Use custom collection instead of the implicitly created one static Collection = ComicsShelve; \/\/ Extend record's attributes static attributes = { artist : Author } } Collection definition Every Record class has implicitly defined Collection, which can be referenced adding the .Collection to the record's constructor. Collections can be defined explicitly extending the base Collection class. There are two ways to bind collection to the record. In record definition static Collection = CollectionConstructor Replaces implicitly defined collection with externally defined collection class. In collection definition static model = RecordConstructor If defined, you can pass raw attributes objects (and arrays) to add, create, and reset, and the attributes will be converted into a model of the proper type. @define class Library extends Record.Collection { static model = Book; } This property is being set automatically for collection types referenced as MyRecord.Collection. Members new Collection() Create an empty collection. new Collection( models, options? ) When creating a Collection, you may choose to pass in the initial array of models. The collection's comparator may be included as an option. Passing false as the comparator option will prevent sorting. If you define an initialize() function, it will be invoked when the collection is created. There are a couple of options that, if provided, are attached to the collection directly: model and comparator. Pass null for models to create an empty Collection with options. var tabs = new TabSet([tab1, tab2, tab3]); collection.initialize( models?, options? ) Initialization function which is called at the end of the constructor. collection.get( id ) Get a record from a collection, specified by an id, a cid, or by passing in a record. const book = library.get(110); collection.at( index ) Get a record from a collection, specified by index. Useful if your collection is sorted, and if your collection isn't sorted, at will still retrieve records in insertion order. When passed a negative index, it will retrieve the record from the back of the collection. collection.length Like an array, a Collection maintains a length property, counting the number of models it contains. collection.models Raw access to the JavaScript array of models inside of the collection. Usually you'll want to use get, at, or the other methods to access model objects, but occasionally a direct reference to the array is desired.","tags":"","url":"Collection\/Basics.html"},{"title":"Updates and transactions","text":"Updates Methods to update the collection. They accept common options: sort : false - do not sort the collection. parse : true - parse raw JSON (used to set collection with a data from the server). collection.add( models, options? ) Add a record (or an array of records) to the collection. If this is the Record.Collection, you may also pass raw attributes objects, and have them be vivified as instances of the Record. Returns the added (or preexisting, if duplicate) records. Pass {at: index} to splice the record into the collection at the specified index. If you're adding records to the collection that are already in the collection, they'll be ignored, unless you pass {merge: true}, in which case their attributes will be merged into the corresponding records. Trigger the one event per record: add(record, collection, options) for each record added. change(record, options) for each record changed (if the {merge: true} option is passed). Trigger the single event: update(collection, options) if any records were added. sort(collection, options) if an order of records was changed. Trigger changes event in case if any changes were made to the collection and objects inside. collection.remove( records, options? ) Remove a record (or an array of records) from the collection, and return them. Each record can be a record instance, an id string or a JS object, any value acceptable as the id argument of collection.get. Trigger remove(record, collection, options) for each record removed. If any records were removed, trigger: update(collection, options) changes(collection, options). collection.set( records, options? ) The set method performs a &quot;smart&quot; update of the collection with the passed list of records. If a record in the list isn't yet in the collection it will be added; if the record is already in the collection its attributes will be merged; and if the collection contains any records that aren't present in the list, they'll be removed. All of the appropriate &quot;add&quot;, &quot;remove&quot;, and &quot;change&quot; events are fired as this happens. Returns the touched records in the collection. If you'd like to customize the behavior, you can disable it with options: {remove: false}, or {merge: false}. Events Trigger the one event per record: add(record, collection, options) for each record added. remove(record, collection, options) for each record removed. change(record, options) for each record changed. Trigger the single event: update(collection, options) if any records were added. sort(collection, options) if an order of records was changed. Trigger changes event in case if any changes were made to the collection and objects inside. const vanHalen = new Man.Collection([ eddie, alex, stone, roth ]); vanHalen.set([ eddie, alex, stone, hagar ]); \/\/ Fires a &quot;remove&quot; event for roth, and an &quot;add&quot; event for &quot;hagar&quot;. \/\/ Updates any of stone, alex, and eddie's attributes that may have \/\/ changed over the years. collection.reset( records, options? ) Replace the collection's content with the new records. More efficient than collection.set, but does not send record-level events. Calling collection.reset() without passing any records as arguments will empty the entire collection. Trigger event reset( collection, options ). Trigger event changes( collection, options ). Transactions All collection updates occures in the scope of transactions. Transaction is the sequence of changes which results in a single changes event. Transaction can be opened either manually or implicitly with calling any of collection update methods. Any additional changes made to the collection or its items in event handlers will be executed in the scope of the original transaction, and won't trigger an additional changes events. collection.transaction( fun ) Execute the sequence of updates in fun function in the scope of the transaction. collection.updateEach( iteratee : ( val : Record, index ) =&gt; void, context? ) Similar to the collection.each, but wraps the loop in a transaction.","tags":"","url":"Collection\/Updates_and_transactions.html"},{"title":"Listening to events","text":"Observable changes Object tree formed by records and collection is deeply observable by default; changes in tree leafs triggers the changes of all parent elements in sequence. Collection automatically listens to change events of all of its records, and triggers change and changes events. Listening to item events in the collection static itemEvents = { eventName : handler, ... } Subscribe for events from records. The hander is either the collection's method name, the handler function, or true. When true is passed as a handler, the corresponding event will be triggered on the collection. Events subscription with Events API listener.listenTo() and listener.listenToOnce() methods can be used to listen to the any of the collection events.s If listener itself is the record or collection, subscribtions will be stopped automatically. Otherwise they must be stopped manually with listener.stopListening() call to prevent memory leaks.","tags":"","url":"Collection\/Listening_to_events.html"},{"title":"Iteration methods","text":"map and forEach collection.forEach( iteratee : ( val : Record, index ) =&gt; void, context? ) collection.each( iteratee : ( val : Record, index ) =&gt; void, context? ) Iterate through the elements of the collection. Similar to Array.forEach. collection.updateEach( iteratee : ( val : Record, index ) =&gt; void, context? ) Similar to the collection.each, but wraps an iteration in a transaction. The single changes event will be emitted for the group of changes to the records made in updateEach. Use this method if you modify records in a loop. collection.map( iteratee : ( val : Record, index ) =&gt; T, context? ) Map elements of the collection. Similar to Array.map, but undefined values returned by iteratee are filtered out. Thus, collection.map can be used to map and filter elements in a single pass. Predicate methods Predicate is either the iteratee function returning boolean, or an object with attribute values used to match with record's attributes. collection.filter( iteratee : Predicate, context? ) Return filtered array of records matching the predicate. collection.every( iteratee : Predicate, context? ) : boolean Return true if all records match the predicate. collection.some( iteratee : Predicate, context? ) : boolean Return true if at least one record match the predicated.","tags":"","url":"Collection\/Iteration_methods.html"},{"title":"Sorted collections","text":"By default there is no comparator for a collection. If you define a comparator, it will be used to maintain the collection in sorted order. This means that as records are added, they are inserted at the correct index in collection.models. Note that Type-R depends on the arity of your comparator function to determine between the two styles, so be careful if your comparator function is bound. Collections with a comparator will not automatically re-sort if you later change model attributes, so you may wish to call sort after changing model attributes that would affect the order. static comparator = 'attrName' Maintain the collection in sorted order by the given record's attribute. static comparator = x =&gt; number | string &quot;sortBy&quot; comparator functions take a model and return a numeric or string value by which the model should be ordered relative to others. static comparator = ( x, y ) =&gt; -1 | 0 | 1 &quot;sort&quot; comparator functions take two models, and return -1 if the first model should come before the second, 0 if they are of the same rank and 1 if the first model should come after. Note how even though all of the chapters in this example are added backwards, they come out in the proper order: var Chapter = Backbone.Model; var chapters = new Backbone.Collection; chapters.comparator = 'page'; chapters.add(new Chapter({page: 9, title: &quot;The End&quot;})); chapters.add(new Chapter({page: 5, title: &quot;The Middle&quot;})); chapters.add(new Chapter({page: 1, title: &quot;The Beginning&quot;})); alert(chapters.pluck('title')); collection.sort( options? ) Force a collection to re-sort itself. You don't need to call this under normal circumstances, as a collection with a comparator will sort itself whenever a model is added. To disable sorting when adding a model, pass {sort: false} to add. Calling sort triggers a &quot;sort&quot; event on the collection.","tags":"","url":"Collection\/Sorted_collections.html"},{"title":"Proxied array methods","text":"collection.push( record, options? ) Add a record at the end of a collection. Takes the same options as add. collection.pop( options? ) Remove and return the last record from a collection. Takes the same options as remove. collection.unshift( model, options? ) Add a model at the beginning of a collection. Takes the same options as add. collection.shift( options? ) Remove and return the first model from a collection. Takes the same options as remove. collection.slice( begin, end ) Return a shallow copy of the collection.models, using the same options as native Array#slice. collection.indexOf( recordOrId : any ) : number Return an index of the record in the collection, and -1 if there are no such a record in the collection. Can take the record itself as an argument, id, or cid of the record.","tags":"","url":"Collection\/Proxied_array_methods.html"},{"title":"Overview","text":"Records can have attributes holding other Records and Collections, forming indefinitely nested data structures of arbitrary complexity. To create nested record or collection you should just mention its type in attribute's type annotation. import { Record } from 'type-r' @define class User extends Record { static attributes = { name : String, email : String, isActive : true } } @define class UsersListState extends Record { static attributes = { users : User.Collection } } All nested records and collections are aggregated by default and behave as integral parts of the containing record. Aggregated attributes are exclusively owned by the record, and taken with it together form an ownerhip tree. Many operations are performed recursively on aggregated elements: They are created when the owner record is created. They are cloned when the record is cloned. They are disposed when the record is disposed. They are validated as part of the record. They are serialized as nested JSON. Aggregation tree methods recordOrCollection.getOwner() Return the reference to the record's owner, or null if record is not the part of aggregation tree. Due to the nature of aggregation, an object may have one and only one owner. recordOrCollection.clone() Clone the record and all aggregated records and collections. The whole aggregation tree will be recursively cloned, references to shared members will copied. record.assignFrom( otherRecord ) collection.assignFrom( otherCollection ) Recursively assign the record and its aggregated members with values from otherRecord. This operation is similar to record.clone(), but instead of creation of the cloned record it makes an existing record to be the copy of other record. The whole aggregation tree will be recursively assigned, references to shared members will copied. recordOrCollection.dispose() Recursively dispose the record and its aggregated members. &quot;Dispose&quot; means that elements of the aggregation tree will unsubscribe from all event sources. It's crucial to prevent memory leaks in SPA. The whole aggregation tree will be recursively disposed, shared members won't.","tags":"","url":"Aggregation_tree\/Overview.html"},{"title":"Serialization","text":"Aggregation tree formed of records and collections is serializable by default. Record corresponds to an object in JSON, while the collection is represented as an array. Serialization API recordOrCollection.toJSON() Produces the JSON for the aggregation tree of the record or collection. May be overriden in particular record or collection. new RecordOrCollection( json, { parse : true } ) Constructs an aggregation tree from its JSON representation. recordOrCollection.set( json, { parse : true } ) Update an aggregation tree from its JSON representation. recordOrCollection.parse( json ) May be overriden to add custom JSON transformation. Attribute-level serialization control Serialization can be controlled for the specific attribute in the Recrod's attribute definition. attrDef attr : Type.has.toJSON( false ) Exclude attribute from the resulting JSON. attrDef attr : Type.has.toJSON( ( value, name ) =&gt; json ) Override the default toJSON() method for the selected record's attribute. attrDef attr : Type.has.parse( ( json, name ) =&gt; value ) Transform the data before it will be passed to the record's attribute.","tags":"","url":"Aggregation_tree\/Serialization.html"},{"title":"Validation","text":"Defining validators Attribute-level validators Type-R supports declarative attribute-level validation declarations. This is the preferable way of doing validation. attrDef attr : Type.has.check( predicate, errorMsg? ) Attribute-level validator. predicate : value =&gt; boolean is the function taking attribute's value and returning true whenever the value is valid. optional errorMsg is the error message which will be passed in case if the validation fail. If errorMsg is omitted, error message will be taken from predicate.error. It makes possible to define reusable validation functions. function isAge( years ){ return years &gt;= 0 &amp;&amp; years &lt; 200; } isAge.error = &quot;Age must be between 0 and 200&quot;; Attribute may have any number of checks attached, which are execute in sequence. Validation stops when first check in sequence fails. \/\/ Define new attribute metatype encapsulating validation checks. const Age = Number.has .check( x =&gt; x &gt;= 0, 'I guess you are a bit older' ) .check( x =&gt; x &lt; 200, 'No way man can be that old' ); attrDef attr : Type.isRequired The special case of attribute-level check cutting out empty values. Attribute value must be truthy to pass, &quot;Required&quot; is used as validation error. isRequired is the first validator to check, no matter in which order validators were attached. Object-level validators recordOrCollection.validate() Override in the subclass to add object-level validation. Whatever is returned from validate() is treated as an error message and triggers the validation error. Validation API Validation Validation happens transparently on the first access to any part of the validation API. Validation results are cached. Only the required parts of aggregation tree will be validated again recordOrCollection.isValid() Returns true whenever an object and its aggregation tree is valid. record.isValid( attrName ) collection.isValid( recordId ) Returns true whenever the record's attribute or collection's item is valid. record.validationError Detailed validation error information, or null if the record and its aggregation tree is valid. An error object has tree structure mapping the invalid subtree of the aggregation tree. \/\/ ValidationError object shape { error : \/* record-level validation error msg as returned from record.validate() *\/, \/\/ Attribute-level validation errors, one entry for each invalid attribute. nested : { \/\/ Contains nested ValidationError object for nested records and collections... nestedRecord : \/* ValidationError *\/ nestedCollection : \/* ValidationError *\/ \/\/ ...and error msg for all other attributes. otherAttr : \/* attribute validation error as returned from .has.check() validator *\/ } } collection.validationError Detailed validation error information, or null if the collection and its aggregation tree is valid. An error object has tree structure mapping the invalid subtree of the aggregation tree. \/\/ ValidationError object shape { error : \/* collection-level validation error msg as returned from collection.validate() *\/, \/\/ Collection items validation errors nested : { \/\/ Contains nested ValidationError object for nested records... \/* record.cid *\/ : \/* record.validationError *\/ } } record.getValidationError( attr ) collection.getValidationError( recordId ) Return the validation error for the given attr or collection's item. recordOrCollection.eachValidationError( iteratee : ( error, key, recordOrCollection ) =&gt; void ) Recursively traverse aggregation tree errors. key is null for the record-level validation error (returned from validate()). recordOrCollection is the reference to the current object.","tags":"","url":"Aggregation_tree\/Validation.html"},{"title":"Shared objects","text":"Shared objects Record's attributes can hold the records and collections from other aggregation trees if they are marked as shared. attrDef attr : RecordOrCollection.shared Record's attribute with a reference to the shared model or collection. It's initialized with null It's not cloned when the record is cloned (just the reference is copied over). It's not disposed when the record is disposed. It's not validated as part of the record (always valid by default) It's excluded from serialization. @define class UsersListState extends Record { static attributes = { users : User.Collection, selected : User.shared \/\/ Can be assigned with the user from this.users } } attrDef attr : Collection.Refs new Collection.Refs() Collection of references to shared records, which does not aggregate its elements. In constrast to the Collection.shared, Collection.Refs creates an instance of collection which is the part the parent record. Still, its items are not validated and serialized. @define class MyRecord extends Record { static attributes = { notCloned : SomeCollection.shared, \/\/ Reference to the _shared collection_ object. cloned : SomeCollection.Refs \/\/ _Aggregated_ collection of references to the _shared records_. }","tags":"","url":"Aggregation_tree\/Shared_objects.html"},{"title":"id-references","text":"Record's id record.id Predefined record's attribute, the id is an arbitrary string (integer id or UUID). id is typically generated by the server. It is used in JSON for id-references. Records can be retrieved by id from collections, and there can be just one instance of the record with the same id in the particular collection. static idAttribute = 'attrName' A record's unique identifier is stored under the id attribute. If you're directly communicating with a backend (CouchDB, MongoDB) that uses a different unique key, you may set a Record's idAttribute to transparently map from that key to id. Record's id property will still be linked to Record's id, no matter which value idAttribute has. @define class Meal extends Record { static idAttribute = &quot;_id&quot;; static attributes = { _id : Number, name : '' } } const cake = new Meal({ _id: 1, name: &quot;Cake&quot; }); alert(&quot;Cake id: &quot; + cake.id); record.isNew() Has this record been saved to the server yet? If the record does not yet have an id, it is considered to be new. id-references Serializable references to shared records are called an id-references. It is represented as record.id in JSON, and there must be the populated master collection of records on the client in order to resolve ids on parse. There are two kinds of id-references: one-to-many, and many-to-many. They are declared with the special kind of attribute annotation. Id-references behaves in the same way as shared attributes, but inner changes in referenced objects are not observed. attrDef attr : Record.from( sourceCollection ) Declare an attribute to be the record from the particular collection. Serialized as record.id. attrDef attr : Collection.subsetOf( sourceCollection ) Declare an attribute to be the collection, which is the subset of the particular collection. Serialized as an array of record ids. Relative paths to source collection sourceCollection can be the string with the dot-separated relative object path to the collection. In this case, it is resolved dynamically relative to the record's this. @define class State extends Record { items : Item.Collection, selected : Record.from( 'items' ) \/\/ Will resolve to `this.items` }","tags":"","url":"Aggregation_tree\/id-references.html"},{"title":"Guide","text":"","tags":"","url":"Store\/Guide.html"},{"title":"Stores and relations basics","text":"The problem When you building complex data layer, sooner or later you will need to cross-reference objects by id. Lets consider users and roles as an example. For the purpose of the example we assume (and in many real cases its true), that users and models related to each other as many-to-many. Two questions arise - how will we send these data in JSON, and how would we ideally want them to appear in our models layer. Lets start with JSON for the users. Obvious solution would be the one as follows: const users = [{ &quot;id&quot; : 1, &quot;login&quot; : &quot;Vini&quot; &quot;roles&quot; : [ { &quot;id&quot; : 1, &quot;name&quot; : &quot;Admin&quot; }, { &quot;id&quot; : 2, &quot;name&quot; : &quot;User&quot; } ] }, { &quot;id&quot; : 2, &quot;login&quot; : &quot;Avraham&quot; &quot;roles&quot; : [ { &quot;id&quot; : 1, &quot;name&quot; : &quot;Admin&quot; }, { &quot;id&quot; : 2, &quot;name&quot; : &quot;User&quot; } ] }, ... ] So, our user's model in this case will look like this: @define class Role extends Record { static attributes = { name : String } } @define class Users extends Record { static attributes = { login : String, roles : Role.Collection } } Obvious problem is that we're transferring the same roles multiple times, which increase the traffic. Less obvious problem is that when objects for role 1 will be deserialized, they will actually become different objects in every user model. So, when one of them needs to be modified, it should be modified for every user. In short, as relational DB developer would say, these data are not normalized. So, the best thing we could do, is to normalize them, putting roles in separate collection. So, our 'users collection' becomes 'users directory object'. { &quot;users&quot; : [ { &quot;id&quot; : 1, &quot;login&quot; : &quot;Vini&quot; &quot;roles&quot; : [ 1, 2 ] }, { &quot;id&quot; : 2,inter &quot;login&quot; : &quot;Avraham&quot; &quot;roles&quot; : [ 1, 2 ] }, ... ], &quot;roles&quot; : [ { &quot;id&quot; : 1, &quot;name&quot; : &quot;Admins&quot; }, { &quot;id&quot; : 2, &quot;name&quot; : &quot;Users&quot; }, ... ] } Now JSON looks okay, and we face the second problem. How would we want it to appear in our data layer? Handling &quot;to-many&quot; relationship I would say, it would be an ideal case if the user of the data layer wouldn't notice this complexity at all. If it will look for us like full collection of roles, and as nested collections of roles in every user model (but roles in this nested collection will be actually the references to shared objects in full collection of roles), it would be just fine. Fortunately, this is just the thing which NestedTypes allows you to do. It will require some changes to our model definition, though: @define class Role extends Record { static attributes = { name : String } } @define class Users extends Record{ static attributes = { login : String, roles : Role.Collection.subsetOf( '~roles' ) } } @define class UsersDirectory extends Record{ static attributes = { users : User.Collection, roles : Role.Collection } } There are two new things here - Role.Collection.subsetOf( '~roles' ) and Store. Lets understand what does it mean. CollectionType.subsetOf( path ) spec literally means that the type of an attribute is the given collection, which will consists of an elements from different collection with a given path relative to model's this. ~ is the shortcut for getStore() method, so ~roles path will be resolved to this.getStore().roles. getStore() method, in turn, will locate the nearest store model traversing object ownership tree upwards, until it will find something which extends Store base class. Speaking simply, ~roles reference points to the roles attribute of the Store model, which is the closest parent of our model. This semantic is important as it allows us to have multiple store instances in the system at the same time. Now, how this code works. subsetOf attributes are always serialized as an arrays of model ids. So, it will take array of roles ids from the JSON, and wait for the moment you will actually try to read it. And when you read user.roles attribute for the first time, it will take master collection from the path you specified, and resolve ids to real models. Speaking simply, user.roles will appear to you as if it would be the regular Roles.Collection. And it's the key point of design that you should notice nothing strange. There are some differences in behaviour, due to the fact that subsetOf is treated as relation, not aggregation: Collection.subsetOf is considered as changed (and throws 'changes' event) only in case its elements are being added or removed. No member models changes will trigger collection change, and parent model change. When Collection.subsetOf is deep cloned, it doesn't clone its elements. You can use model ids in the place of the models in set and add methods. As it was mentioned above, it's serialized to an array of ids. Handling cross-references Okay. But what if you want both user and role to reference each other? Yep, you can do it too using the special form of extend for forward declaration: \/\/ Make forward declaration for the User... @predefine class User extends Record{} @define class Role extends Record { static attributes = { name : String, users : User.Collection.subsetOf( '~users' ) } } User.define({ attributes : { login : String, roles : Role.Collection.subsetOf( '~roles' ) } }); @define class UsersDirectory = Store.extend({ static attributes = { users : User.Collection, roles : Role.Collection } } to-one relationships and default store Lets say, we have some content created by users. We have few authors, and it would probably be not so bad idea to reference author of this content in JSON by user id. However, we don't like an idea that all our collections would be bound to the same store as UserDirectory. First obvious thing we could do to resolve this situation, is to create some global default store holding all 'dictionary' data which would be used to resolve such an ids across the system. Lets create such a store: Nested.store = new UsersDirectory(); Once we have default store, it will be used in all cases when ownership store lookup fails. So, we can just define our standalone BlogPost model. But wait. BlogPost have just one author, not many. Thus, we don't need Collection, which is subsetOf something. We need Model, taken from collection. const BlogPost = Model.extend({ attributes : { author : Model.from( '~users' ), created : Date, title : '', body : '' } }); let posts = new BlogPost.Collection(); posts.fetch(); Whenever we have default store populated with data, this post.author attribute will be indistinguishable from regular nested model attribute. But as with subsetOf, it's not an aggregation, but relation. So, there are some differences: Model.from is considered as changed (and throws 'change:attr' event) only in case its model is replaced. No nested model changes will trigger attribute change, and parent model change. When Model.from is deep cloned, it doesn't clone its element. You can assign model id to this attribute. It's serialized as just model ids. Pitfalls There is one problem, however, which you should be aware of. In case when role is being deleted from master collection, you will need to reconcile users collection, in order to remove extra users. So far, there are no built in mechanics for that, and an easiest way of doing this is just to fetch UsersDirectory from server again. Or (if it really important) you can do something like in the example below. const UsersDirectory = Model.extend({ attributes : { ... }, initialize(){ this.listenTo( this.roles, 'remove', role =&gt; { this.users.transaction( () =&gt; { \/\/ 'users' will trigger single 'changes' event for bulk operation this.users.each( user =&gt; user.roles.remove( role ) ); }); }); } }); Or ask us to add generic reconcile method. In older NestedTypes versions it was hard to do efficient enough to make generic implementation, and also its quite rare situation when you really need client-side reconcilation; that's why it's not done yet. But now we can.","tags":"","url":"Store\/Stores_and_relations_basics.html"},{"title":"Advanced stores","text":"Multiple stores Now let's imagine the situation that we have a lot of authors and posts, and we can't afford to load everything upfront. So we want to utilize paging. Still, we have an intention to pack users in JSON separately from the posts. We can do this using the same trick as we done for users and roles originally, no matter do we have default store or not. Lets just add one more store for our task. For this case, we will create the model for every page with posts. This model id will be the page id. const PostsPage = Store.extend({ attributes : { posts : BlogPost.Collection, users : User.Collection } }); Now, all ~users references from page.posts will use local page.users collection. But ~roles references from page.users will find no collection for roles, so what will happen? They will fall back to the default store we have defined above, and take roles from there. In nested types, you may have multiple stores at the same time, you can dynamically create them, and they plays together: Whenever closest parent lookup for the store fails, default store is taken. Stores can aggregate other stores. Whenever lookup for the resource in particular store fails... parent store is taken, and procedure continues; Modeling UI state with relations The fact that reference path is taken relative to model's this allows us to use local relations in scenarious wihout Stores, which are way simpler and more common than example discussed above. Most of these scenarious happens when you use NestedTypes not in data layer, but to model UI state. Which is very convinient due to deep changes detection feature, and invaluable in sutuations when you need to preserve UI state on browser refresh. It's hard to write about UI patterns in general, because different frameworks has different assumptions on what is UI state. So, the case of React is covered in the last section, and React is actually the recommended way of writing applications with NestedTypes. List of items with selection Suppose that we have a list of items in collection, which we need to display. And some items might be selected with a click. It could be done with DOM manipulation, and we can rely on the DOM as the primary source of information about selection. Which is extrimely bad practice. In case of any UI framework the code will be much cleaner if we would keep information about selection (and other information which is required to render the widget) as a part of the separately managed UI state. And here the situation our models and relations comes to help. First idea which comes to the mind is to add 'selected' attribute to the item's model. And again, it is bad idea no matter which framework you're using. In this case we would mix UI state with our data layer. Server and other part of our application have no interest in selection made in particular UI widget, so we need to keep it separate from the items collection. Thus, we introduce collection of selected items, which is, obviously, the subset of items collection, and put it along with items we wanna render: const State = Model.extend({ attributes : { items : Collection, selected : Collection.subsetOf( 'items' ) } }) Here, since master collection's path is taken relative to this, it will be this.items. And this spec gives reader quite precise information about the purpose of this selected. Then we can just subscribe for the changes of this model and update our UI on every change. Thanks to NestedTypes deep changes detection feature, whenever we will receive items from the server or anything will be changed deep inside of the models for any reason, our UI will be in sync. In case of Backbone View, it will look like this: initialize : function( options ){ this.model = new State( options ); this.listenTo( this.model, 'change', this.render ); } So, instead of DOM manipulation, now it's enough to add or remove corresponding item in selected collection in our click event handler. It has toggle method for that purpose, like selected.toggle( modelOrId ). And since selected collections knows which subset it is, it can easily handle toggle with model id taken from the DOM as an argument. onClick : function( e ){ const id = $( e.target ).attr( 'model-id' ); this.model.selected.toggle( id ); \/\/ will trigger state model change, which will trigger UI update } If just one item may be selected at a time, it will obviously be Model.from( 'items' ) instead of Collection.subsetOf. Adding persistence Now let's suppose that we need to preserve our selection in local storage when browser is refreshed. First idea is to take some Backbone plugin for working with localStorage, and try it on our model. As usual. Bad idea. This time - because it could be done trivially without plugins. Thanks to powerful NestedTypes serialization facilities, it's enough to convert our State model to JSON and save it as one piece. Lets do something quick and dirty to illustrate an idea. First, we need to teach our model to save to and be loaded from local storage. We suspect it won't be the single case, so we create the base class for that. const LocalStorage = Model.extend({ fetch(){ if( this.id ){ \/\/ take model id as key... const json = localStorage.getItem( this.id ); json &amp;&amp; ( this.set( JSON.parse( json ), { parse: true }) ); } }, save( attrs ){ attrs &amp;&amp; this.set( attrs ); this.id &amp;&amp; localStorage.setItem( this.id, JSON.stringify( this ) ); } }); Great. When it comes to the State model, we probably don't want to save items to local storage, because they are received from the server. Just selected. And thanks to subsetOf metatype, it will be serialized as an array of model ids, and it's exactly what we want. So... const State = LocalStorage.extend({ attributes : { id : 'My Very Specific Widget State Local Storage Key', items : Collection.has.toJSON( false ), selected : Collection.subsetOf( 'items' ) } }) Assuming that we will have just one instance of this widget on the screen, it's okay, so it would be enough to add something like this in widget's constructor: this.model.fetch(); window.onunload = () =&gt; this.model.save(); That's really quick and very dirty example (describen trick with local storage is really okay for the top level View only), but I think you got the general idea. For the React guys... ...this example would look a bit different. Because React handle state differently (and in much better way) than traditional MVC frameworks. And because we have special support for React (you're also warmly welcomed to see our complete React TodoMVC example). Here props will be translated to propTypes, state will lead to creation of the NestedTypes model to manage state (as you see both have the common type annotation style), Model specify the base class for the state model, and pureRender... Well, it's pure render, which you've probably been told of as an impossible optimization for mutable data. :) So now you know it was not true. In the context of our topic, you might wander what ^props.items reference means. ^ is the shortcut for getOwner() call, thus this reference will be translated to this.getOwner().props.items, which literally means the reference to the member of my component's props. Model can make direct references to its parents too, yes. I wouldn't recommend using them in other context, though. const QuickAndDirty = React.createClass({ props : { items : Collection }, pureRender : true, Model : LocalStorage, state : { id : 'My Very Specific Widget State Local Storage Key', selected : Collection.subsetOf( '^props.items' ) }, componentWillMount(){ this.state.fetch(); }, componentWillUnmount(){ this.state.save(); }, ... });","tags":"","url":"Store\/Advanced_stores.html"},{"title":"Events","text":"Both Record and Collection uses an efficient synchronous events implementation which is compatible with Backbone 1.1 Events API but is twice faster in average. It comes in form of Events mixin and the Messenger base class. An implementation is optimized for the large amount of relatively small subscriptions (5-10 events). Here are the benchmark results (lower is the better). It is also avaiable separately as part of MixtureJS package. Events mixin Events is a mixin, giving the object the ability to bind and trigger custom named events. Events do not have to be declared before they are bound, and may take passed arguments. eventsSource.trigger(event, [*args]) Trigger callbacks for the given event, or space-delimited list of events. Subsequent arguments to trigger will be passed along to the event callbacks. High-level listening API All high-level event subscriptions are stopped automatically on the listener's disposal, and thus does not introduce memory leaks. This is the preferable listening API and must be used in all application code. listener.listenTo(other, event, callback) Tell an object to listen to a particular event on an other object. The advantage of using this form, instead of other.on(event, callback, object), is that listenTo allows the object to keep track of the events, and they can be removed all at once later on. The callback will always be called with object as context. view.listenTo(model, 'change', view.render ); listener.stopListening([other], [event], [callback]) Tell an object to stop listening to events. Either call stopListening with no arguments to have the object remove all of its registered callbacks ... or be more precise by telling it to remove just the events it's listening to on a specific object, or a specific event, or just a specific callback. view.stopListening(); \/\/ Unsubscribe from all events view.stopListening(model); \/\/ Unsubscribe from all events from the model All Type-R classes execute this.stopListening() from their dispose() method. listener.listenToOnce(other, event, callback) Just like listenTo, but causes the bound callback to fire only once before being removed. Low-level listening API This API is more efficient but requires manual action to stop the subscribtion. Must be used with care. eventSource.on(event, callback, [context]) Bind a callback function to an object. The callback will be invoked whenever the event is fired. If you have a large number of different events on a page, the convention is to use colons to namespace them: &quot;poll:start&quot;, or &quot;change:selection&quot;. The event string may also be a space-delimited list of several events... book.on(&quot;change:title change:author&quot;, ...); Callbacks bound to the special &quot;all&quot; event will be triggered when any event occurs, and are passed the name of the event as the first argument. For example, to proxy all events from one object to another: proxy.on(&quot;all&quot;, function(eventName) { object.trigger(eventName); }); All event methods also support an event map syntax, as an alternative to positional arguments: book.on({ &quot;change:author&quot;: authorPane.update, &quot;change:title change:subtitle&quot;: titleView.update, &quot;destroy&quot;: bookView.remove }); To supply a context value for this when the callback is invoked, pass the optional last argument: model.on('change', this.render, this) or model.on({change: this.render}, this). eventSource.off([event], [callback], [context]) Remove a previously-bound callback function from an object. If no context is specified, all of the versions of the callback with different contexts will be removed. If no callback is specified, all callbacks for the event will be removed. If no event is specified, callbacks for all events will be removed. \/\/ Removes just the `onChange` callback. object.off(&quot;change&quot;, onChange); \/\/ Removes all &quot;change&quot; callbacks. object.off(&quot;change&quot;); \/\/ Removes the `onChange` callback for all events. object.off(null, onChange); \/\/ Removes all callbacks for `context` for all events. object.off(null, null, context); \/\/ Removes all callbacks on `object`. object.off(); Note that calling model.off(), for example, will indeed remove all events on the model \u00e2\u0080\u0094 including events that Backbone uses for internal bookkeeping. eventsSource.once(event, callback, [context]) Just like on, but causes the bound callback to fire only once before being removed. Handy for saying &quot;the next time that X happens, do this&quot;. When multiple events are passed in using the space separated syntax, the event will fire once for every event you passed in, not once for a combination of all events Messenger Messenger is an abstract base class implementing Events mixin and some convinience methods. readonly messenger.cid Unique run-time only messenger instance id (string). messenger.initialize() Callback which is called at the end of the constructor. messenger.dispose() Executes messenger.stopListening() and messenger.off(). Objects must be disposed to prevent memory leaks caused by subscribing for events from singletons. List of built-in events Record events event &quot;change:attrName&quot; (record, value, options) When a specific attribute has been updated event &quot;change&quot; (record, options) When a record's attributes have changed. Collection events event &quot;changes&quot; (collection, options) The main change event. Single event triggered when the collection has been changed. event &quot;update&quot; (collection, options) Single event triggered after any number of records have been added or removed from a collection. event &quot;reset&quot; (collection, options) When the collection's entire contents have been reset. event &quot;sort&quot; (collection, options) When the collection has been re-sorted. event &quot;add&quot; (record, collection, options) When a record is added to a collection. event &quot;remove&quot; (record, collection, options) When a record is removed from a collection. event &quot;change&quot; (record, options) When a record's attributes have changed.","tags":"","url":"Events.html"},{"title":"Mixins","text":"Both plain JS object and class constructor may be used as mixins. In the case of the class constructor, missing static members will copied over as well. decorator @mixins( mixinA, mixinB, ... ) class ... You need to import mixins decorator to use mixins: import { mixins } from 'type-r' ... @mixins( plainObject, MyClass, ... ) class X { ... } decorator @mixinRules({ name : rule, ... }) class ...` Define configurable properties merge rules for the specific class. Rules can be extented in any subclass. Mixin rules rule name : 'merge' Assume the property to be an object. Property values from mixins will be merged. rule name : { name1 : rule, ... } If merge rule is an object, the corresponding member is expected to be an object and the rule defines the merge rules for its members. rule name : 'pipe' Property is the function ( x : T ) =&gt; T transforming the value. Multiple functions joined in pipe. rule name : 'sequence' Property is the function. Multiple functions will be called in sequence. rule name : 'reverse' Same as sequence, but functions called in reverse sequence. rule name : 'mergeSequence' Merge the object returned by functions, executing them in sequence. rule name : 'every' Property is the function ( ...args : any[] ) =&gt; boolean. Resulting method will return true if every single function returns true. rule name : 'some' Same as every, but method will return true when at least one function returns true.","tags":"","url":"Mixins.html"}]}