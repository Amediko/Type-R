{"pages":[{"title":"Type-R","text":"Type-R is the universal state management JS framework designed to manage both UI and domain application state. Reactive and persistent state All data objects defined with Type-R are observable and serializable by default. Complex serialization scenarios like many-to-many relations are supported out of box. Declarative validation Validation checks are transparent and defined as a part of an attributes definition. Dynamically type-safe State elements are typed. It's guaranteed that state elements will retain declared types at run-time no matter what. Client-server communication is validated and guarded from type errors from both ends.","tags":"","url":"index.html"},{"title":"Getting Started","text":"","tags":"","url":"Getting_Started.html"},{"title":"Overview","text":"React-MVx is built around the idea of universal state management featuring the same technique to manage the local component state, application page state, and the global application state. Basic building blocks of the application architecture are: React-MVx Component (extended React.Component) for the view layer. Records and Collection (provided by Type-R data framework) for managing all kinds of an application state. Links for two-way data binding. Stores (which is the subclass of the Record and can be dynamically created) for resolving record's id-references. React-MVx Component uses the Record class to manage its local state. Record can consists of other records and collections, describing the data structure of arbitrary complexity. All records are serializable by default, has deeply observable changes, and supports the declarative validation. The behavior of record's attributes and component state\/props elements is controlled with declarative type annotations. React-MVx extends React namespace and should be used instead of react. All class Component definitions must be preceeded with the @define decorator. import React, { define } from 'react-mvx' @define class HelloApp extends React.Component { static state = { count : 0 }; render(){ const { state } = this; return ( &lt;h1 onClick={ () =&gt; state.count++ }&gt; Hi there! { state.count } &lt;\/h1&gt;; ); } }","tags":"","url":"Overview.html"},{"title":"Overview","text":"Record is the serializable class with typed attributes, observable changes, and custom validation checks. It is the main building block for managing the application state; component local state, stores, and collection elements are all subclasses of the Record. In contrast to the &quot;model&quot; class in the majority of data frameworks, Record is not the key-value hash. It's the class with statically defined set of attributes of known types. Record itself is an abstract class. The subclass needs to be defined for every data structure of different shape, in a similar way as it's done in statically typed languages. import { define, Record } from 'type-r' \/\/ \u00e2\u00a4\u00b9 required to make magic work @define class User extends Record { \/\/ \u00e2\u00a4\u00b9 attribute's declaration static attributes = { firstName : '', \/\/ \u00e2\u009f\u00b5 String type is inferred from the default value lastName : String, \/\/ \u00e2\u009f\u00b5 Or you can just mention its constructor email : String.value( null ), \/\/\u00e2\u009f\u00b5 Or you can provide both createdAt : Date, \/\/ \u00e2\u009f\u00b5 And it works for any constructor. \/\/ And you can attach \u00e2\u00a4\u00b9 metadata to fine-tune attribute's behavior lastLogin : Date.value( null ).has.toJSON( false ) \/\/ \u00e2\u009f\u00b5 not serializable } } const user = new User(); console.log( user.createdAt ); \/\/ \u00e2\u009f\u00b5 this is an instance of Date created for you. const users = new User.Collection(); \/\/ \u00e2\u009f\u00b5 Collections are defined automatically. users.on( 'changes', () =&gt; updateUI( users ) ); \/\/ \u00e2\u009f\u00b5 listen to the changes. users.set( json, { parse : true } ); \/\/ \u00e2\u009f\u00b5 parse raw JSON from the server. users.updateEach( user =&gt; user.firstName = '' ); \/\/ \u00e2\u009f\u00b5 bulk update triggering 'changes' once Declarations static attributes = { name : attrDef, ... } Record is a class with an observalbe and serializable public attributes. Attributes must be declared statically in static attributes class member, which is an object hash mapping an attribute name name to its declaration, encapsulating attribute type, default value, and metadata controlling different aspects of attribute behavior. @define class User extends Record { static attributes = { name : String.value( 'John Dow' ), email : 'john.dow@mail.com', \/\/ Same as String.value( 'john.dow@mail.com' ) address : String, \/\/ Same as String.value( '' ) } } The Record guarantee that every attribute will always hold the value of the declared type. Whenever the an attribute is being assigned with the value which is not compatible with its declared type, the type is being converted with an invocation of the constructor: new Type( value ) (primitive types are treated specially). Attribute definitions attrDef name : Type.value( defaultValue ) The general form of type annotation is Type.value( defaultValue ), where the Type is the corresponding constructor function. attrDef name : Type When the function is used as attrDef, it's treated as the constructor function. Any constructor function may be used as an attribute type, if it behaves as converting constructor (like new Date( msecs )). attrDef name : defaultValue When other value than function is passed, it's treated as the default value and the type is being inferred form the value. If you need to pass function as the default value, use Function.value( theFunction ). Class methods constructor( attrs?, options? ) When creating an instance of a record, you can pass in the initial values of the attributes, which will be set on the record. If {parse: true} is passed as an option, the attributes will first be converted by record's and attribute-level parse() before being set on the record. @define class Book extends Record { static attributes = { title : '', author : '' } } const book = new Book({ title: &quot;One Thousand and One Nights&quot;, author: &quot;Scheherazade&quot; }); record.initialize( attrs?, options? ) Called at the end of the Record constructor when all attributes are assigned and record's inner state is properly initialized. Takes the same arguments as a constructor. record.attrName Record's attributes may be directly accessed with record.name, as if they would be the members of the class. Please note, that you have to declare all attributes in static attributes declaration before use. @define class Account extends Record { static attributes = { name : String, ballance : Number } } const myAccount = new Account({ name : 'mine' }); myAccount.ballance += 1000000; \/\/ That works. Good, eh? record.set() Set a hash of attributes (one or many) on the record. If any of the attributes change the record's state, a change event will be triggered on the record. Change events for specific attributes are also triggered, and you can bind to those as well, for example: change:title, and change:content. @define class Note extends Record { static attributes = { title : '', content : '' } } const note = new Note(); note.set({title: &quot;March 20&quot;, content: &quot;In his eyes she eclipses...&quot;}); note.title = &quot;A Scandal in Bohemia&quot;; set() takes the standard set of transactional options.","tags":"","url":"Record\/Overview.html"},{"title":"Record basics","text":"Declarations static attributes = { name : attrDef, ... } Record is a class with an observalbe and serializable public attributes. Attributes must be declared statically in static attributes class member, which is an object hash mapping an attribute name name to its declaration, encapsulating attribute type, default value, and metadata controlling different aspects of attribute behavior. @define class User extends Record { static attributes = { name : String.value( 'John Dow' ), email : 'john.dow@mail.com', \/\/ Same as String.value( 'john.dow@mail.com' ) address : String, \/\/ Same as String.value( '' ) } } The Record guarantee that every attribute will always hold the value of the declared type. Whenever the an attribute is being assigned with the value which is not compatible with its declared type, the type is being converted with an invocation of the constructor: new Type( value ) (primitive types are treated specially). Attribute definitions attrDef name : Type.value( defaultValue ) The general form of type annotation is Type.value( defaultValue ), where the Type is the corresponding constructor function. attrDef name : Type When the function is used as attrDef, it's treated as the constructor function. Any constructor function may be used as an attribute type, if it behaves as converting constructor (like new Date( msecs )). attrDef name : defaultValue When other value than function is passed, it's treated as the default value and the type is being inferred form the value. If you need to pass function as the default value, use Function.value( theFunction ). Class methods constructor( attrs?, options? ) When creating an instance of a record, you can pass in the initial values of the attributes, which will be set on the record. If {parse: true} is passed as an option, the attributes will first be converted by record's and attribute-level parse() before being set on the record. @define class Book extends Record { static attributes = { title : '', author : '' } } const book = new Book({ title: &quot;One Thousand and One Nights&quot;, author: &quot;Scheherazade&quot; }); record.initialize( attrs?, options? ) Called at the end of the Record constructor when all attributes are assigned and record's inner state is properly initialized. Takes the same arguments as a constructor. record.attrName Record's attributes may be directly accessed with record.name, as if they would be the members of the class. Please note, that you have to declare all attributes in static attributes declaration before use. @define class Account extends Record { static attributes = { name : String, ballance : Number } } const myAccount = new Account({ name : 'mine' }); myAccount.ballance += 1000000; \/\/ That works. Good, eh? record.set() Set a hash of attributes (one or many) on the record. If any of the attributes change the record's state, a change event will be triggered on the record. Change events for specific attributes are also triggered, and you can bind to those as well, for example: change:title, and change:content. @define class Note extends Record { static attributes = { title : '', content : '' } } const note = new Note(); note.set({title: &quot;March 20&quot;, content: &quot;In his eyes she eclipses...&quot;}); note.title = &quot;A Scandal in Bohemia&quot;; set() takes the standard set of transactional options.","tags":"","url":"Record\/Record_basics.html"},{"title":"Aggregation tree","text":"Records can have attributes holding other Records and Collections, forming indefinitely nested data structures of arbitrary complexity. To create nested record or collection you should just mention its type in attribute's type annotation. import { Record } from 'type-r' @define class User extends Record { static attributes = { name : String, email : String, isActive : true } } @define class UsersListState extends Record { static attributes = { users : User.Collection } } All nested records and collections are aggregated by default and behave as integral parts of the containing record. Aggregated attributes are exclusively owned by the record, and taken with it together form an ownerhip tree. Many operations are performed recursively on aggregated elements: They are created when the owner record is created. They are cloned when the record is cloned. They are disposed when the record is disposed. They are validated as part of the record. They are serialized as nested JSON. Declarations attrDef attr : Type.shared Attributes can be marked as shared with adding Type.shared modifier. Such an attribute is not the member of record's aggregation\/ownership tree. It's initialized with null It's not cloned when the record is cloned (just the reference is copied over). It's not disposed when the record is disposed. It's not validated as part of the record (always valid by default) It's excluded from serialization. @define class UsersListState extends Record { static attributes = { users : User.Collection, selected : User.shared \/\/ can be assigned with the user from this.users } } Class methods record.getOwner() Return the reference to the record's owner, or null if record is not the part of aggregation tree. Due to the nature of aggregation, record may have one and only one owner. record.clone() Clone the record and all aggregated records and collections. The whole aggregation tree will be recursively cloned, references to shared members will copied. record.assignFrom( otherRecord ) Recursively assign the record and its aggregated members with values from otherRecord. This operation is similar to record.clone(), but instead of creation of the cloned record it makes an existing record to be the copy of other record. The whole aggregation tree will be recursively assigned, references to shared members will copied. record.dispose() Recursively dispose the record and its aggregated members. &quot;Dispose&quot; means that elements of the aggregation tree will unsubscribe from all event sources. It's crucial to prevent memory leaks in SPA. The whole aggregation tree will be recursively disposed, shared members won't.","tags":"","url":"Record\/Aggregation_tree.html"},{"title":"Transactions and Events","text":"How record updates are processed Record changes occure in the scope of transactions. Record triggers the set of events during the transaction. Transaction is executed in three steps. Apply all the changes to the record and nested records and collections. Send change:[attribute] (record, value, options) events for each attribute which has been updated (including nested objects). If any of the model's attributes have changed: Send change (record, options) event. Notify record's owner on changes. So, the statement like user.name = 'Joe' will trigger two events: change:attr and the subsequent change. Statement user.set({ name : 'Joe', email : 'joe@mail.com' }) will (assuming that both attributes was changed) execute like this: New name and email values will be applied to the user. change:name and change:user events will be sent out. change event will be sent out. Any additional changes that may be applied to the record in change:[attribute] and change event handlers will be executed in the scope of the original transaction. It means, that: No additional change events will be triggered if you modify the record in change:[attribute] event handler (but new change:[attribute] events will). If the record will be modified in change event handler, there will be additional change events. However, record's owner will be notifyed only once when the wave of events and reactions will finish its processing. record.transaction( fun ) Execute the sequence of updates in fun function in the scope of the transaction, so it will trigger the single change event. Transactions are superior to record.set() in terms of both performance and flexibility. some.record.transaction( record =&gt; { record.a = 1; \/\/ `change:a` is triggered. record.b = 2; \/\/ `change:b` is triggered. }); \/\/ `change` is triggered. Listening to change events attrDef attr : Type.has.watcher( 'methodName' ) attrDef attr : Type.has.watcher( function( value, name ){ ... } ) To attach some custom reaction on specific record's attribute change event, you attach the watcher function to this attribute. Watcher has the signature ( attrValue, attrName ) =&gt; void and is executed in the context of the record. Watcher internally listens to change:attr event which is triggered during the step 2. Therefore, no additional change events will be triggered. In the example below, any change of the name attribute will result in the subsequent update of the isAdmin attribute, and the singlechange event is triggered. @define class User extends Record { static attributes = { name : String.has.watcher( 'onNameChange' ), isAdmin : Boolean, } onNameChange(){ \/\/ Cruel. But we need it for the purpose of the example. this.isAdmin = this.name.indexOf( 'Admin' ) &gt;= 0; } } Events API TODO Class methods Following API might be useful in change event listeners. record.changed The changed property is the internal hash containing all the attributes that have changed during its last transaction. Please do not update changed directly since its state is internally maintained by set(). A copy of changed can be acquired from changedAttributes(). record.changedAttributes( attrs? ) Retrieve a hash of only the record's attributes that have changed during the last transaction, or false if there are none. Optionally, an external attributes hash can be passed in, returning the attributes in that hash which differ from the record. This can be used to figure out which portions of a view should be updated, or what calls need to be made to sync the changes to the server. record.previous( attr ) During a &quot;change&quot; event, this method can be used to get the previous value of a changed attribute. @define class Person extends Record{ static attributes = { name: '' } } const bill = new Person({ name: &quot;Bill Smith&quot; }); bill.on(&quot;change:name&quot;, ( record, name ) =&gt; { alert( `Changed name from ${ bill.previous('name') } to ${ name }`); }); bill.name = &quot;Bill Jones&quot;; record.previousAttributes() Return a copy of the record's previous attributes. Useful for getting a diff between versions of a record, or getting back to a valid state after an error occurs.","tags":"","url":"Record\/Transactions_and_Events.html"},{"title":"Validation","text":"Declarations attrDef attr : Type.has.check( predicate, errorMsg? ) Attribute-level validator. predicate : value =&gt; boolean is the function taking attribute's value and returning true whenever the value is valid. optional errorMsg is the error message which will be passed in case if the validation fail. If errorMsg is omitted, error message will be taken from predicate.error. It makes possible to define reusable validation functions. function isAge( years ){ return years &gt;= 0 &amp;&amp; years &lt; 200; } isAge.error = &quot;Age must be between 0 and 200&quot;; Attribute may have any number of checks attached, which are execute in sequence. Validation stops when first check in sequence fails. \/\/ Define new attribute metatype encapsulating validation checks. const Age = Number.has .check( x =&gt; x &gt;= 0, 'I guess you are a bit older' ) .check( x =&gt; x &lt; 200, 'No way man can be that old' ); attrDef attr : Type.isRequired The special case of attribute-level check cutting out empty values. Attribute value must be truthy to pass, &quot;Required&quot; is used as validation error. isRequired is the first validator to check, no matter in which order validators were attached. Class members record.validate() Override in Record subclass to add record-level validation. Whatever is returned is treated as an error message. record.isValid() Returns true whenever the record is valid. The whole aggregation tree is validated. record.isValid( attrName ) Returns true whenever the record's attribute is valid. record.validationError Detailed validation error information, or null if the record and its aggregation tree is valid. An error object has tree structure mapping the invalid subtree of the aggregation tree. \/\/ ValidationError object shape { error : \/* record-level validation error msg as returned from record.validate() *\/, \/\/ Attribute-level validation errors, one entry for each invalid attribute. nested : { \/\/ Contains nested ValidationError object for nested records and collections... nestedRecord : \/* ValidationError *\/ nestedCollection : \/* ValidationError *\/ \/\/ ...and error msg for all other attributes. otherAttr : \/* attribute validation error as returned from .has.check() validator *\/ } } Validation error traversal ValidationError has a couple of methods for tree traversal. validationError.each( ( error, key ) =&gt; void ) Iterate through the records's errors (not recursive). key is null for the record-level validation error. validationError.eachError( ( error, key, recordOrCollection ) =&gt; void ) Recursively traverse aggregation tree errors. key is null for the record-level validation error. recordOrCollection is the reference to the current object.","tags":"","url":"Record\/Validation.html"},{"title":"Serialization","text":"Declarations attrDef attr : Type.has.toJSON( false ) Exclude attribute from serialization. attrDef attr : Type.has.toJSON( ( value, name ) =&gt; json ) Override the default toJSON() method for the selected record's attribute. attrDef attr : Type.has.parse() Transform the data before it will be passed to the record's attribute when { parse : true } option is used. Class members record.parse( json ) May be overriden to transform constructor or set argument when { parse : true } option is used. constructor( json, { parse : true } ) Call record.parse( json ) and attribute-level parse transforms. They won't be executed by default. record.set( json, { parse : true } ) Call record.parse( json ) and attribute-level parse transforms. They won't be executed by default. record.toJSON() Create record's JSON representation. This can be used for persistence, serialization, or for augmentation before being sent to the server. The name of this method is a bit confusing, as it doesn't actually return a JSON string \u00e2\u0080\u0094 but I'm afraid that it's the way that the JavaScript API for JSON.stringify works. @define class Artist extends Record { static attributes = { firstName: String, lastName: String, birthday : Date, code : String.has.toJSON( x =&gt; x.toLowerCase() ) } } const artist = new Artist({ firstName: &quot;Wassily&quot;, lastName: &quot;Kandinsky&quot; }); artist.birthday = new Date( 1866, 12, 16 ); alert( JSON.stringify( artist ) ); It will, however, produce correct JSON for all the complex attribute types.","tags":"","url":"Record\/Serialization.html"},{"title":"id  and id-references","text":"Record's id record.id Predefined record's attribute, the id is an arbitrary string (integer id or UUID). id is typically generated by the server. It is used in JSON for id-references. Records can be retrieved by id from collections, and there can be just one instance of the record with the same id in the particular collection. static idAttribute = 'attrName' A record's unique identifier is stored under the id attribute. If you're directly communicating with a backend (CouchDB, MongoDB) that uses a different unique key, you may set a Record's idAttribute to transparently map from that key to id. Record's id property will still be linked to Record's id, no matter which value idAttribute has. @define class Meal extends Record { static idAttribute = &quot;_id&quot;; static attributes = { _id : Number, name : '' } } const cake = new Meal({ _id: 1, name: &quot;Cake&quot; }); alert(&quot;Cake id: &quot; + cake.id); record.isNew() Has this record been saved to the server yet? If the record does not yet have an id, it is considered to be new. id-references Serializable references to shared records are called an id-references. It is represented as record.id in JSON, and there must be the populated master collection of records on the client in order to resolve ids on parse. There are two kinds of id-references: one-to-many, and many-to-many. They are declared with the special kind of attribute annotation. Id-references behaves in the same way as shared attributes, but inner changes in referenced objects are not observed. attrDef attr : Record.from( sourceCollection ) Declare an attribute to be the record from the particular collection. Serialized as record.id. attrDef attr : Collection.subsetOf( sourceCollection ) Declare an attribute to be the collection, which is the subset of the particular collection. Serialized as an array of record ids. Relative paths to source collection sourceCollection can be the string with the dot-separated relative object path to the collection. In this case, it is resolved dynamically relative to the record's this. @define class State extends Record { items : Item.Collection, selected : Record.from( 'items' ) \/\/ Will resolve to `this.items` }","tags":"","url":"Record\/id_ and_id-references.html"}]}