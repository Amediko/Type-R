{"pages":[{"title":"Type-R","text":"Type-R is the universal state management JS framework designed to manage both UI and domain application state. Reactive and persistent state All data objects defined with Type-R are observable and serializable by default. Complex serialization scenarios like many-to-many relations are supported out of box. Declarative validation Validation checks are transparent and defined as a part of an attributes definition. Dynamically type-safe State elements are typed. It's guaranteed that state elements will retain declared types at run-time no matter what. Client-server communication is validated and guarded from type errors from both ends.","tags":"","url":"index.html"},{"title":"Getting Started","text":"","tags":"","url":"Getting_Started.html"},{"title":"Overview","text":"React-MVx is built around the idea of universal state management featuring the same technique to manage the local component state, application page state, and the global application state. Basic building blocks of the application architecture are: React-MVx Component (extended React.Component) for the view layer. Records and Collection (provided by Type-R data framework) for managing all kinds of an application state. Links for two-way data binding. Stores (which is the subclass of the Record and can be dynamically created) for resolving record's id-references. React-MVx Component uses the Record class to manage its local state. Record can consists of other records and collections, describing the data structure of arbitrary complexity. All records are serializable by default, has deeply observable changes, and supports the declarative validation. The behavior of record's attributes and component state\/props elements is controlled with declarative type annotations. React-MVx extends React namespace and should be used instead of react. All class Component definitions must be preceeded with the @define decorator. import React, { define } from 'react-mvx' @define class HelloApp extends React.Component { static state = { count : 0 }; render(){ const { state } = this; return ( &lt;h1 onClick={ () =&gt; state.count++ }&gt; Hi there! { state.count } &lt;\/h1&gt;; ); } }","tags":"","url":"Overview.html"},{"title":"Overview","text":"node.cid Auto-generated unique local string id. node.initialize() Callback which is called at the end of the constructor. Accepts the same arguments as the constructor.","tags":"","url":"General_concepts\/Overview.html"},{"title":"Aggregation tree","text":"node.getOwner() Get an immediate owner. node.clone() Clone the aggregation tree. node.assignFrom( otherNode ) Synchronize the state of the aggregation tree with another tree. node.dispose() Dispose the aggregation tree.","tags":"","url":"General_concepts\/Aggregation_tree.html"},{"title":"Updates and change events","text":"node.set( values, options? ) node.transaction( fun : ( self : this ) =&gt; void, options : TransactionOptions = {} ) : void{ Change events There are different change events for different types of nodes in aggregation tree. node.onChanges( handler, context? ) node.offChanges( handler?, context? ) node.listenToChanges( source, handler ) Generic Events API Aggregation tree node implements Events API. eventsSource.trigger(event, [*args]) eventSource.on(event, callback, [context]) eventSource.off([event], [callback], [context]) eventsSource.once(event, callback, [context]) eventsSource.listenTo(other, event, callback) eventsSource.stopListening([other], [event], [callback]) eventsSource.listenToOnce(other, event, callback)","tags":"","url":"General_concepts\/Updates_and_change_events.html"},{"title":"Serialization","text":"node.parse( data : any, options? : TransactionOptions ) : any { return data } node.toJSON() : {}","tags":"","url":"General_concepts\/Serialization.html"},{"title":"Validation","text":"node.validationError() : ValidationError { node.validate( obj? : Transactional ) : any {} node.getValidationError( key : string ) : any { node.eachValidationError( iteratee : ( error : any, key : string, object : Transactional ) =&gt; void ) : void { node.isValid( key : string ) : boolean {","tags":"","url":"General_concepts\/Validation.html"},{"title":"Overview","text":"Record is the serializable class with typed attributes, observable changes, and custom validation checks. It is the main building block for managing the application state; component local state, stores, and collection elements are all subclasses of the Record. In contrast to the &quot;model&quot; class in the majority of data frameworks, Record is not the key-value hash. It's the class with statically defined set of attributes of known types. Record itself is an abstract class. The subclass needs to be defined for every data structure of different shape, in a similar way as it's done in statically typed languages. import { define, Record } from 'type-r' \/\/ \u00e2\u00a4\u00b9 required to make magic work @define class User extends Record { \/\/ \u00e2\u00a4\u00b9 attribute's declaration static attributes = { firstName : '', \/\/ \u00e2\u009f\u00b5 String type is inferred from the default value lastName : String, \/\/ \u00e2\u009f\u00b5 Or you can just mention its constructor email : String.value( null ), \/\/\u00e2\u009f\u00b5 Or you can provide both createdAt : Date, \/\/ \u00e2\u009f\u00b5 And it works for any constructor. \/\/ And you can attach \u00e2\u00a4\u00b9 metadata to fine-tune attribute's behavior lastLogin : Date.value( null ).has.toJSON( false ) \/\/ \u00e2\u009f\u00b5 not serializable } } const user = new User(); console.log( user.createdAt ); \/\/ \u00e2\u009f\u00b5 this is an instance of Date created for you. const users = new User.Collection(); \/\/ \u00e2\u009f\u00b5 Collections are defined automatically. users.on( 'changes', () =&gt; updateUI( users ) ); \/\/ \u00e2\u009f\u00b5 listen to the changes. users.set( json, { parse : true } ); \/\/ \u00e2\u009f\u00b5 parse raw JSON from the server. users.updateEach( user =&gt; user.firstName = '' ); \/\/ \u00e2\u009f\u00b5 bulk update triggering 'changes' once Declarations static attributes = { name : attrDef, ... } Record is a class with an observalbe and serializable public attributes. Attributes must be declared statically in static attributes class member, which is an object hash mapping an attribute name name to its declaration, encapsulating attribute type, default value, and metadata controlling different aspects of attribute behavior. @define class User extends Record { static attributes = { name : String.value( 'John Dow' ), email : 'john.dow@mail.com', \/\/ Same as String.value( 'john.dow@mail.com' ) address : String, \/\/ Same as String.value( '' ) } } The Record guarantee that every attribute will always hold the value of the declared type. Whenever the an attribute is being assigned with the value which is not compatible with its declared type, the type is being converted with an invocation of the constructor: new Type( value ) (primitive types are treated specially). Attribute definitions attrDef name : Type.value( defaultValue ) The general form of type annotation is Type.value( defaultValue ), where the Type is the corresponding constructor function. attrDef name : Type When the function is used as attrDef, it's treated as the constructor function. Any constructor function may be used as an attribute type, if it behaves as converting constructor (like new Date( msecs )). attrDef name : defaultValue When other value than function is passed, it's treated as the default value and the type is being inferred form the value. If you need to pass function as the default value, use Function.value( theFunction ). Class methods constructor( attrs?, options? ) When creating an instance of a record, you can pass in the initial values of the attributes, which will be set on the record. If {parse: true} is passed as an option, the attributes will first be converted by record's and attribute-level parse() before being set on the record. @define class Book extends Record { static attributes = { title : '', author : '' } } const book = new Book({ title: &quot;One Thousand and One Nights&quot;, author: &quot;Scheherazade&quot; }); record.initialize( attrs?, options? ) Called at the end of the Record constructor when all attributes are assigned and record's inner state is properly initialized. Takes the same arguments as a constructor. record.attrName Record's attributes may be directly accessed with record.name, as if they would be the members of the class. Please note, that you have to declare all attributes in static attributes declaration before use. @define class Account extends Record { static attributes = { name : String, ballance : Number } } const myAccount = new Account({ name : 'mine' }); myAccount.ballance += 1000000; \/\/ That works. Good, eh? record.set() Set a hash of attributes (one or many) on the record. If any of the attributes change the record's state, a change event will be triggered on the record. Change events for specific attributes are also triggered, and you can bind to those as well, for example: change:title, and change:content. @define class Note extends Record { static attributes = { title : '', content : '' } } const note = new Note(); note.set({title: &quot;March 20&quot;, content: &quot;In his eyes she eclipses...&quot;}); note.title = &quot;A Scandal in Bohemia&quot;; set() takes the standard set of transactional options.","tags":"","url":"Record\/Overview.html"},{"title":"Aggregation tree","text":"Records can have attributes holding other Records and Collections, forming indefinitely nested data structures of arbitrary complexity. To create nested record or collection you should just mention its type in attribute's type annotation. import { Record } from 'type-r' @define class User extends Record { static attributes = { name : String, email : String, isActive : true } } @define class UsersListState extends Record { static attributes = { users : User.Collection } } All nested records and collections are aggregated by default and behave as integral parts of the containing record. Aggregated attributes are exclusively owned by the record, and taken with it together form an ownerhip tree. Many operations are performed recursively on aggregated elements: They are created when the owner record is created. They are cloned when the record is cloned. They are disposed when the record is disposed. They are validated as part of the record. They are serialized as nested JSON. Declarations attrDef attr : Type.shared Attributes can be marked as shared with adding Type.shared modifier. Such an attribute is not the member of record's aggregation\/ownership tree. It's initialized with null It's not cloned when the record is cloned (just the reference is copied over). It's not disposed when the record is disposed. It's not validated as part of the record (always valid by default) It's excluded from serialization. @define class UsersListState extends Record { static attributes = { users : User.Collection, selected : User.shared \/\/ can be assigned with the user from this.users } } Class methods record.getOwner() Return the reference to the record's owner, or null if record is not the part of aggregation tree. Due to the nature of aggregation, record may have one and only one owner. record.clone() Clone the record and all aggregated records and collections. The whole aggregation tree will be recursively cloned, references to shared members will copied. record.assignFrom( otherRecord ) Recursively assign the record and its aggregated members with values from otherRecord. This operation is similar to record.clone(), but instead of creation of the cloned record it makes an existing record to be the copy of other record. The whole aggregation tree will be recursively assigned, references to shared members will copied. record.dispose() Recursively dispose the record and its aggregated members. &quot;Dispose&quot; means that elements of the aggregation tree will unsubscribe from all event sources. It's crucial to prevent memory leaks in SPA. The whole aggregation tree will be recursively disposed, shared members won't.","tags":"","url":"Record\/Aggregation_tree.html"},{"title":"Updates and change events","text":"Update record attributes record.attrName = val Assign record attribute. Assign new attribute value. If value has changed, trigger change:attrName ( record, value ) event. trigger change ( record ) event. record.set( { attrName : val, ... }, options? : options ) Bulk assign record's attributes, possibly taking options. Assign new attribut values. For any changed attribute, trigger change:attrName ( record, val, options ) event. If any attribute has changed: trigger change (record, options) event. options { parse : true } Transform record.set argument with user-defined parse logic. Typically used to process the responce from the server to make user-defined JSON format conversion. options { merge : true } Merge attributes of record and collection types instead of replacement. If the new instance of record or collection is to be assigned, update the current instances instead. record.assignFrom( otherRecord ) Makes the record to be the copy of otherRecord, recursively assigning all attributes. Works similar to `record.set( otherRecord.attributes, { merge : true }); Listening to events Deep changes observation Records automatically listens to change events of nested records and collections, and triggers the corresponding change events on its attributes. It means that the single attribute change deeply inside of aggregation tree will trigger change events on all the parents in a sequence. attrDef attr : Type.has.changeEvents( false ) Do not listen for the inner changes of the attr. Custom attribute change watchers Declaratively attach the watcher in attribute definition. Subscription will be managed automatically. attrDef attr : Type.has.watcher( 'methodName' ) attrDef attr : Type.has.watcher( function( value, name ){ ... } ) Attach change:attr event listener to the particular record's attribute. Watcher function has the signature ( attrValue, attrName ) =&gt; void and is executed in the context of the record. @define class User extends Record { static attributes = { name : String.has.watcher( 'onNameChange' ), isAdmin : Boolean, } onNameChange(){ \/\/ Cruel. But we need it for the purpose of the example. this.isAdmin = this.name.indexOf( 'Admin' ) &gt;= 0; } } Custom events subscribtion. listener.listenTo() and listener.listenToOnce() methods can be used to listen to the any of the change events. If listener itself is the record or collection, subscribtions will be stopped automatically. Otherwise they must be stopped manually with listener.stopListening() call to prevent memory leaks. Transactions All record updates occures in the scope of transactions. Transaction is the sequence of changes which results in a single change event. Transaction can be opened either manually or implicitly with calling set() or assigning an attribute. Any additional changes made to the record in change:attr event handler will be executed in the scope of the original transaction, and won't trigger additional change events. record.transaction( fun ) Execute the all changes made to the record in fun as single transaction. some.record.transaction( record =&gt; { record.a = 1; \/\/ `change:a` is triggered. record.b = 2; \/\/ `change:b` is triggered. }); \/\/ `change` is triggered. Manual transactions with attribute assignments are superior to record.set() in terms of both performance and flexibility. Change inspection methods Following API might be useful in change event listeners. record.changed The changed property is the internal hash containing all the attributes that have changed during its last transaction. Please do not update changed directly since its state is internally maintained by set(). A copy of changed can be acquired from changedAttributes(). record.changedAttributes( attrs? ) Retrieve a hash of only the record's attributes that have changed during the last transaction, or false if there are none. Optionally, an external attributes hash can be passed in, returning the attributes in that hash which differ from the record. This can be used to figure out which portions of a view should be updated, or what calls need to be made to sync the changes to the server. record.previous( attr ) During a &quot;change&quot; event, this method can be used to get the previous value of a changed attribute. @define class Person extends Record{ static attributes = { name: '' } } const bill = new Person({ name: &quot;Bill Smith&quot; }); bill.on(&quot;change:name&quot;, ( record, name ) =&gt; { alert( `Changed name from ${ bill.previous('name') } to ${ name }`); }); bill.name = &quot;Bill Jones&quot;; record.previousAttributes() Return a copy of the record's previous attributes. Useful for getting a diff between versions of a record, or getting back to a valid state after an error occurs.","tags":"","url":"Record\/Updates_and_change_events.html"},{"title":"Validation","text":"Declarations attrDef attr : Type.has.check( predicate, errorMsg? ) Attribute-level validator. predicate : value =&gt; boolean is the function taking attribute's value and returning true whenever the value is valid. optional errorMsg is the error message which will be passed in case if the validation fail. If errorMsg is omitted, error message will be taken from predicate.error. It makes possible to define reusable validation functions. function isAge( years ){ return years &gt;= 0 &amp;&amp; years &lt; 200; } isAge.error = &quot;Age must be between 0 and 200&quot;; Attribute may have any number of checks attached, which are execute in sequence. Validation stops when first check in sequence fails. \/\/ Define new attribute metatype encapsulating validation checks. const Age = Number.has .check( x =&gt; x &gt;= 0, 'I guess you are a bit older' ) .check( x =&gt; x &lt; 200, 'No way man can be that old' ); attrDef attr : Type.isRequired The special case of attribute-level check cutting out empty values. Attribute value must be truthy to pass, &quot;Required&quot; is used as validation error. isRequired is the first validator to check, no matter in which order validators were attached. Class members record.validate() Override in Record subclass to add record-level validation. Whatever is returned is treated as an error message. record.isValid() Returns true whenever the record is valid. The whole aggregation tree is validated. record.isValid( attrName ) Returns true whenever the record's attribute is valid. record.validationError Detailed validation error information, or null if the record and its aggregation tree is valid. An error object has tree structure mapping the invalid subtree of the aggregation tree. \/\/ ValidationError object shape { error : \/* record-level validation error msg as returned from record.validate() *\/, \/\/ Attribute-level validation errors, one entry for each invalid attribute. nested : { \/\/ Contains nested ValidationError object for nested records and collections... nestedRecord : \/* ValidationError *\/ nestedCollection : \/* ValidationError *\/ \/\/ ...and error msg for all other attributes. otherAttr : \/* attribute validation error as returned from .has.check() validator *\/ } } Validation error traversal ValidationError has a couple of methods for tree traversal. validationError.each( ( error, key ) =&gt; void ) Iterate through the records's errors (not recursive). key is null for the record-level validation error. validationError.eachError( ( error, key, recordOrCollection ) =&gt; void ) Recursively traverse aggregation tree errors. key is null for the record-level validation error. recordOrCollection is the reference to the current object.","tags":"","url":"Record\/Validation.html"},{"title":"Serialization","text":"Declarations attrDef attr : Type.has.toJSON( false ) Exclude attribute from serialization. attrDef attr : Type.has.toJSON( ( value, name ) =&gt; json ) Override the default toJSON() method for the selected record's attribute. attrDef attr : Type.has.parse() Transform the data before it will be passed to the record's attribute when { parse : true } option is used. Class members record.parse( json ) May be overriden to transform constructor or set argument when { parse : true } option is used. constructor( json, { parse : true } ) Call record.parse( json ) and attribute-level parse transforms. They won't be executed by default. record.set( json, { parse : true } ) Call record.parse( json ) and attribute-level parse transforms. They won't be executed by default. record.toJSON() Create record's JSON representation. This can be used for persistence, serialization, or for augmentation before being sent to the server. The name of this method is a bit confusing, as it doesn't actually return a JSON string \u00e2\u0080\u0094 but I'm afraid that it's the way that the JavaScript API for JSON.stringify works. @define class Artist extends Record { static attributes = { firstName: String, lastName: String, birthday : Date, code : String.has.toJSON( x =&gt; x.toLowerCase() ) } } const artist = new Artist({ firstName: &quot;Wassily&quot;, lastName: &quot;Kandinsky&quot; }); artist.birthday = new Date( 1866, 12, 16 ); alert( JSON.stringify( artist ) ); It will, however, produce correct JSON for all the complex attribute types.","tags":"","url":"Record\/Serialization.html"},{"title":"id  and id-references","text":"Record's id record.id Predefined record's attribute, the id is an arbitrary string (integer id or UUID). id is typically generated by the server. It is used in JSON for id-references. Records can be retrieved by id from collections, and there can be just one instance of the record with the same id in the particular collection. static idAttribute = 'attrName' A record's unique identifier is stored under the id attribute. If you're directly communicating with a backend (CouchDB, MongoDB) that uses a different unique key, you may set a Record's idAttribute to transparently map from that key to id. Record's id property will still be linked to Record's id, no matter which value idAttribute has. @define class Meal extends Record { static idAttribute = &quot;_id&quot;; static attributes = { _id : Number, name : '' } } const cake = new Meal({ _id: 1, name: &quot;Cake&quot; }); alert(&quot;Cake id: &quot; + cake.id); record.isNew() Has this record been saved to the server yet? If the record does not yet have an id, it is considered to be new. id-references Serializable references to shared records are called an id-references. It is represented as record.id in JSON, and there must be the populated master collection of records on the client in order to resolve ids on parse. There are two kinds of id-references: one-to-many, and many-to-many. They are declared with the special kind of attribute annotation. Id-references behaves in the same way as shared attributes, but inner changes in referenced objects are not observed. attrDef attr : Record.from( sourceCollection ) Declare an attribute to be the record from the particular collection. Serialized as record.id. attrDef attr : Collection.subsetOf( sourceCollection ) Declare an attribute to be the collection, which is the subset of the particular collection. Serialized as an array of record ids. Relative paths to source collection sourceCollection can be the string with the dot-separated relative object path to the collection. In this case, it is resolved dynamically relative to the record's this. @define class State extends Record { items : Item.Collection, selected : Record.from( 'items' ) \/\/ Will resolve to `this.items` }","tags":"","url":"Record\/id_ and_id-references.html"},{"title":"Overview","text":"Collections are ordered sets of records. You can bind &quot;change&quot; events to be notified when any record in the collection has been modified, listen for &quot;add&quot; and &quot;remove&quot; events, fetch the collection from the server, and use a full suite of Underscore.js methods. Collection is implicitly defined for every record with a constructor accessible as MyRecord.Collection. In most cases, you don't need to declare it manually. \/\/ Implicitly defined collection. const books = new Book.Collection(); @define class ComicsShelve extends Book.Collection { static itemEvents = { \/\/ List of records's events we want to be triggered on the collection 'change:inMyReadingList' : true, 'customEvent' : true } } @define class Comics extends Book { \/\/ Use custom collection instead of the implicitly created one static Collection = ComicsShelve; \/\/ Extend record's attributes static attributes = { artist : Author } } Declarations static model = RecordConstructor @define class Library extends Record.Collection { static model = Book; } If defined, you can pass raw attributes objects (and arrays) to add, create, and reset, and the attributes will be converted into a model of the proper type. This property is being set automatically for collection types referenced as MyRecord.Collection. In the majority of cases you don't need to define it explicitly. Members constructor( models?, options? ) When creating a Collection, you may choose to pass in the initial array of models. The collection's comparator may be included as an option. Passing false as the comparator option will prevent sorting. If you define an initialize function, it will be invoked when the collection is created. There are a couple of options that, if provided, are attached to the collection directly: model and comparator. Pass null for models to create an empty Collection with options. var tabs = new TabSet([tab1, tab2, tab3]); collection.add( models, options? ) Add a record (or an array of records) to the collection, firing an &quot;add&quot; event for each record, and an &quot;update&quot; event afterwards. If a record property is defined, you may also pass raw attributes objects, and have them be vivified as instances of the record. Returns the added (or preexisting, if duplicate) records. Pass {at: index} to splice the record into the collection at the specified index. If you're adding records to the collection that are already in the collection, they'll be ignored, unless you pass {merge: true}, in which case their attributes will be merged into the corresponding records, firing any appropriate &quot;change&quot; events. var ships = new Backbone.Collection; ships.on(&quot;add&quot;, function(ship) { alert(&quot;Ahoy &quot; + ship.get(&quot;name&quot;) + &quot;!&quot;); }); ships.add([ {name: &quot;Flying Dutchman&quot;}, {name: &quot;Black Pearl&quot;} ]); Note that adding the same record (a record with the same id) to a collection more than once is a no-op. collection.remove( records, options? ) Remove a record (or an array of records) from the collection, and return them. Each record can be a record instance, an id string or a JS object, any value acceptable as the id argument of collection.get. Fires a &quot;remove&quot; event for each record, and a single &quot;update&quot; event afterwards, unless {silent: true} is passed. The record's index before removal is available to listeners as options.index. collection.reset( records, options? ) Adding and removing records one at a time is all well and good, but sometimes you have so many records to change that you'd rather just update the collection in bulk. Use reset to replace a collection with a new list of records (or attribute hashes), triggering a single &quot;reset&quot; event on completion, and without triggering any add or remove events on any records. Returns the newly-set records. Pass null for records to empty your Collection with options. Here's an example using reset to bootstrap a collection during initial page load, in a Rails application: &lt;script&gt; var accounts = new Backbone.Collection; accounts.reset(&lt;%= @accounts.to_json %&gt;); &lt;\/script&gt; Calling collection.reset() without passing any records as arguments will empty the entire collection. collection.set( records, options? ) The set method performs a &quot;smart&quot; update of the collection with the passed list of records. If a record in the list isn't yet in the collection it will be added; if the record is already in the collection its attributes will be merged; and if the collection contains any records that aren't present in the list, they'll be removed. All of the appropriate &quot;add&quot;, &quot;remove&quot;, and &quot;change&quot; events are fired as this happens. Returns the touched records in the collection. If you'd like to customize the behavior, you can disable it with options: {add: false}, {remove: false}, or {merge: false}. const vanHalen = new Man.Collection([ eddie, alex, stone, roth ]); vanHalen.set([ eddie, alex, stone, hagar ]); \/\/ Fires a &quot;remove&quot; event for roth, and an &quot;add&quot; event for &quot;hagar&quot;. \/\/ Updates any of stone, alex, and eddie's attributes that may have \/\/ changed over the years. collection.get( id ) Get a record from a collection, specified by an id, a cid, or by passing in a record. const book = library.get(110); collection.at( index ) Get a record from a collection, specified by index. Useful if your collection is sorted, and if your collection isn't sorted, at will still retrieve records in insertion order. When passed a negative index, it will retrieve the record from the back of the collection. collection.length Like an array, a Collection maintains a length property, counting the number of models it contains. collection.models Raw access to the JavaScript array of models inside of the collection. Usually you'll want to use get, at, or the other methods to access model objects, but occasionally a direct reference to the array is desired.","tags":"","url":"Collection\/Overview.html"},{"title":"Proxied array methods","text":"collection.push( record, options? ) Add a record at the end of a collection. Takes the same options as add. collection.pop( options? ) Remove and return the last record from a collection. Takes the same options as remove. collection.unshift( model, options? ) Add a model at the beginning of a collection. Takes the same options as add. collection.shift( options? ) Remove and return the first model from a collection. Takes the same options as remove. collection.slice( begin, end ) Return a shallow copy of the collection.models, using the same options as native Array#slice. collection.indexOf( recordOrId : any ) : number Return an index of the record in the collection, and -1 if there are no such a record in the collection. Can take the record itself as an argument, id, or cid of the record.","tags":"","url":"Collection\/Proxied_array_methods.html"},{"title":"Iteration methods","text":"map and forEach collection.forEach( iteratee : ( val : Record, index ) =&gt; void, context? ) collection.each( iteratee : ( val : Record, index ) =&gt; void, context? ) Iterate through the elements of the collection. Similar to Array.forEach. collection.updateEach( iteratee : ( val : Record, index ) =&gt; void, context? ) Similar to the collection.each, but wraps an iteration in a transaction. The single changes event will be emitted for the group of changes to the records made in updateEach. Use this method if you modify records in a loop. collection.map( iteratee : ( val : Record, index ) =&gt; T, context? ) Map elements of the collection. Similar to Array.map, but undefined values returned by iteratee are filtered out. Thus, collection.map can be used to map and filter elements in a single pass. Predicate methods Predicate is either the iteratee function returning boolean, or an object with attribute values used to match with record's attributes. collection.filter( iteratee : Predicate, context? ) Return filtered array of records matching the predicate. collection.every( iteratee : Predicate, context? ) : boolean Return true if all records match the predicate. collection.some( iteratee : Predicate, context? ) : boolean Return true if at least one record match the predicated.","tags":"","url":"Collection\/Iteration_methods.html"},{"title":"Sorted collections","text":"By default there is no comparator for a collection. If you define a comparator, it will be used to maintain the collection in sorted order. This means that as records are added, they are inserted at the correct index in collection.models. Note that Type-R depends on the arity of your comparator function to determine between the two styles, so be careful if your comparator function is bound. Collections with a comparator will not automatically re-sort if you later change model attributes, so you may wish to call sort after changing model attributes that would affect the order. static comparator = 'attrName' Maintain the collection in sorted order by the given record's attribute. static comparator = x =&gt; number | string &quot;sortBy&quot; comparator functions take a model and return a numeric or string value by which the model should be ordered relative to others. static comparator = ( x, y ) =&gt; -1 | 0 | 1 &quot;sort&quot; comparator functions take two models, and return -1 if the first model should come before the second, 0 if they are of the same rank and 1 if the first model should come after. Note how even though all of the chapters in this example are added backwards, they come out in the proper order: var Chapter = Backbone.Model; var chapters = new Backbone.Collection; chapters.comparator = 'page'; chapters.add(new Chapter({page: 9, title: &quot;The End&quot;})); chapters.add(new Chapter({page: 5, title: &quot;The Middle&quot;})); chapters.add(new Chapter({page: 1, title: &quot;The Beginning&quot;})); alert(chapters.pluck('title')); collection.sort( options? ) Force a collection to re-sort itself. You don't need to call this under normal circumstances, as a collection with a comparator will sort itself whenever a model is added. To disable sorting when adding a model, pass {sort: false} to add. Calling sort triggers a &quot;sort&quot; event on the collection.","tags":"","url":"Collection\/Sorted_collections.html"},{"title":"Serialization","text":"Serialization methods colleciton.parse( json ) Called when { parse : true } option is used in collection's constructor, set, reset, and add methods. May be overriden to transforms the responce from the server. collection.toJSON() Return an array containing the attributes hash of each model (via toJSON) in the collection. This can be used to serialize and persist the collection as a whole. The name of this method is a bit confusing, because it conforms to JavaScript's JSON API. @define class Man extends Record { static attributes = { name : '', age : 0 } } const collection = new Man.Collection([ {name: &quot;Tim&quot;, age: 5}, {name: &quot;Ida&quot;, age: 26}, {name: &quot;Rob&quot;, age: 55} ]); alert(JSON.stringify(collection)); Polymorphic collections Collection may contain polimorphic records of different types if they are the subclass of the model. You need to define static Model.create factory method to make an abstract model serializable. @define \/\/ Serializable abstract Record class Document extends Record { static attrbutes = { type : String, \/\/ attrs definition... }; \/\/ Factory method needs to be defined. static create( attrs, options ){ switch( attrs.type ){ case &quot;public&quot; : return new PublicDocument( attrs, options ); case &quot;private&quot; : return new PrivateDocument( attrs, options ); } } } const Library = Document.Collection; @define class PublicDocument extends Document { static attributes = { type : 'public', \/\/ attrs definition... } } @define class PrivateDocument extends Document { static attributes = { type : 'private', \/\/ attrs definition... } }","tags":"","url":"Collection\/Serialization.html"},{"title":"Updates and Events","text":"Updates Collections notify listeners on the details of the update with events. It's executed in 3 steps: Apply all changes to collection and nested records. Trigger events for individual changes: Trigger add, remove, or change event for every individual record change. Trigger an update event when there are any records added or removed, and sort event if an order of records was changed. If any changes were applied to the collection: trigger changes event; notify collection's owner on aggregation subtree changes. collection.add( models, options? ) Add a record (or an array of records) to the collection, firing an &quot;add&quot; event for each record, and an &quot;update&quot; event afterwards. If a record property is defined, you may also pass raw attributes objects, and have them be vivified as instances of the record. Returns the added (or preexisting, if duplicate) records. Pass {at: index} to splice the record into the collection at the specified index. If you're adding records to the collection that are already in the collection, they'll be ignored, unless you pass {merge: true}, in which case their attributes will be merged into the corresponding records, firing any appropriate &quot;change&quot; events. var ships = new Backbone.Collection; ships.on(&quot;add&quot;, function(ship) { alert(&quot;Ahoy &quot; + ship.get(&quot;name&quot;) + &quot;!&quot;); }); ships.add([ {name: &quot;Flying Dutchman&quot;}, {name: &quot;Black Pearl&quot;} ]); Note that adding the same record (a record with the same id) to a collection more than once is a no-op. collection.remove( records, options? ) Remove a record (or an array of records) from the collection, and return them. Each record can be a record instance, an id string or a JS object, any value acceptable as the id argument of collection.get. Fires a &quot;remove&quot; event for each record, and a single &quot;update&quot; event afterwards, unless {silent: true} is passed. The record's index before removal is available to listeners as options.index. collection.set( records, options? ) The set method performs a &quot;smart&quot; update of the collection with the passed list of records. If a record in the list isn't yet in the collection it will be added; if the record is already in the collection its attributes will be merged; and if the collection contains any records that aren't present in the list, they'll be removed. All of the appropriate &quot;add&quot;, &quot;remove&quot;, and &quot;change&quot; events are fired as this happens. Returns the touched records in the collection. If you'd like to customize the behavior, you can disable it with options: {add: false}, {remove: false}, or {merge: false}. const vanHalen = new Man.Collection([ eddie, alex, stone, roth ]); vanHalen.set([ eddie, alex, stone, hagar ]); \/\/ Fires a &quot;remove&quot; event for roth, and an &quot;add&quot; event for &quot;hagar&quot;. \/\/ Updates any of stone, alex, and eddie's attributes that may have \/\/ changed over the years. record.transaction( fun ) Execute the sequence of updates in fun function in the scope of the transaction. Transaction is the sequence of updates resuling in a single changes event. Every collection update method opens an implicit transaction. collection.updateEach( iteratee : ( val : Record, index ) =&gt; void, context? ) Similar to the collection.each, but wraps an iteration in a transaction. collection.reset( records, options? ) Adding and removing records one at a time is all well and good, but sometimes you have so many records to change that you'd rather just update the collection in bulk. Use reset to replace a collection with a new list of records (or attribute hashes), triggering a single &quot;reset&quot; event on completion, and without triggering any add or remove events on any records. Returns the newly-set records. Pass null for records to empty your Collection with options. Here's an example using reset to bootstrap a collection during initial page load, in a Rails application: &lt;script&gt; var accounts = new Backbone.Collection; accounts.reset(&lt;%= @accounts.to_json %&gt;); &lt;\/script&gt; Calling collection.reset() without passing any records as arguments will empty the entire collection. Listening to events Collection implements Events API (on, off, once, listenTo, stopListening, listenToOnce, trigger), and dedicated methods for listening to the changes event (onChanges, offChanges, listenToChanges). static itemEvents = { eventName : handler, ... } Subscribe for events from records. The hander is either the collection's method name, the handler function, or true. When true is passed as a handler, the corresponding event will be triggered on the collection. List of built-in events Collection-level events event &quot;changes&quot; (collection, options) The main change event. Single event triggered when the collection has been changed. event &quot;update&quot; (collection, options) Single event triggered after any number of records have been added or removed from a collection. event &quot;reset&quot; (collection, options) When the collection's entire contents have been reset. event &quot;sort&quot; (collection, options) When the collection has been re-sorted. Record-level events event &quot;add&quot; (record, collection, options) When a record is added to a collection. event &quot;remove&quot; (record, collection, options) When a record is removed from a collection. event &quot;change&quot; (record, options) When a record's attributes have changed.","tags":"","url":"Collection\/Updates_and_Events.html"},{"title":"Validation","text":"collection.validate() Override in the subclass to add collection-level validation. Whatever is returned is treated as an error message. collection.isValid() Returns true whenever all records in the collection is valid and collection.validate() returns undefined. collection.isValid( id ) Returns true whenever the record with a given id or cid is valid. collection.validationError Detailed validation error information, or null if all the records are valid. An error object has tree structure mapping the invalid subtree of the aggregation tree. \/\/ ValidationError object shape { error : \/* record-level validation error msg as returned from collection.validate() *\/, nested : { \/\/ One entry per each invalid record. \/* record.cid *\/ : \/* record.validationError *\/ } } Validation error traversal ValidationError has a couple of methods for tree traversal. validationError.each( ( error, key ) =&gt; void ) Iterate through the records's errors (not recursive). key is null for the collection-level validation error. validationError.eachError( ( error, key, recordOrCollection ) =&gt; void ) Recursively traverse aggregation tree errors. key is null for the record-level validation error. recordOrCollection is the reference to the current object.","tags":"","url":"Collection\/Validation.html"},{"title":"Events","text":"Type-R implements Backbone 1.1 events API in the form of the Events mixin and Messenger base class. An implementation is optimized for the large amount of relatively small subscriptions (5-10 events). The majority of event subscriptions occuring in Type-R is 1-2 events per source. Here are benchmark results (lower is the better). Events mixin Events is a mixin, giving the object the ability to bind and trigger custom named events. Events do not have to be declared before they are bound, and may take passed arguments. eventsSource.trigger(event, [*args]) Trigger callbacks for the given event, or space-delimited list of events. Subsequent arguments to trigger will be passed along to the event callbacks. High-level listening API All high-level event subscriptions are stopped automatically on the listener's disposal, and thus does not introduce memory leaks. This is the preferable listening API and must be used in all application code. listener.listenTo(other, event, callback) Tell an object to listen to a particular event on an other object. The advantage of using this form, instead of other.on(event, callback, object), is that listenTo allows the object to keep track of the events, and they can be removed all at once later on. The callback will always be called with object as context. view.listenTo(model, 'change', view.render); listener.stopListening([other], [event], [callback]) Tell an object to stop listening to events. Either call stopListening with no arguments to have the object remove all of its registered callbacks ... or be more precise by telling it to remove just the events it's listening to on a specific object, or a specific event, or just a specific callback. view.stopListening(); view.stopListening(model); listener.listenToOnce(other, event, callback) Just like listenTo, but causes the bound callback to fire only once before being removed. Low-level listening API This API is more efficient but requires manual action to stop the subscribtion. Must be used with care. eventSource.on(event, callback, [context]) Bind a callback function to an object. The callback will be invoked whenever the event is fired. If you have a large number of different events on a page, the convention is to use colons to namespace them: &quot;poll:start&quot;, or &quot;change:selection&quot;. The event string may also be a space-delimited list of several events... book.on(&quot;change:title change:author&quot;, ...); Callbacks bound to the special &quot;all&quot; event will be triggered when any event occurs, and are passed the name of the event as the first argument. For example, to proxy all events from one object to another: proxy.on(&quot;all&quot;, function(eventName) { object.trigger(eventName); }); All event methods also support an event map syntax, as an alternative to positional arguments: book.on({ &quot;change:author&quot;: authorPane.update, &quot;change:title change:subtitle&quot;: titleView.update, &quot;destroy&quot;: bookView.remove }); To supply a context value for this when the callback is invoked, pass the optional last argument: model.on('change', this.render, this) or model.on({change: this.render}, this). eventSource.off([event], [callback], [context]) Remove a previously-bound callback function from an object. If no context is specified, all of the versions of the callback with different contexts will be removed. If no callback is specified, all callbacks for the event will be removed. If no event is specified, callbacks for all events will be removed. \/\/ Removes just the `onChange` callback. object.off(&quot;change&quot;, onChange); \/\/ Removes all &quot;change&quot; callbacks. object.off(&quot;change&quot;); \/\/ Removes the `onChange` callback for all events. object.off(null, onChange); \/\/ Removes all callbacks for `context` for all events. object.off(null, null, context); \/\/ Removes all callbacks on `object`. object.off(); Note that calling model.off(), for example, will indeed remove all events on the model \u00e2\u0080\u0094 including events that Backbone uses for internal bookkeeping. eventsSource.once(event, callback, [context]) Just like on, but causes the bound callback to fire only once before being removed. Handy for saying &quot;the next time that X happens, do this&quot;. When multiple events are passed in using the space separated syntax, the event will fire once for every event you passed in, not once for a combination of all events Messenger Messenger is an abstract base class implementing Events mixin and some convinience methods. readonly messenger.cid Unique run-time only messenger instance id (string). messenger.initialize() Callback which is called at the end of the constructor. messenger.dispose() Executes messenger.stopListening() and messenger.off(). Objects must be disposed to prevent memory leaks caused by subscribing for events from singletons.","tags":"","url":"Events.html"},{"title":"Mixins","text":"Both plain JS object and class constructor may be used as mixins. In the case of the class constructor, missing static members will copied over as well. decorator @mixins( mixinA, mixinB, ... ) class ... You need to import mixins decorator to use mixins: import { mixins } from 'type-r' ... @mixins( plainObject, MyClass, ... ) class X { ... } decorator @mixinRules({ name : rule, ... }) class ...` Define configurable properties merge rules for the specific class. Rules can be extented in any subclass. Mixin rules rule name : 'merge' Assume the property to be an object. Property values from mixins will be merged. rule name : { name1 : rule, ... } If merge rule is an object, the corresponding member is expected to be an object and the rule defines the merge rules for its members. rule name : 'pipe' Property is the function ( x : T ) =&gt; T transforming the value. Multiple functions joined in pipe. rule name : 'sequence' Property is the function. Multiple functions will be called in sequence. rule name : 'reverse' Same as sequence, but functions called in reverse sequence. rule name : 'mergeSequence' Merge the object returned by functions, executing them in sequence. rule name : 'every' Property is the function ( ...args : any[] ) =&gt; boolean. Resulting method will return true if every single function returns true. rule name : 'some' Same as every, but method will return true when at least one function returns true.","tags":"","url":"Mixins.html"}]}