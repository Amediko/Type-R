{"pages":[{"title":"Type-R","text":"Type-R is the universal state management JS framework designed to manage both UI and domain application state. Serializable and observable Complex serialization scenarios like many-to-many relations by id are supported out of box. Declarative validation Validation checks are transparent and declarative. Dynamically type-safe State elements are typed. It's guaranteed that state elements will retain declared types at run-time no matter what. Client-server communication is validated and guarded from type errors from both ends.","tags":"","url":"index.html"},{"title":"Getting Started","text":"Intruduction Type-R is the universal state container for both UI and domain state management. Application state is described with the superposition of two main container types - Record and Collection or records. The state has observable changes and is serializable by default. Records are classes with typed attributes. They are protected from assignment of incompatible types with run-time type assertions and convertions. Which means that the client-server protocol is protected from both ends. Records distinguish aggregated attributes and those which are references to shared objects. Aggregated attributes are serialized as nested JSON, while references might be serialized as ids. Many operations like clone(), dispose(), and toJSON() are performed recursively on elements of aggregation tree. Type-R features declarative validation with attribute-level rules. Validation is transarent and lazily evaluated. Architecture does not depend on stores and singletons. Stores are optional and used for shared data only. There might be as many stores as you need, and they can be created and disposed dynamically. Type-R data structures are pretty efficient. They are about 10 times faster in real-world data scenarios than BackboneJS. Installation Is packed as UMD and ES6 module. No side dependencies. npm install type-r --save-dev Requirements IE10+, Edge, Safari, Chrome, Firefox are supported. IE9 and Opera may work but has not been tested. IE8 won't work.","tags":"","url":"Getting_Started.html"},{"title":"Definition","text":"Record is the serializable class with typed attributes, observable changes, and custom validation checks. It is the main building block for managing the application state; component local state, stores, and collection elements are all subclasses of the Record. In contrast to the &quot;model&quot; class in the majority of data frameworks, Record is not the key-value hash. It's the class with statically defined set of attributes of known types. Record itself is an abstract class. The subclass needs to be defined for every data structure of different shape, in a similar way as it's done in statically typed languages. import { define, Record } from 'type-r' \/\/ \u00e2\u00a4\u00b9 required to make magic work @define class User extends Record { \/\/ \u00e2\u00a4\u00b9 attribute's declaration static attributes = { firstName : '', \/\/ \u00e2\u009f\u00b5 String type is inferred from the default value lastName : String, \/\/ \u00e2\u009f\u00b5 Or you can just mention its constructor email : String.value( null ), \/\/\u00e2\u009f\u00b5 Or you can provide both createdAt : Date, \/\/ \u00e2\u009f\u00b5 And it works for any constructor. \/\/ And you can attach \u00e2\u00a4\u00b9 metadata to fine-tune attribute's behavior lastLogin : Date.value( null ).has.toJSON( false ) \/\/ \u00e2\u009f\u00b5 not serializable } } const user = new User(); console.log( user.createdAt ); \/\/ \u00e2\u009f\u00b5 this is an instance of Date created for you. const users = new User.Collection(); \/\/ \u00e2\u009f\u00b5 Collections are defined automatically. users.on( 'changes', () =&gt; updateUI( users ) ); \/\/ \u00e2\u009f\u00b5 listen to the changes. users.set( json, { parse : true } ); \/\/ \u00e2\u009f\u00b5 parse raw JSON from the server. users.updateEach( user =&gt; user.firstName = '' ); \/\/ \u00e2\u009f\u00b5 bulk update triggering 'changes' once Record definition Record must extend Record base class, it must have static attributes definition, and the class definition must be preceeded with @define decorator. static attributes = { name : attrDef, ... } Record is a class with an observalbe and serializable public attributes. Attributes must be declared statically in static attributes class member, which is an object hash mapping an attribute name name to its declaration, encapsulating attribute type, default value, and metadata controlling different aspects of attribute behavior. @define class User extends Record { static attributes = { name : String.value( 'John Dow' ), email : 'john.dow@mail.com', \/\/ Same as String.value( 'john.dow@mail.com' ) address : String, \/\/ Same as String.value( '' ) } } The Record guarantee that every attribute will always hold the value of the declared type. Whenever the an attribute is being assigned with the value which is not compatible with its declared type, the type is being converted with an invocation of the constructor: new Type( value ) (primitive types are treated specially). Attribute definitions attrDef name : Type.value( defaultValue ) The general form of type annotation is Type.value( defaultValue ), where the Type is the corresponding constructor function. attrDef name : Type When the function is used as attrDef, it's treated as the constructor function. Any constructor function may be used as an attribute type, if it behaves as converting constructor (like new Date( msecs )). attrDef name : defaultValue When other value than function is passed, it's treated as the default value and the type is being inferred form the value. If you need to pass function as the default value, use Function.value( theFunction ). Create the record Record behaves as regular ES6 class with attributes accessible as properties. new Record() Create an instance of the record with the default attribute values taken from the attributes definition. When no default value is explicitly provided, it's new Type() (just Type() for primitives). When the default value is provided and it's not compatible with the attribute type, it's converted with new Type( defaultValue ) call. new Record({ attrName : value, ... }, options? ) When creating an instance of a record, you can pass in the initial values of the attributes, which will be set on the record. If {parse: true} is passed as an option, attrs is assumed to be the JSON. If the value of the particular attribute is not compatible with its type, it's converted to this type invoking the constructor new Type( value ) (just Type( value ) for primitives). @define class Book extends Record { static attributes = { title : '', author : '' } } const book = new Book({ title: &quot;One Thousand and One Nights&quot;, author: &quot;Scheherazade&quot; }); record.initialize( attrs?, options? ) Called at the end of the Record constructor when all attributes are assigned and record's inner state is properly initialized. Takes the same arguments as a constructor. record.attrName Record's attributes may be directly accessed with record.name, as if they would be the members of the class. Please note, that you have to declare all attributes in static attributes declaration before use. @define class Account extends Record { static attributes = { name : String, ballance : Number } } const myAccount = new Account({ name : 'mine' }); myAccount.ballance += 1000000; \/\/ That works. Good, eh?","tags":"","url":"Record\/Definition.html"},{"title":"Updates and transactions","text":"Update record attributes record.attrName = value Assign record attribute. If the value is not compatible with attribute's type, special action is taken: For primitive attribute, it's converted with Type( value ) call. For record or collection, it's used to update it in place with record.attrName.set( value ). In other cases, it's converted with new Type( value ) call. In case of changes, the record triggers events: change:attrName ( record, value ). change ( record ). record.set( { attrName : value, ... }, options? : options ) Bulk assign record's attributes, possibly taking options. If the value is not compatible with attribute's type, special action is taken: For primitive attribute, it's converted with Type( value ) call. For record or collection, it's used to update it in place with record.attrName.set( value ). In other cases, it's converted with new Type( value ) call. In case of changes, the record triggers events: For any changed attribute, trigger event change:attrName ( record, val, options ). If any attribute has changed: trigger event change (record, options). options { parse : true } Transform record.set argument with user-defined parse logic. Typically used to process the responce from the server to make user-defined JSON format conversion. options { merge : true } Merge attributes of record and collection types instead of replacement. If the new instance of record or collection is to be assigned, update the current instances instead. record.assignFrom( otherRecord ) Makes an existing record to be the copy of otherRecord, recursively assigning all attributes. Works similar to record.set( otherRecord.attributes, { merge : true }); Transactions All record updates occures in the scope of transactions. Transaction is the sequence of changes which results in a single change event. Transaction can be opened either manually or implicitly with calling set() or assigning an attribute. Any additional changes made to the record in change:attr event handler will be executed in the scope of the original transaction, and won't trigger additional change events. record.transaction( fun ) Execute the all changes made to the record in fun as single transaction. some.record.transaction( record =&gt; { record.a = 1; \/\/ `change:a` is triggered. record.b = 2; \/\/ `change:b` is triggered. }); \/\/ `change` is triggered. Manual transactions with attribute assignments are superior to record.set() in terms of both performance and flexibility.","tags":"","url":"Record\/Updates_and_transactions.html"},{"title":"Listening to events","text":"Observable changes Object tree formed by records and collection is deeply observable by default; changes in tree leafs triggers the changes of all parent elements in sequence. Records automatically listens to change events of all nested records and collections, and triggers the corresponding change events on its attributes. attrDef attr : Type.has.changeEvents( false ) Do not listen for the inner changes of the specific attr. Listening to events in the record Record has declarative API for managing event subscriptions for its attributes. attrDef attr : Type.has.watcher( 'methodName' ) attrDef attr : Type.has.watcher( function( value, name ){ ... } ) Attach change:attr event listener to the particular record's attribute. Watcher function has the signature ( attrValue, attrName ) =&gt; void and is executed in the context of the record. Note that it differs from the event signature. @define class User extends Record { static attributes = { name : String.has.watcher( 'onNameChange' ), isAdmin : Boolean, } onNameChange(){ \/\/ Cruel. But we need it for the purpose of the example. this.isAdmin = this.name.indexOf( 'Admin' ) &gt;= 0; } } attrDef attr : Type.has.events({ eventName : handler, ... }) Automatically manage custom event subscription for the attribute. handler is either the method name or the handler function. Events subscription with Events API listener.listenTo() and listener.listenToOnce() methods can be used to listen to the any of the change events. If listener itself is the record or collection, subscribtions will be stopped automatically. Otherwise they must be stopped manually with listener.stopListening() call to prevent memory leaks. Change inspection methods Following API might be useful in change event listeners. record.changed The changed property is the internal hash containing all the attributes that have changed during its last transaction. Please do not update changed directly since its state is internally maintained by set(). A copy of changed can be acquired from changedAttributes(). record.changedAttributes( attrs? ) Retrieve a hash of only the record's attributes that have changed during the last transaction, or false if there are none. Optionally, an external attributes hash can be passed in, returning the attributes in that hash which differ from the record. This can be used to figure out which portions of a view should be updated, or what calls need to be made to sync the changes to the server. record.previous( attr ) During a &quot;change&quot; event, this method can be used to get the previous value of a changed attribute. @define class Person extends Record{ static attributes = { name: '' } } const bill = new Person({ name: &quot;Bill Smith&quot; }); bill.on(&quot;change:name&quot;, ( record, name ) =&gt; { alert( `Changed name from ${ bill.previous('name') } to ${ name }`); }); bill.name = &quot;Bill Jones&quot;; record.previousAttributes() Return a copy of the record's previous attributes. Useful for getting a diff between versions of a record, or getting back to a valid state after an error occurs.","tags":"","url":"Record\/Listening_to_events.html"},{"title":"Definition","text":"Collections are ordered sets of records. You can bind &quot;change&quot; events to be notified when any record in the collection has been modified, listen for &quot;add&quot; and &quot;remove&quot; events, fetch the collection from the server, and use a full suite of Underscore.js methods. Collection is implicitly defined for every record with a constructor accessible as MyRecord.Collection. In most cases, you don't need to declare it manually. \/\/ Implicitly defined collection. const books = new Book.Collection(); @define class ComicsShelve extends Book.Collection { static itemEvents = { \/\/ List of records's events we want to be triggered on the collection 'change:inMyReadingList' : true, 'customEvent' : true } } @define class Comics extends Book { \/\/ Use custom collection instead of the implicitly created one static Collection = ComicsShelve; \/\/ Extend record's attributes static attributes = { artist : Author } } Collection definition Implicitly defined collections RecordConstructor.Collection Every Record class has implicitly defined Collection, which can be referenced adding the .Collection to the record's constructor. Extending the Collection class Collections can be defined explicitly extending the base Collection class. There are two ways to bind collection to the record. (record definition) static Collection = CollectionConstructor Replaces implicitly defined collection with externally defined collection class. (colleciton definition) static model = RecordConstructor Specify the record type inside of the collection's definition. This property is being set automatically for collection types referenced as MyRecord.Collection. @define class Library extends Record.Collection { static model = Book; } Create and access the colleciton new Collection() Create an empty collection. new Collection( models, options? ) When creating a Collection, you may choose to pass in the initial array of models. The collection's comparator may be included as an option. Passing false as the comparator option will prevent sorting. If you define an initialize() function, it will be invoked when the collection is created. There are a couple of options that, if provided, are attached to the collection directly: model and comparator. Pass null for models to create an empty Collection with options. var tabs = new TabSet([tab1, tab2, tab3]); collection.initialize( models?, options? ) Initialization function which is called at the end of the constructor. collection.get( id ) Get a record from a collection, specified by an id, a cid, or by passing in a record. const book = library.get(110); collection.at( index ) Get a record from a collection, specified by index. Useful if your collection is sorted, and if your collection isn't sorted, at will still retrieve records in insertion order. When passed a negative index, it will retrieve the record from the back of the collection. collection.length Like an array, a Collection maintains a length property, counting the number of models it contains. collection.models Raw access to the JavaScript array of models inside of the collection. Usually you'll want to use get, at, or the other methods to access model objects, but occasionally a direct reference to the array is desired.","tags":"","url":"Collection\/Definition.html"},{"title":"Updates and transactions","text":"Updates Methods to update the collection. They accept common options: sort : false - do not sort the collection. parse : true - parse raw JSON (used to set collection with a data from the server). collection.add( models, options? ) Add a record (or an array of records) to the collection. If this is the Record.Collection, you may also pass raw attributes objects, and have them be vivified as instances of the Record. Returns the added (or preexisting, if duplicate) records. Pass {at: index} to splice the record into the collection at the specified index. If you're adding records to the collection that are already in the collection, they'll be ignored, unless you pass {merge: true}, in which case their attributes will be merged into the corresponding records. Trigger the one event per record: add(record, collection, options) for each record added. change(record, options) for each record changed (if the {merge: true} option is passed). Trigger the single event: update(collection, options) if any records were added. sort(collection, options) if an order of records was changed. Trigger changes event in case if any changes were made to the collection and objects inside. collection.remove( records, options? ) Remove a record (or an array of records) from the collection, and return them. Each record can be a record instance, an id string or a JS object, any value acceptable as the id argument of collection.get. Trigger remove(record, collection, options) for each record removed. If any records were removed, trigger: update(collection, options) changes(collection, options). collection.set( records, options? ) The set method performs a &quot;smart&quot; update of the collection with the passed list of records. If a record in the list isn't yet in the collection it will be added; if the record is already in the collection its attributes will be merged; and if the collection contains any records that aren't present in the list, they'll be removed. All of the appropriate &quot;add&quot;, &quot;remove&quot;, and &quot;change&quot; events are fired as this happens. Returns the touched records in the collection. If you'd like to customize the behavior, you can disable it with options: {remove: false}, or {merge: false}. Events Trigger the one event per record: add(record, collection, options) for each record added. remove(record, collection, options) for each record removed. change(record, options) for each record changed. Trigger the single event: update(collection, options) if any records were added. sort(collection, options) if an order of records was changed. Trigger changes event in case if any changes were made to the collection and objects inside. const vanHalen = new Man.Collection([ eddie, alex, stone, roth ]); vanHalen.set([ eddie, alex, stone, hagar ]); \/\/ Fires a &quot;remove&quot; event for roth, and an &quot;add&quot; event for &quot;hagar&quot;. \/\/ Updates any of stone, alex, and eddie's attributes that may have \/\/ changed over the years. collection.reset( records, options? ) Replace the collection's content with the new records. More efficient than collection.set, but does not send record-level events. Calling collection.reset() without passing any records as arguments will empty the entire collection. Trigger event reset( collection, options ). Trigger event changes( collection, options ). Transactions All collection updates occures in the scope of transactions. Transaction is the sequence of changes which results in a single changes event. Transaction can be opened either manually or implicitly with calling any of collection update methods. Any additional changes made to the collection or its items in event handlers will be executed in the scope of the original transaction, and won't trigger an additional changes events. collection.transaction( fun ) Execute the sequence of updates in fun function in the scope of the transaction. collection.updateEach( iteratee : ( val : Record, index ) =&gt; void, context? ) Similar to the collection.each, but wraps the loop in a transaction.","tags":"","url":"Collection\/Updates_and_transactions.html"},{"title":"Listening to events","text":"Observable changes Object tree formed by records and collection is deeply observable by default; changes in tree leafs triggers the changes of all parent elements in sequence. Collection automatically listens to change events of all of its records, and triggers change and changes events. Listening to item events in the collection static itemEvents = { eventName : handler, ... } Subscribe for events from records. The hander is either the collection's method name, the handler function, or true. When true is passed as a handler, the corresponding event will be triggered on the collection. Events subscription with Events API listener.listenTo() and listener.listenToOnce() methods can be used to listen to the any of the collection events.s If listener itself is the record or collection, subscribtions will be stopped automatically. Otherwise they must be stopped manually with listener.stopListening() call to prevent memory leaks.","tags":"","url":"Collection\/Listening_to_events.html"},{"title":"Iteration methods","text":"map and forEach collection.forEach( iteratee : ( val : Record, index ) =&gt; void, context? ) collection.each( iteratee : ( val : Record, index ) =&gt; void, context? ) Iterate through the elements of the collection. Similar to Array.forEach. collection.updateEach( iteratee : ( val : Record, index ) =&gt; void, context? ) Similar to the collection.each, but wraps an iteration in a transaction. The single changes event will be emitted for the group of changes to the records made in updateEach. Use this method if you modify records in a loop. collection.map( iteratee : ( val : Record, index ) =&gt; T, context? ) Map elements of the collection. Similar to Array.map, but undefined values returned by iteratee are filtered out. Thus, collection.map can be used to map and filter elements in a single pass. Predicate methods Predicate is either the iteratee function returning boolean, or an object with attribute values used to match with record's attributes. collection.filter( iteratee : Predicate, context? ) Return filtered array of records matching the predicate. collection.every( iteratee : Predicate, context? ) : boolean Return true if all records match the predicate. collection.some( iteratee : Predicate, context? ) : boolean Return true if at least one record match the predicated.","tags":"","url":"Collection\/Iteration_methods.html"},{"title":"Sorted collections","text":"By default there is no comparator for a collection. If you define a comparator, it will be used to maintain the collection in sorted order. This means that as records are added, they are inserted at the correct index in collection.models. Note that Type-R depends on the arity of your comparator function to determine between the two styles, so be careful if your comparator function is bound. Collections with a comparator will not automatically re-sort if you later change model attributes, so you may wish to call sort after changing model attributes that would affect the order. static comparator = 'attrName' Maintain the collection in sorted order by the given record's attribute. static comparator = x =&gt; number | string &quot;sortBy&quot; comparator functions take a model and return a numeric or string value by which the model should be ordered relative to others. static comparator = ( x, y ) =&gt; -1 | 0 | 1 &quot;sort&quot; comparator functions take two models, and return -1 if the first model should come before the second, 0 if they are of the same rank and 1 if the first model should come after. Note how even though all of the chapters in this example are added backwards, they come out in the proper order: var Chapter = Backbone.Model; var chapters = new Backbone.Collection; chapters.comparator = 'page'; chapters.add(new Chapter({page: 9, title: &quot;The End&quot;})); chapters.add(new Chapter({page: 5, title: &quot;The Middle&quot;})); chapters.add(new Chapter({page: 1, title: &quot;The Beginning&quot;})); alert(chapters.pluck('title')); collection.sort( options? ) Force a collection to re-sort itself. You don't need to call this under normal circumstances, as a collection with a comparator will sort itself whenever a model is added. To disable sorting when adding a model, pass {sort: false} to add. Calling sort triggers a &quot;sort&quot; event on the collection.","tags":"","url":"Collection\/Sorted_collections.html"},{"title":"Proxied array methods","text":"collection.push( record, options? ) Add a record at the end of a collection. Takes the same options as add. collection.pop( options? ) Remove and return the last record from a collection. Takes the same options as remove. collection.unshift( model, options? ) Add a model at the beginning of a collection. Takes the same options as add. collection.shift( options? ) Remove and return the first model from a collection. Takes the same options as remove. collection.slice( begin, end ) Return a shallow copy of the collection.models, using the same options as native Array#slice. collection.indexOf( recordOrId : any ) : number Return an index of the record in the collection, and -1 if there are no such a record in the collection. Can take the record itself as an argument, id, or cid of the record.","tags":"","url":"Collection\/Proxied_array_methods.html"},{"title":"Aggregation tree","text":"Records can have attributes holding other Records and Collections, forming indefinitely nested data structures of arbitrary complexity. To create nested record or collection you should just mention its type in attribute's type annotation. import { Record } from 'type-r' @define class User extends Record { static attributes = { name : String, email : String, isActive : true } } @define class UsersListState extends Record { static attributes = { users : User.Collection } } All nested records and collections are aggregated by default and behave as integral parts of the containing record. Aggregated attributes are exclusively owned by the record, and taken with it together form an ownerhip tree. Many operations are performed recursively on aggregated elements: They are created when the owner record is created. They are cloned when the record is cloned. They are disposed when the record is disposed. They are validated as part of the record. They are serialized as nested JSON. Aggregation tree methods recordOrCollection.getOwner() Return the reference to the record's owner, or null if record is not the part of aggregation tree. Due to the nature of aggregation, an object may have one and only one owner. recordOrCollection.clone() Clone the record and all aggregated records and collections. The whole aggregation tree will be recursively cloned, references to shared members will copied. record.assignFrom( otherRecord ) collection.assignFrom( otherCollection ) Recursively assign the record and its aggregated members with values from otherRecord. This operation is similar to record.clone(), but instead of creation of the cloned record it makes an existing record to be the copy of other record. The whole aggregation tree will be recursively assigned, references to shared members will copied. recordOrCollection.dispose() Recursively dispose the record and its aggregated members. &quot;Dispose&quot; means that elements of the aggregation tree will unsubscribe from all event sources. It's crucial to prevent memory leaks in SPA. The whole aggregation tree will be recursively disposed, shared members won't.","tags":"","url":"API_by_feature\/Aggregation_tree.html"},{"title":"Serialization","text":"Aggregation tree formed of records and collections is serializable by default. Record corresponds to an object in JSON, while the collection is represented as an array. Serialization API recordOrCollection.toJSON() Produces the JSON for the aggregation tree of the record or collection. May be overriden in particular record or collection. new RecordOrCollection( json, { parse : true } ) Constructs an aggregation tree from its JSON representation. recordOrCollection.set( json, { parse : true } ) Update an aggregation tree from its JSON representation. recordOrCollection.parse( json ) May be overriden to add custom JSON transformation. Attribute-level serialization control Serialization can be controlled for the specific attribute in the Recrod's attribute definition. attrDef attr : Type.has.toJSON( false ) Exclude attribute from the resulting JSON. attrDef attr : Type.has.toJSON( ( value, name ) =&gt; json ) Override the default toJSON() method for the selected record's attribute. attrDef attr : Type.has.parse( ( json, name ) =&gt; value ) Transform the data before it will be passed to the record's attribute.","tags":"","url":"API_by_feature\/Serialization.html"},{"title":"Validation","text":"Defining validators Attribute-level validators Type-R supports declarative attribute-level validation declarations. This is the preferable way of doing validation. attrDef attr : Type.has.check( predicate, errorMsg? ) Attribute-level validator. predicate : value =&gt; boolean is the function taking attribute's value and returning true whenever the value is valid. optional errorMsg is the error message which will be passed in case if the validation fail. If errorMsg is omitted, error message will be taken from predicate.error. It makes possible to define reusable validation functions. function isAge( years ){ return years &gt;= 0 &amp;&amp; years &lt; 200; } isAge.error = &quot;Age must be between 0 and 200&quot;; Attribute may have any number of checks attached, which are execute in sequence. Validation stops when first check in sequence fails. \/\/ Define new attribute metatype encapsulating validation checks. const Age = Number.has .check( x =&gt; x &gt;= 0, 'I guess you are a bit older' ) .check( x =&gt; x &lt; 200, 'No way man can be that old' ); attrDef attr : Type.isRequired The special case of attribute-level check cutting out empty values. Attribute value must be truthy to pass, &quot;Required&quot; is used as validation error. isRequired is the first validator to check, no matter in which order validators were attached. Object-level validators recordOrCollection.validate() Override in the subclass to add object-level validation. Whatever is returned from validate() is treated as an error message and triggers the validation error. Validation API Validation Validation happens transparently on the first access to any part of the validation API. Validation results are cached. Only the required parts of aggregation tree will be validated again recordOrCollection.isValid() Returns true whenever an object and its aggregation tree is valid. record.isValid( attrName ) collection.isValid( recordId ) Returns true whenever the record's attribute or collection's item is valid. record.validationError Detailed validation error information, or null if the record and its aggregation tree is valid. An error object has tree structure mapping the invalid subtree of the aggregation tree. \/\/ ValidationError object shape { error : \/* record-level validation error msg as returned from record.validate() *\/, \/\/ Attribute-level validation errors, one entry for each invalid attribute. nested : { \/\/ Contains nested ValidationError object for nested records and collections... nestedRecord : \/* ValidationError *\/ nestedCollection : \/* ValidationError *\/ \/\/ ...and error msg for all other attributes. otherAttr : \/* attribute validation error as returned from .has.check() validator *\/ } } collection.validationError Detailed validation error information, or null if the collection and its aggregation tree is valid. An error object has tree structure mapping the invalid subtree of the aggregation tree. \/\/ ValidationError object shape { error : \/* collection-level validation error msg as returned from collection.validate() *\/, \/\/ Collection items validation errors nested : { \/\/ Contains nested ValidationError object for nested records... \/* record.cid *\/ : \/* record.validationError *\/ } } record.getValidationError( attr ) collection.getValidationError( recordId ) Return the validation error for the given attr or collection's item. recordOrCollection.eachValidationError( iteratee : ( error, key, recordOrCollection ) =&gt; void ) Recursively traverse aggregation tree errors. key is null for the record-level validation error (returned from validate()). recordOrCollection is the reference to the current object.","tags":"","url":"API_by_feature\/Validation.html"},{"title":"Shared objects","text":"Shared objects Record's attributes can hold the records and collections from other aggregation trees if they are marked as shared. attrDef attr : RecordOrCollection.shared Record's attribute with a reference to the shared model or collection. It's initialized with null It's not cloned when the record is cloned (just the reference is copied over). It's not disposed when the record is disposed. It's not validated as part of the record (always valid by default) It's excluded from serialization. @define class UsersListState extends Record { static attributes = { users : User.Collection, selected : User.shared \/\/ Can be assigned with the user from this.users } } attrDef attr : Collection.Refs new Collection.Refs() Collection of references to shared records, which does not aggregate its elements. In constrast to the Collection.shared, Collection.Refs creates an instance of collection which is the part the parent record. Still, its items are not validated and serialized. @define class MyRecord extends Record { static attributes = { notCloned : SomeCollection.shared, \/\/ Reference to the _shared collection_ object. cloned : SomeCollection.Refs \/\/ _Aggregated_ collection of references to the _shared records_. }","tags":"","url":"API_by_feature\/Shared_objects.html"},{"title":"id-references and Stores","text":"Record's id record.id Predefined record's attribute, the id is an arbitrary string (integer id or UUID). id is typically generated by the server. It is used in JSON for id-references. Records can be retrieved by id from collections, and there can be just one instance of the record with the same id in the particular collection. static idAttribute = 'attrName' A record's unique identifier is stored under the id attribute. If you're directly communicating with a backend (CouchDB, MongoDB) that uses a different unique key, you may set a Record's idAttribute to transparently map from that key to id. Record's id property will still be linked to Record's id, no matter which value idAttribute has. @define class Meal extends Record { static idAttribute = &quot;_id&quot;; static attributes = { _id : Number, name : '' } } const cake = new Meal({ _id: 1, name: &quot;Cake&quot; }); alert(&quot;Cake id: &quot; + cake.id); record.isNew() Has this record been saved to the server yet? If the record does not yet have an id, it is considered to be new. id-references Serializable references to shared records are called an id-references. It is represented as record.id in JSON, and there must be the populated master collection of records on the client in order to resolve ids on parse. There are two kinds of id-references: one-to-many, and many-to-many. They are declared with the special kind of attribute annotation. Id-references behaves in the same way as shared attributes, but inner changes in referenced objects are not observed. attrDef attr : Record.from( sourceCollection ) Declare an attribute to be the record from the particular collection. Serialized as record.id. attrDef attr : Collection.subsetOf( sourceCollection ) Declare an attribute to be the collection, which is the subset of the particular collection. Serialized as an array of record ids. sourceCollection 'path.relative.to.this' sourceCollection may be the string with the dot-separated relative object path to the collection. In this case, it is resolved dynamically relative to the record's this. @define class State extends Record { items : Item.Collection, selected : Record.from( 'items' ) \/\/ Will resolve to `this.items` } sourceCollection '^path.relative.to.owner' ^ symbol in path is being translated to the getOwner() call. It's recommended to use tilda-references and stores instead. Stores and tilda-references asbtract class Store sourceCollection '~path.relative.to.store' Store is the Record's subclass which serves as a root for id-references. Any id-reference with a path starting with ~ look for the nearest Store subclass traversing the aggregation tree upwards, and if there are none, it takes the default Store class Store.global. For all objects inside of the store's aggregation tree ~member will resolve to the member of this store class. If the lookup will fail, the next available store upper in aggregation tree will be used (as regular records stores can be nested), or the Store.global if there are no one. Stores in Type-R is very different to stores in other framework. Pay attention. @define class Role extends Record { static attributes = { name : String, ... } } @define class User extends Record { static attributes = { name : String, roles : Role.Collection.subsetOf( '~roles' ) } } @define class UsersDirectory extends Store { static attributes = { roles : Role.Collection, users : User.Collection \/\/ `~roles` references will be resolved against this.roles } } Store.global The default store class. Is always the last store to lookup when resolving tilda-reference. Use the default store for the globally shared data only. Each application page must have its local store. @define class MyStore extends Store { static attributes = { users : User.Collection, roles : Role.Collection } } Store.global = new MyStore(); \/\/ Now the reference '~users` will point to users collection from the MyStore.","tags":"","url":"API_by_feature\/id-references_and_Stores.html"},{"title":"Events","text":"Both Record and Collection uses an efficient synchronous events implementation which is compatible with Backbone 1.1 Events API but is twice faster in average. It comes in form of Events mixin and the Messenger base class. An implementation is optimized for the large amount of relatively small subscriptions (5-10 events). Here are the benchmark results (lower is the better). It is also avaiable separately as part of MixtureJS package. Events mixin Events is a mixin, giving the object the ability to bind and trigger custom named events. Events do not have to be declared before they are bound, and may take passed arguments. eventsSource.trigger(event, [*args]) Trigger callbacks for the given event, or space-delimited list of events. Subsequent arguments to trigger will be passed along to the event callbacks. High-level listening API All high-level event subscriptions are stopped automatically on the listener's disposal, and thus does not introduce memory leaks. This is the preferable listening API and must be used in all application code. listener.listenTo(other, event, callback) Tell an object to listen to a particular event on an other object. The advantage of using this form, instead of other.on(event, callback, object), is that listenTo allows the object to keep track of the events, and they can be removed all at once later on. The callback will always be called with object as context. view.listenTo(model, 'change', view.render ); listener.stopListening([other], [event], [callback]) Tell an object to stop listening to events. Either call stopListening with no arguments to have the object remove all of its registered callbacks ... or be more precise by telling it to remove just the events it's listening to on a specific object, or a specific event, or just a specific callback. view.stopListening(); \/\/ Unsubscribe from all events view.stopListening(model); \/\/ Unsubscribe from all events from the model All Type-R classes execute this.stopListening() from their dispose() method. listener.listenToOnce(other, event, callback) Just like listenTo, but causes the bound callback to fire only once before being removed. Low-level listening API This API is more efficient but requires manual action to stop the subscribtion. Must be used with care. eventSource.on(event, callback, [context]) Bind a callback function to an object. The callback will be invoked whenever the event is fired. If you have a large number of different events on a page, the convention is to use colons to namespace them: &quot;poll:start&quot;, or &quot;change:selection&quot;. The event string may also be a space-delimited list of several events... book.on(&quot;change:title change:author&quot;, ...); Callbacks bound to the special &quot;all&quot; event will be triggered when any event occurs, and are passed the name of the event as the first argument. For example, to proxy all events from one object to another: proxy.on(&quot;all&quot;, function(eventName) { object.trigger(eventName); }); All event methods also support an event map syntax, as an alternative to positional arguments: book.on({ &quot;change:author&quot;: authorPane.update, &quot;change:title change:subtitle&quot;: titleView.update, &quot;destroy&quot;: bookView.remove }); To supply a context value for this when the callback is invoked, pass the optional last argument: model.on('change', this.render, this) or model.on({change: this.render}, this). eventSource.off([event], [callback], [context]) Remove a previously-bound callback function from an object. If no context is specified, all of the versions of the callback with different contexts will be removed. If no callback is specified, all callbacks for the event will be removed. If no event is specified, callbacks for all events will be removed. \/\/ Removes just the `onChange` callback. object.off(&quot;change&quot;, onChange); \/\/ Removes all &quot;change&quot; callbacks. object.off(&quot;change&quot;); \/\/ Removes the `onChange` callback for all events. object.off(null, onChange); \/\/ Removes all callbacks for `context` for all events. object.off(null, null, context); \/\/ Removes all callbacks on `object`. object.off(); Note that calling model.off(), for example, will indeed remove all events on the model \u00e2\u0080\u0094 including events that Backbone uses for internal bookkeeping. eventsSource.once(event, callback, [context]) Just like on, but causes the bound callback to fire only once before being removed. Handy for saying &quot;the next time that X happens, do this&quot;. When multiple events are passed in using the space separated syntax, the event will fire once for every event you passed in, not once for a combination of all events Messenger Messenger is an abstract base class implementing Events mixin and some convinience methods. readonly messenger.cid Unique run-time only messenger instance id (string). messenger.initialize() Callback which is called at the end of the constructor. messenger.dispose() Executes messenger.stopListening() and messenger.off(). Objects must be disposed to prevent memory leaks caused by subscribing for events from singletons. List of built-in events Record events event &quot;change:attrName&quot; (record, value, options) When a specific attribute has been updated event &quot;change&quot; (record, options) When a record's attributes have changed. Collection events event &quot;changes&quot; (collection, options) The main change event. Single event triggered when the collection has been changed. event &quot;update&quot; (collection, options) Single event triggered after any number of records have been added or removed from a collection. event &quot;reset&quot; (collection, options) When the collection's entire contents have been reset. event &quot;sort&quot; (collection, options) When the collection has been re-sorted. event &quot;add&quot; (record, collection, options) When a record is added to a collection. event &quot;remove&quot; (record, collection, options) When a record is removed from a collection. event &quot;change&quot; (record, options) When a record's attributes have changed.","tags":"","url":"Events.html"},{"title":"Mixins","text":"Both plain JS object and class constructor may be used as mixins. In the case of the class constructor, missing static members will copied over as well. decorator @mixins( mixinA, mixinB, ... ) class ... You need to import mixins decorator to use mixins: import { mixins } from 'type-r' ... @mixins( plainObject, MyClass, ... ) class X { ... } decorator @mixinRules({ name : rule, ... }) class ...` Define configurable properties merge rules for the specific class. Rules can be extented in any subclass. Mixin rules rule name : 'merge' Assume the property to be an object. Property values from mixins will be merged. rule name : { name1 : rule, ... } If merge rule is an object, the corresponding member is expected to be an object and the rule defines the merge rules for its members. rule name : 'pipe' Property is the function ( x : T ) =&gt; T transforming the value. Multiple functions joined in pipe. rule name : 'sequence' Property is the function. Multiple functions will be called in sequence. rule name : 'reverse' Same as sequence, but functions called in reverse sequence. rule name : 'mergeSequence' Merge the object returned by functions, executing them in sequence. rule name : 'every' Property is the function ( ...args : any[] ) =&gt; boolean. Resulting method will return true if every single function returns true. rule name : 'some' Same as every, but method will return true when at least one function returns true.","tags":"","url":"Mixins.html"}]}