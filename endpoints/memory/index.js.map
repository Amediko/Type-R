{"version":3,"file":"index.js","sources":["../../src/io-tools.ts","../../src/endpoints/memory.ts"],"sourcesContent":["export interface IONode {\n    _endpoint : IOEndpoint\n    _ioPromise : IOPromise< any >\n}\n\nexport interface IOPromise<T> extends Promise<T> {\n    abort? : () => void\n}\n\nexport interface IOEndpoint {\n    list( options : IOOptions, collection? ) : IOPromise<any>\n    create( json : any, options : IOOptions, record? ) : IOPromise<any>\n    update( id : string | number, json :any, options : IOOptions, record? ) : IOPromise<any>\n    patch? : ( id : string | number, json :any, options : IOOptions, record? ) => IOPromise<any>\n    read( id : string | number, options : IOOptions, record? ) : IOPromise<any>\n    destroy( id : string | number, options : IOOptions, record? ) : IOPromise<any>\n    subscribe( events : IOEvents, collection? ) : IOPromise<any>\n    unsubscribe( events : IOEvents, collection? ) : void\n}\n\nexport interface IOOptions {\n    ioUpdate? : boolean\n}\n\nexport interface IOEvents {\n    updated? : ( json : any ) => void\n    removed? : ( json : any ) => void\n}\n\nexport function getOwnerEndpoint( self ) : IOEndpoint {\n    // Check if we are the member of the collection...\n    const { collection } = self;\n    if( collection ){\n        return getOwnerEndpoint( collection );\n    }\n\n    // Now, if we're the member of the model...\n    if( self._owner ){\n        const { _endpoints } = self._owner;\n        return _endpoints && _endpoints[ self._ownerKey ];\n    }\n}\n\n/**\n * Create abortable promise.\n * Adds `promise.abort()` function which rejects the promise by default\n * initialize() function takes third optional argument `abort : ( resolve, reject ) => void`,\n * which can be used to add custom abort handling.\n */\ndeclare var Promise: PromiseConstructorLike;\n\nexport function createIOPromise( initialize : InitIOPromise ) : IOPromise<any>{\n    let resolve, reject, onAbort;\n\n    function abort( fn ){\n        onAbort = fn;\n    }\n\n    const promise : IOPromise<any> = new Promise( ( a_resolve, a_reject ) =>{\n        reject = a_reject;\n        resolve = a_resolve;\n        initialize( resolve, reject, abort );\n    }) as IOPromise<any>;\n\n    promise.abort = () => {\n        onAbort ? onAbort( resolve, reject ) : reject( new Error( \"I/O Aborted\" ) );\n    }\n\n    return promise;\n}\n\nexport type InitIOPromise = ( resolve : ( x? : any ) => void, reject : ( x? : any ) => void, abort? : ( fn : Function ) => void ) => void;\n\nexport function startIO( self : IONode, promise : IOPromise<any>, options : IOOptions, thenDo : ( json : any ) => any ) : IOPromise<any> {\n    // Stop pending I/O first...\n    abortIO( self );\n\n    // Mark future update transaction as IO transaction.\n    options.ioUpdate = true;\n\n    self._ioPromise = promise\n        .then( resp => {\n            self._ioPromise = null;\n    \n            const result = thenDo ? thenDo( resp ) : resp;\n                \n            triggerAndBubble( self, 'sync', self, resp, options );\n                \n            return result;\n        } )  \n        .catch( err => {\n            self._ioPromise = null;\n\n            console.error( err );\n            \n            triggerAndBubble( self, 'error', self, err, options );\n            \n            throw err;\n        } ) as IOPromise<any>;\n\n    self._ioPromise.abort = promise.abort;\n\n    return self._ioPromise;\n}\n\nexport function abortIO( self : IONode ){\n    if( self._ioPromise && self._ioPromise.abort ){\n        self._ioPromise.abort();\n        self._ioPromise = null;\n    }\n}\n\nexport function triggerAndBubble( eventSource, ...args ){\n    eventSource.trigger.apply( eventSource, args );\n    const { collection } = eventSource;\n    collection && collection.trigger.apply( collection, args ); \n}","import { IOEndpoint, IOPromise, createIOPromise } from '../io-tools'\n\nexport type Index = ( number | string )[];\n\nexport function create( init = [], delay = 50 ){\n    return new MemoryEndpoint( init, delay );\n}\n\nexport { create as memoryIO };\n\nexport class MemoryEndpoint implements IOEndpoint {\n    resolve( value ){\n        return createIOPromise( ( resolve, reject ) => {\n            setTimeout( () => resolve( value ), this.delay );\n        });\n    }\n    \n    reject( value ){\n        return createIOPromise( ( resolve, reject ) => {\n            setTimeout( () => reject( value ), this.delay );\n        });\n    }\n\n    constructor( init : object[], public delay : number ){\n        for( let obj of init ){\n            this.create( obj, {} );\n        }\n    }\n\n    index : Index = [ 0 ];\n    items = {};\n\n    generateId( a_id ){\n        // Update index counter...\n        const id = Number( a_id );\n        if( !isNaN( id ) ){\n            this.index[ 0 ] = Math.max( this.index[ 0 ] as number, id );\n        }\n\n        // Return id...\n        return a_id || String( ( this.index[ 0 ] as number ) ++ );\n    }\n\n    create( json, options ) {\n        const id = json.id = this.generateId( json.id );\n        this.index.push( id );\n        this.items[ id ] = json;\n        return this.resolve({ id });\n    }\n\n    update( id, json, options ) {\n        this.items[ id ] = json;\n        return this.resolve( {} );\n    }\n\n    read( id, options ){\n        const existing = this.items[ id ];\n        return existing ?\n            this.resolve( existing ) : \n            this.reject( \"Not found\" );\n    }\n\n    destroy( id, options ){\n        const existing = this.items[ id ];\n        if( existing ){\n            delete this.items[ id ];\n            this.index = this.index.filter( x => x !== id );\n            return this.resolve( {} );\n        }\n        else{\n            return this.reject( \"Not found\" );\n        }\n    }\n\n    list( options? : object ) {\n        return this.resolve( this.index.slice( 1 ).map( id => this.items[ id ]) );\n    }\n\n    subscribe( events ) : any {}\n    unsubscribe( events) : any {}\n}"],"names":["initialize","fn","onAbort","resolve","reject","promise","Promise","a_resolve","a_reject","abort","Error","init","delay","MemoryEndpoint","this","init_1","_i","obj","create","value","createIOPromise","setTimeout","_this","a_id","id","Number","isNaN","index","Math","max","String","json","options","generateId","push","items","existing","filter","x","slice","map","events"],"mappings":"sMAmDiCA,GAG7B,WAAgBC,GACZC,EAAUD,EAHd,IAAIE,EAASC,EAAQF,EAMfG,EAA2B,IAAIC,QAAS,SAAEC,EAAWC,GAGvDR,EADAG,EAAUI,EADVH,EAASI,EAEoBC,KAOjC,OAJAJ,EAAQI,MAAQ,WACZP,EAAUA,EAASC,EAASC,GAAWA,EAAQ,IAAIM,MAAO,iBAGvDL,aChEaM,EAAWC,GAC/B,oBADoBD,mBAAWC,MACxB,IAAIC,EAAgBF,EAAMC,GAGrC,iBAeI,WAAaD,EAAwBC,GAAAE,WAAAF,EAMrCE,YAAkB,GAClBA,cANI,IAAgB,QAAAC,IAAAC,WAAAA,KAAX,IAAIC,OACLH,KAAKI,OAAQD,OAuDzB,OArEIJ,oBAAA,SAASM,GAAT,WACI,OAAOC,EAAiB,SAAEjB,EAASC,GAC/BiB,WAAY,WAAM,OAAAlB,EAASgB,IAASG,EAAKV,UAIjDC,mBAAA,SAAQM,GAAR,WACI,OAAOC,EAAiB,SAAEjB,EAASC,GAC/BiB,WAAY,WAAM,OAAAjB,EAAQe,IAASG,EAAKV,UAahDC,uBAAA,SAAYU,GAER,IAAMC,EAAKC,OAAQF,GAMnB,OALKG,MAAOF,KACRV,KAAKa,MAAO,GAAMC,KAAKC,IAAKf,KAAKa,MAAO,GAAeH,IAIpDD,GAAQO,OAAUhB,KAAKa,MAAO,OAGzCd,mBAAA,SAAQkB,EAAMC,GACV,IAAMR,EAAKO,EAAKP,GAAKV,KAAKmB,WAAYF,EAAKP,IAG3C,OAFAV,KAAKa,MAAMO,KAAMV,GACjBV,KAAKqB,MAAOX,GAAOO,EACZjB,KAAKX,SAAUqB,QAG1BX,mBAAA,SAAQW,EAAIO,EAAMC,GAEd,OADAlB,KAAKqB,MAAOX,GAAOO,EACZjB,KAAKX,aAGhBU,iBAAA,SAAMW,EAAIQ,GACN,IAAMI,EAAWtB,KAAKqB,MAAOX,GAC7B,OAAOY,EACHtB,KAAKX,QAASiC,GACdtB,KAAKV,OAAQ,cAGrBS,oBAAA,SAASW,EAAIQ,GAET,OADiBlB,KAAKqB,MAAOX,WAElBV,KAAKqB,MAAOX,GACnBV,KAAKa,MAAQb,KAAKa,MAAMU,OAAQ,SAAAC,GAAK,OAAAA,IAAMd,IACpCV,KAAKX,aAGLW,KAAKV,OAAQ,cAI5BS,iBAAA,SAAMmB,GAAN,WACI,OAAOlB,KAAKX,QAASW,KAAKa,MAAMY,MAAO,GAAIC,IAAK,SAAAhB,GAAM,OAAAF,EAAKa,MAAOX,OAGtEX,sBAAA,SAAW4B,KACX5B,wBAAA,SAAa4B"}