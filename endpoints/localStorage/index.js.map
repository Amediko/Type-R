{"version":3,"file":"index.js","sources":["../../src/io-tools.ts","../../src/endpoints/localStorage.ts"],"sourcesContent":["export interface IONode {\n    _endpoint : IOEndpoint\n    _ioPromise : IOPromise< any >\n}\n\nexport interface IOPromise<T> extends Promise<T> {\n    abort? : () => void\n}\n\nexport interface IOEndpoint {\n    list( options : IOOptions, collection? ) : IOPromise<any>\n    create( json : any, options : IOOptions, record? ) : IOPromise<any>\n    update( id : string | number, json :any, options : IOOptions, record? ) : IOPromise<any>\n    read( id : string | number, options : IOOptions, record? ) : IOPromise<any>\n    destroy( id : string | number, options : IOOptions, record? ) : IOPromise<any>\n    subscribe( events : IOEvents, collection? ) : IOPromise<any>\n    unsubscribe( events : IOEvents, collection? ) : void\n}\n\nexport interface IOOptions {\n    ioUpdate? : boolean\n}\n\nexport interface IOEvents {\n    updated? : ( json : any ) => void\n    removed? : ( json : any ) => void\n}\n\nexport function getOwnerEndpoint( self ) : IOEndpoint {\n    // Check if we are the member of the collection...\n    const { collection } = self;\n    if( collection ){\n        return getOwnerEndpoint( collection );\n    }\n\n    // Now, if we're the member of the model...\n    if( self._owner ){\n        const { _endpoints } = self._owner;\n        return _endpoints && _endpoints[ self._ownerKey ];\n    }\n}\n\n/**\n * Create abortable promise.\n * Adds `promise.abort()` function which rejects the promise by default\n * initialize() function takes third optional argument `abort : ( resolve, reject ) => void`,\n * which can be used to add custom abort handling.\n */\ndeclare var Promise: PromiseConstructorLike;\n\nexport function createIOPromise( initialize : InitIOPromise ) : IOPromise<any>{\n    let resolve, reject, onAbort;\n\n    function abort( fn ){\n        onAbort = fn;\n    }\n\n    const promise : IOPromise<any> = new Promise( ( a_resolve, a_reject ) =>{\n        reject = a_reject;\n        resolve = a_resolve;\n        initialize( resolve, reject, abort );\n    }) as IOPromise<any>;\n\n    promise.abort = () => {\n        onAbort ? onAbort( resolve, reject ) : reject( new Error( \"I/O Aborted\" ) );\n    }\n\n    return promise;\n}\n\nexport type InitIOPromise = ( resolve : ( x? : any ) => void, reject : ( x? : any ) => void, abort? : ( fn : Function ) => void ) => void;\n\nexport function startIO( self : IONode, promise : IOPromise<any>, options : IOOptions, thenDo : ( json : any ) => any ) : IOPromise<any> {\n    // Stop pending I/O first...\n    abortIO( self );\n\n    // Mark future update transaction as IO transaction.\n    options.ioUpdate = true;\n\n    self._ioPromise = promise\n        .then( resp => {\n            self._ioPromise = null;\n    \n            const result = thenDo ? thenDo( resp ) : resp;\n                \n            triggerAndBubble( self, 'sync', self, resp, options );\n                \n            return result;\n        } )  \n        .catch( err => {\n            self._ioPromise = null;\n\n            console.error( err );\n            \n            triggerAndBubble( self, 'error', self, err, options );\n            \n            throw err;\n        } ) as IOPromise<any>;\n\n    self._ioPromise.abort = promise.abort;\n\n    return self._ioPromise;\n}\n\nexport function abortIO( self : IONode ){\n    if( self._ioPromise && self._ioPromise.abort ){\n        self._ioPromise.abort();\n        self._ioPromise = null;\n    }\n}\n\nexport function triggerAndBubble( eventSource, ...args ){\n    eventSource.trigger.apply( eventSource, args );\n    const { collection } = eventSource;\n    collection && collection.trigger.apply( collection, args ); \n}","import { IOEndpoint, IOOptions, IOPromise, createIOPromise } from '../io-tools'\n\nexport type Index = number[];\n\nexport function create( key : string ){\n    return new LocalStorageEndpoint( key );\n}\n\nexport { create as localStorageIO }\n\nexport class LocalStorageEndpoint implements IOEndpoint {\n    constructor( public key : string ){\n    }\n\n    resolve( value ){\n        return createIOPromise( ( resolve, reject ) => {\n            setTimeout( () =>{\n                resolve( value )\n            }, 0 );\n        });\n    }\n    \n    reject( value ){\n        return createIOPromise( ( resolve, reject ) => {\n            setTimeout( () => reject( value ), 0 );\n        });\n    }\n\n    create( json, options : IOOptions ) {\n        const { index } = this;\n        index.push( json.id = String( ( index[ 0 ] as number )++ ) );\n        this.index = index;\n        this.set( json );\n        return this.resolve({ id : json.id });\n    }\n\n    set( json ){\n        localStorage.setItem( this.key + '#' + json.id, JSON.stringify( json ) );\n    }\n\n    get( id ){\n        return JSON.parse( localStorage.getItem( this.key + '#' + id ) );\n    }\n\n    update( id, json, options : IOOptions ) {\n        json.id = id;\n        this.set( json );\n        return this.resolve( {} );\n    }\n\n    read( id, options : IOOptions ){\n        const existing = this.get( id );\n        return existing ?\n            this.resolve( existing ) : \n            this.reject( \"Not found\" );\n    }\n\n    destroy( id, options : IOOptions ){\n        const existing = this.get( id );\n        if( existing ){\n            localStorage.removeItem( this.key + '#' + id );\n            this.index = this.index.filter( x => x !== id );\n            return this.resolve( {} );\n        }\n        else{\n            return this.reject( \"Not found\" );\n        }\n    }\n\n    get index() : ( string | number )[]{\n        return JSON.parse( localStorage.getItem( this.key ) ) || [ 0 ];\n    }\n\n    set index( x ){\n        localStorage.setItem( this.key, JSON.stringify( x ) );\n    }\n\n    list( options? : IOOptions ) {\n        const { index } = this; \n        return this.resolve( this.index.slice( 1 ).map( id => this.get( id ) ) );\n    }\n\n    subscribe( events ) : any {}\n    unsubscribe( events) : any {}\n}"],"names":["initialize","fn","onAbort","resolve","reject","promise","Promise","a_resolve","a_reject","abort","Error","key","LocalStorageEndpoint","this","value","createIOPromise","setTimeout","json","options","index","push","id","String","set","localStorage","setItem","JSON","stringify","parse","getItem","existing","get","removeItem","filter","x","Object","slice","map","_this","events"],"mappings":"4MAkDiCA,GAG7B,WAAgBC,GACZC,EAAUD,EAHd,IAAIE,EAASC,EAAQF,EAMfG,EAA2B,IAAIC,QAAS,SAAEC,EAAWC,GAGvDR,EADAG,EAAUI,EADVH,EAASI,EAEoBC,KAOjC,OAJAJ,EAAQI,MAAQ,WACZP,EAAUA,EAASC,EAASC,GAAWA,EAAQ,IAAIM,MAAO,iBAGvDL,aC/DaM,GACpB,OAAO,IAAIC,EAAsBD,GAGrC,iBAGI,WAAoBA,GAAAE,SAAAF,EAyExB,OAtEIC,oBAAA,SAASE,GACL,OAAOC,EAAiB,SAAEZ,EAASC,GAC/BY,WAAY,WACRb,EAASW,IACV,MAIXF,mBAAA,SAAQE,GACJ,OAAOC,EAAiB,SAAEZ,EAASC,GAC/BY,WAAY,WAAM,OAAAZ,EAAQU,IAAS,MAI3CF,mBAAA,SAAQK,EAAMC,GACF,IAAAC,aAIR,OAHAA,EAAMC,KAAMH,EAAKI,GAAKC,OAAUH,EAAO,OACvCN,KAAKM,MAAQA,EACbN,KAAKU,IAAKN,GACHJ,KAAKV,SAAUkB,GAAKJ,EAAKI,MAGpCT,gBAAA,SAAKK,GACDO,aAAaC,QAASZ,KAAKF,IAAM,IAAMM,EAAKI,GAAIK,KAAKC,UAAWV,KAGpEL,gBAAA,SAAKS,GACD,OAAOK,KAAKE,MAAOJ,aAAaK,QAAShB,KAAKF,IAAM,IAAMU,KAG9DT,mBAAA,SAAQS,EAAIJ,EAAMC,GAGd,OAFAD,EAAKI,GAAKA,EACVR,KAAKU,IAAKN,GACHJ,KAAKV,aAGhBS,iBAAA,SAAMS,EAAIH,GACN,IAAMY,EAAWjB,KAAKkB,IAAKV,GAC3B,OAAOS,EACHjB,KAAKV,QAAS2B,GACdjB,KAAKT,OAAQ,cAGrBQ,oBAAA,SAASS,EAAIH,GAET,OADiBL,KAAKkB,IAAKV,IAEvBG,aAAaQ,WAAYnB,KAAKF,IAAM,IAAMU,GAC1CR,KAAKM,MAAQN,KAAKM,MAAMc,OAAQ,SAAAC,GAAK,OAAAA,IAAMb,IACpCR,KAAKV,aAGLU,KAAKT,OAAQ,cAI5B+B,sBAAIvB,yBAAJ,WACI,OAAOc,KAAKE,MAAOJ,aAAaK,QAAShB,KAAKF,QAAa,QAG/D,SAAWuB,GACPV,aAAaC,QAASZ,KAAKF,IAAKe,KAAKC,UAAWO,qCAGpDtB,iBAAA,SAAMM,GAAN,WACY,OACDL,KAAKV,QAASU,KAAKM,MAAMiB,MAAO,GAAIC,IAAK,SAAAhB,GAAM,OAAAiB,EAAKP,IAAKV,OAGpET,sBAAA,SAAW2B,KACX3B,wBAAA,SAAa2B"}