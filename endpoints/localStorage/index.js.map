{"version":3,"file":"index.js","sources":["../../src/io-tools.ts","../../src/endpoints/localStorage.ts"],"sourcesContent":["export interface IONode {\n    _endpoint : IOEndpoint\n    _ioPromise : IOPromise< any >\n}\n\nexport interface IOPromise<T> extends Promise<T> {\n    abort() : void\n}\n\nexport interface IOEndpoint {\n    list( options : object ) : IOPromise<any>\n    create( json : any, options : object ) : IOPromise<any>\n    update( id : string | number, json :any, options : object ) : IOPromise<any>\n    read( id : string | number, options : object ) : IOPromise<any>\n    destroy( id : string | number, options : object ) : IOPromise<any>\n    subscribe( events : IOEvents ) : IOPromise<any>\n    unsubscribe( events : IOEvents ) : void\n}\n\nexport interface IOEvents {\n    updated? : ( json : any ) => void\n    removed? : ( json : any ) => void\n}\n\nexport function getOwnerEndpoint( self ) : IOEndpoint {\n    // Check if we are the member of the collection...\n    const { collection } = self;\n    if( collection ){\n        return getOwnerEndpoint( collection );\n    }\n\n    // Now, if we're the member of the model...\n    if( self._owner ){\n        const { _endpoints } = self._owner;\n        return _endpoints && _endpoints[ self._ownerKey ];\n    }\n}\n\n/**\n * Create abortable promise.\n * Adds `promise.abort()` function which rejects the promise by default\n * initialize() function takes third optional argument `abort : ( resolve, reject ) => void`,\n * which can be used to add custom abort handling.\n */\ndeclare var Promise: PromiseConstructorLike;\n\nexport function createIOPromise( initialize : InitIOPromise ) : IOPromise<any>{\n    let resolve, reject, onAbort;\n\n    function abort( fn ){\n        onAbort = fn;\n    }\n\n    const promise : IOPromise<any> = new Promise( ( a_resolve, a_reject ) =>{\n        reject = a_reject;\n        resolve = a_resolve;\n        initialize( resolve, reject, abort );\n    }) as IOPromise<any>;\n\n    promise.abort = () => {\n        onAbort ? onAbort( resolve, reject ) : reject( new Error( \"I/O Aborted\" ) );\n    }\n\n    return promise;\n}\n\nexport type InitIOPromise = ( resolve : ( x? : any ) => void, reject : ( x? : any ) => void, abort? : ( fn : Function ) => void ) => void;\n\nexport function startIO( self : IONode, promise : IOPromise<any>, options : object, thenDo : ( json : any ) => any ) : IOPromise<any> {\n    // Stop pending I/O first...\n    abortIO( self );\n    \n    self._ioPromise = promise\n        .then( resp => {\n            self._ioPromise = null;\n    \n            const result = thenDo ? thenDo( resp ) : resp;\n                \n            triggerAndBubble( self, 'sync', self, resp, options );\n                \n            return result;\n        } )  \n        .catch( err => {\n            self._ioPromise = null;\n\n            console.error( err );\n            \n            triggerAndBubble( self, 'error', self, err, options );\n            \n            throw err;\n        } ) as IOPromise<any>;\n\n    self._ioPromise.abort = promise.abort;\n\n    return self._ioPromise;\n}\n\nexport function abortIO( self : IONode ){\n    if( self._ioPromise && self._ioPromise.abort ){\n        self._ioPromise.abort();\n        self._ioPromise = null;\n    }\n}\n\nexport function triggerAndBubble( eventSource, ...args ){\n    eventSource.trigger.apply( eventSource, args );\n    const { collection } = eventSource;\n    collection && collection.trigger.apply( collection, args ); \n}","import { IOEndpoint, IOPromise, createIOPromise } from '../io-tools'\n\nexport type Index = number[];\n\nexport function create( key : string, delay = 1000 ){\n    return new LocalStorageEndpoint( key, delay );\n}\n\nexport { create as localStorageIO }\n\nexport class LocalStorageEndpoint implements IOEndpoint {\n    constructor( public key : string, public delay : number ){\n    }\n\n    resolve( value ){\n        return createIOPromise( ( resolve, reject ) => {\n            setTimeout( () => resolve( value ), this.delay );\n        });\n    }\n    \n    reject( value ){\n        return createIOPromise( ( resolve, reject ) => {\n            setTimeout( () => reject( value ), this.delay );\n        });\n    }\n\n    create( json, options ) {\n        const { index } = this;\n        index.push( json.id = String( ( index[ 0 ] as number )++ ) );\n        this.index = index;\n        this.set( json );\n        return this.resolve({ id : json.id });\n    }\n\n    set( json ){\n        localStorage.setItem( this.key + '#' + json.id, JSON.stringify( json ) );\n    }\n\n    get( id ){\n        return JSON.parse( localStorage.getItem( this.key + '#' + id ) );\n    }\n\n    update( id, json, options ) {\n        const existing = this.get( id );\n        if( existing ){\n            json.id = id;\n            this.set( json );\n            return this.resolve( {} );\n        }\n        else{\n            return this.reject( \"Not found\");\n        }\n    }\n\n    read( id, options ){\n        const existing = this.get( id );\n        return existing ?\n            this.resolve( existing ) : \n            this.reject( \"Not found\" );\n    }\n\n    destroy( id, options ){\n        const existing = this.get( id );\n        if( existing ){\n            localStorage.removeItem( id );\n            this.index = this.index.filter( x => x !== id );\n            return this.resolve( {} );\n        }\n        else{\n            return this.reject( \"Not found\" );\n        }\n    }\n\n    get index() : ( string | number )[]{\n        return JSON.parse( localStorage.getItem( this.key ) ) || [ 0 ];\n    }\n\n    set index( x ){\n        localStorage.setItem( this.key, JSON.stringify( x ) );\n    }\n\n    list( options? : object ) {\n        const { index } = this; \n        return this.resolve( this.index.slice( 1 ).map( id => this.get( id ) ) );\n    }\n\n    subscribe( events ) : any {}\n    unsubscribe( events) : any {}\n}"],"names":["initialize","fn","onAbort","resolve","reject","promise","Promise","a_resolve","a_reject","abort","Error","key","delay","LocalStorageEndpoint","this","value","createIOPromise","setTimeout","_this","json","options","index","push","id","String","set","localStorage","setItem","JSON","stringify","parse","getItem","get","existing","removeItem","filter","x","Object","slice","map","events"],"mappings":"4MA8CiCA,GAG7B,WAAgBC,GACZC,EAAUD,EAHd,IAAIE,EAASC,EAAQF,EAMfG,EAA2B,IAAIC,QAAS,SAAEC,EAAWC,GAGvDR,EADAG,EAAUI,EADVH,EAASI,EAEoBC,KAOjC,OAJAJ,EAAQI,MAAQ,WACZP,EAAUA,EAASC,EAASC,GAAWA,EAAQ,IAAIM,MAAO,iBAGvDL,aC3DaM,EAAcC,GAClC,oBADkCA,OAC3B,IAAIC,EAAsBF,EAAKC,GAG1C,iBAGI,WAAoBD,EAAqBC,GAArBE,SAAAH,EAAqBG,WAAAF,EA6E7C,OA1EIC,oBAAA,SAASE,GAAT,WACI,OAAOC,EAAiB,SAAEb,EAASC,GAC/Ba,WAAY,WAAM,OAAAd,EAASY,IAASG,EAAKN,UAIjDC,mBAAA,SAAQE,GAAR,WACI,OAAOC,EAAiB,SAAEb,EAASC,GAC/Ba,WAAY,WAAM,OAAAb,EAAQW,IAASG,EAAKN,UAIhDC,mBAAA,SAAQM,EAAMC,GACF,IAAAC,aAIR,OAHAA,EAAMC,KAAMH,EAAKI,GAAKC,OAAUH,EAAO,OACvCP,KAAKO,MAAQA,EACbP,KAAKW,IAAKN,GACHL,KAAKX,SAAUoB,GAAKJ,EAAKI,MAGpCV,gBAAA,SAAKM,GACDO,aAAaC,QAASb,KAAKH,IAAM,IAAMQ,EAAKI,GAAIK,KAAKC,UAAWV,KAGpEN,gBAAA,SAAKU,GACD,OAAOK,KAAKE,MAAOJ,aAAaK,QAASjB,KAAKH,IAAM,IAAMY,KAG9DV,mBAAA,SAAQU,EAAIJ,EAAMC,GAEd,OADiBN,KAAKkB,IAAKT,IAEvBJ,EAAKI,GAAKA,EACVT,KAAKW,IAAKN,GACHL,KAAKX,aAGLW,KAAKV,OAAQ,cAI5BS,iBAAA,SAAMU,EAAIH,GACN,IAAMa,EAAWnB,KAAKkB,IAAKT,GAC3B,OAAOU,EACHnB,KAAKX,QAAS8B,GACdnB,KAAKV,OAAQ,cAGrBS,oBAAA,SAASU,EAAIH,GAET,OADiBN,KAAKkB,IAAKT,IAEvBG,aAAaQ,WAAYX,GACzBT,KAAKO,MAAQP,KAAKO,MAAMc,OAAQ,SAAAC,GAAK,OAAAA,IAAMb,IACpCT,KAAKX,aAGLW,KAAKV,OAAQ,cAI5BiC,sBAAIxB,yBAAJ,WACI,OAAOe,KAAKE,MAAOJ,aAAaK,QAASjB,KAAKH,QAAa,QAG/D,SAAWyB,GACPV,aAAaC,QAASb,KAAKH,IAAKiB,KAAKC,UAAWO,qCAGpDvB,iBAAA,SAAMO,GAAN,WACY,OACDN,KAAKX,QAASW,KAAKO,MAAMiB,MAAO,GAAIC,IAAK,SAAAhB,GAAM,OAAAL,EAAKc,IAAKT,OAGpEV,sBAAA,SAAW2B,KACX3B,wBAAA,SAAa2B"}